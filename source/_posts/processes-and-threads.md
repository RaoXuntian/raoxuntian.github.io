---
title: 进程和线程
date: 2020-08-17 00:23:05
updated:
tags:
- OS
---

操作系统实在是硬伤，每次面试几乎都被问到进程和线程的区别，那就总结一下吧。

### 进程和线程的区别

根本区别：进程是操作系统**资源分配**的基本单位，而线程是**任务调度和执行**的基本单位。

**一个进程中可以有多个线程，他们共享进程的资源。**

在开销方面：每个进程都有**独立的代码和数据空间**（程序上下文），程序之间的切换会有**较大**的开销；线程可以看做轻量级的进程，同一类线程**共享代码和数据空间**，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的**开销小**。

<!--more-->

所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。**简而言之，一个程序至少有一个进程，一个进程至少有一个线程。**

内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

所以，在系统开销方面，由于创建或撤销进程时，系统都要为之分配或者回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。类似的，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需要保存和设置少量寄存器内容，开销很小。

包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

### 线程之间的通信

线程之间可以通过直接读写同一进程中的数据进行通信，但是进程间的通信需要借助IPC。

### 进程之间的通信

千万不要把进程的通信和进程的同步混淆。

- 进程同步：控制多个进程按照一定的顺序执行。
- 进程通信：进程间的传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

进程的通信有以下几种：

- 管道

  - 只支持半双通信

  - 只能在父子进程中使用

- FIFO

  也叫命名管道，去除了管道只能在父子进程中使用的限制。

  FIFO常用于C/S应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。

- 消息队列

  相比于FIFO，消息队列具有以下优点：

  - 消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难
  - 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法
  - 读进程可以根据消息类型有选择地接受消息，而不像FIFO那样只能默认地接受。

- 信号量

  它是一个计数器，用于为多个进程提供对共享数据对象的访问。

- 共享存储

  允许多个进程共享一个给定的存储区。因为数据不需要在进程之间进行复制，所以这是最快的一种IPC

  需要使用信号量来同步对共享存储的访问。

- 套接字

  套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

  套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。

### 孤儿进程和僵尸进程

​		我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

　　**孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。**

　　**僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。**

#### 问题和危害

​		unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，**如果进程不调用wait / waitpid的话，** **那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。**

　　**孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上**，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。**因此孤儿进程并不会有什么危害。**

　　**任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。**这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

　　僵尸进程危害场景：

　　例如有个进程，它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵尸进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是**把产生大量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）**。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。

### 参考文章

- [进程和线程的主要区别（总结）](https://blog.csdn.net/kuangsonghan/article/details/80674777)
- [腾讯面试题04.进程和线程的区别？](https://blog.csdn.net/mxsgoden/article/details/8821936)
- [进程间通信IPC (InterProcess Communication)](https://www.jianshu.com/p/c1015f5ffa74)
- [孤儿进程与僵尸进程总结](https://www.cnblogs.com/Anker/p/3271773.html)
- https://cyc2018.github.io/CS-Notes/#/

