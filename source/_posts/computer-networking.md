---

title: 计网面试题目梳理
date: 2020-06-23 15:52:29
updated: 2020-06-28
tags:
- 计算机网络
- interview
---

计算机网络。

重要性不言而喻。

考研的那几本书都快翻烂了，书上的东西虽不敢说理解了100%，理解了个60%还是有的。

背是不可能背下来的，这辈子都不可能死记硬背的，最多面试前突击记一下……那就来看看哪些需要记忆的吧~

<!--more-->

### 一.计算机网络体系结构

{% asset_img 1.png  image %}

我们主要讨论的还是OSI七层模型：

{% asset_img 2.png  image %}

##### Q1.OSI七层模型的作用

1. 应用层(数据):确定进程之间通信的性质以满足用户需要以及提供网络与用户应用；
2. 表示层(数据):主要解决拥护信息的语法表示问题，如加密解密；
3. 会话层(数据):提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的；
4. 传输层(段):实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等；
5. 网络层(包):提供逻辑地址(IP)、选路，数据从源端到目的端的传输；
6. 数据链路层(帧):将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正；
7. 物理层(比特流):设备之间比特流的传输，物理接口，电气特性等。

##### Q2.各层使用的是哪个数据交换设备(交换机、路由器、网关)

1. 网关:应用层、传输层(网关在传输层上以实现网络互连，是最复杂的网络互连设 备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是 互连层。网关既可以用于广域网互连，也可以用于局域网互连)；
2. 路由器:网络层(路由选择、存储转发)；
3. 交换机:数据链路层、网络层(识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中)；
4. 网桥:数据链路层(将两个 LAN 连起来，根据 MAC 地址来转发帧)；
5. 集线器(Hub):物理层(纯硬件设备，主要用来连接计算机等网络终端)；
6. 中继器:物理层(在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离)。

面试最喜欢问的主要就四个相关协议，TCP、UDP、IP、HTTP，简单记录一些相关问题吧。

### 二.IP

IP协议在网络层，同在网络层的还有DNS、ARP、ICMP等IP相关协议。

##### Q3.什么是IP协议

**IP即网际协议，处在OSI七层模型中的网络层，网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点(end-to-end) 通信”。**网络层的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进 行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同 的数据链路上也能实现两端节点之间的数据包传输。

IP大致分为三大作用模块，它们是**IP寻址**、**路由**(最终节点为止的转发)以及**IP分包与组包**。

IP数据报的格式：

{% asset_img 3.png  image %}

- 版本 : 有 4(IPv4)和 6(IPv6)两个值;

- 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长 度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。

- 总长度 : 包括首部长度和数据部分长度。

- 生存时间 :TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。

- 协议 :指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。

- 首部检验和 :因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算 的工作量。

- 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。

- 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。


数据报分片的举例

{% asset_img 4.png  image %}

##### Q4.IPv4和IPv6的区别

- 地址空间不同，IPv4中规定IP地址长度为32，而IPv6中IP地址的长度为128。

- 路由表大小不同，IPv6的路由表相比IPv4的更小。

- IPv6的组播支持以及对流的支持要强于IPv4。

- 安全性不同，IPv6的安全性更高，在使用IPv6的网络时，用户可对网络层的数据进行加密。

- 协议扩充不同，IPv6允许协议进行扩充而IPv4不允许。



### 三.TCP/UDP

TCP/IP中有两个具有代表性的传输层协议，它们分别是TCP和UDP。TCP提供可靠的通信传输，而UDP 则常被用于让广播和细节控制交给应用的通信传输。总之，根据通信的具体特征，选择合适的传输层协议是非常重要的。

##### Q5.TCP和UDP的特点和区别

**用户数据报协议 UDP（User Datagram Protocol）**

是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

**传输控制协议 TCP（Transmission Control Protocol）**

是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。



1. TCP 面向连接，UDP 面向无连接(无需建立连接)
2. TCP 面向字节流，UDP 面向报文
3. TCP 提供可靠传输服务(数据顺序、正确性)，UDP 传输不可靠
4. TCP 协议传输速度慢，UDP 协议传输速度快
5. TCP 协议对系统资源要求多(头部开销大)，UDP 协议要求少



#### UDP

##### Q6.UDP校验和怎么计算

UDP 的校验和要计算首部和数据部分。首部还包括伪首部。

{% asset_img 5.png  image %}

多了 12 个字节的伪首部。
 注意点:UDP 长度计算两次。
 如果检验和有错，则 UDP 数据报被悄悄丢弃，不产生任何差错报文。

##### Q7.UDP为什么要加伪首部

目的是让 UDP 两次检查数据是否已经正确到达目的地。
 IP 接受正确的目的地址，传送到正确的上层程序。 所有伪首部包括:源 IP 地址，目的 IP 地址，0，协议号，UDP 长度。

还有一个原因：**TCP/IP或UDP/IP通信中通常采用5个信息来识别(这个信息可以在Unix或Windows系统中通过 netstat -n 命令显示。)一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端 口号”。只要其中某一项不同，则被认为是其他通信。**

TCP/IP中识别一个进行通信的应用需要5大要素，它们分别为“源IP地址”、“目标IP地址”、“源端 口”、“目标端口”、“协议号”。然而，在UDP的首部中只包含它们当中的两项(源端口和目标端口)，余下的3项都包含在IP首部里。

假定其他3项的信息被破坏会产生什么样的后果呢?很显然，这极有可能会导致应该收包的应用收不到包，不该收到包的应用却收到了包。

为了避免这类问题，有必要验证一个通信中必要的5项识别码是否正确。为此，在校验和的计算中就引入了伪首部的概念。

此外，IPv6中的IP首部没有校验和字段。TCP或UDP通过伪首部，得以对5项数字进行校验，从而实 现即使在IP首部并不可靠的情况下仍然能够提供可靠的通信传输。



#### TCP

##### Q8.TCP通过哪些方式来保证传输的可靠性

1.  应用数据被分割成 TCP 认为最适合发送的数据块。
2. 确认机制，发送报文后，等待确认。
3. 重发机制，没有收到确认，将重发数据段。
4. 保持它首部和数据的校验和。确认数据的准确性。
5. 排序，丢弃重复的，流量控制。



##### Q9.TCP的流量控制机制

主要是下面的四种机制:

**慢启动(慢开始)**:

1. 慢开始不是指 cwnd 的增长速度慢(指数增长)，而是指 TCP 开始发送设置 cwnd=1。 

2. 思路:不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。

3. 为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量) 当 cnwd<ssthresh，使用慢开始算法
    当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
    当 cnwd>ssthresh，使用拥塞避免算法

**拥塞避免**:

1. 拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。

2. 思路:让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控制窗口加一。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理)，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口 设置为 1，执行慢开始算法。 如图所示:

{% asset_img 6.png  image %}

**快速重传**:

1. 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

2. 由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。

**快速恢复**:

1. 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。 但是接下去并不执行慢开始算法。
2. 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小， 然后执行拥塞避免算法。

##### Q10.TCP的三次握手和四次挥手

**TCP三次握手**

{% asset_img 7.png  image %}

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN(监听)状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时 也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

**三次握手的原因** 

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待 一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握 手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确 认，不进行第三次握手，因此就不会再次打开连接。

**TCP四次挥手**

{% asset_img 8.png  image %}

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都 为 1。

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL(最大报文存活时间)后释放连接。
- B 收到 A 的确认后释放连接。

**四次挥手的原因**
客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 

TIME_WAIT

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由:

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文， A 等待一段时间就是为了处理这种情况的发生。 
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。



##### Q11.服务器端突然出现大量的CLOSE_WAIT状态是什么原因

（这个题是我在面试百度时被问过，当时直接懵逼……太菜了  : ( 

服务器端出现大量的CLOSE_WAIT状态，说明服务器端没有发送FIN报文，也就是说服务器端的某些进程并没有结束导致服务器端没能向客户端发送FIN报文，通过网上查找资料总结了以下可能的原因：

- 服务器端连接了SQL等数据库，执行完之后没有关闭连接；
- 服务器端的代码，socket连接，没有写close函数关闭连接，或者出现死循环，服务器端的代码永远执行不到 close。
- 客户机响应太慢或者 timeout 设置过小，当服务器端发生阻塞的时候，客户端发出的请求一直在等待，当超时之后就会抛出异常，关闭连接，关闭连接导致客户端发送了FIN报文，但是由于服务器端处理请求的线程还处于阻塞的状态，所以当前的连接状态处于CLOSE_WAIT。



### 四.HTTP

##### Q12.GET和POST的区别

**作用**

GET 用于获取资源，而 POST 用于传输实体主体。

**参数**

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在 实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具 (Fiddler)查看。

因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 `中文` 会转换为 `%E4%B8%AD%E6%96%87` ，而`空格`会转换为 `%20` 。POST 参数支持标准字符集。

```
GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1
```

```
POST /test/demo_form.asp HTTP/1.1 
Host: w3schools.com 
name1=value1&name2=value2
```

**安全**

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。

GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数 据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

安全的方法除了 GET 之外还有:HEAD、OPTIONS。

不安全的方法除了 POST 之外还有 PUT、DELETE。

| 操作方式 | 数据位置 | 明文密文 | 数据安全 | 长度限时         | 应用场景 |
| -------- | -------- | -------- | -------- | ---------------- | -------- |
| GET      | HTTP报头 | 明文     | 不安全   | 长度较小         | 查询数据 |
| POST     | HTTP正文 | 可明可密 | 安全     | 支持较大数据传输 | 修改数据 |



##### Q13.用浏览器打开一个网页的过程

(假设主机一开始没有分配IP地址)整个过程可以概括为以下几步：

1. DHCP协议自动分配主机IP地址；
2. DNS域名解析URL网页的IP地址；
3. 应用层客户端(浏览器)发送HTTP请求；
4. 传输层TCP三次握手建立连接，传输报文；
5. 网络层IP协议把TCP分割好的各种数据包封装到IP包里面传送给接收方，ARP协议将IP地址解析为MAC地址；
6. 得到下一个(不一定是目的)MAC地址后，数据链路层将IP包封装到数据帧结构中，再通过物理层的比特流送出去（至此客户端发送请求的阶段结束）；
7. 服务器接收数据，在数据链路层接收到数据报，层层向上直到应用层。这过程中包括在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文；
8. 服务器响应请求并返回相应文件；
9. 浏览器开始处理数据信息并渲染页面；
10. 将渲染好的页面图像显示出来，并开始响应用户的操作。



### 五.参考文章

- https://github.com/CyC2018/CS-Notes
- 计算机网络·自顶向下方法 第六版
- 图解TCP/IP 第五版
- [“三次握手，四次挥手”你真的懂吗？](https://www.cnblogs.com/qcrao-2018/p/10182185.html)
- [一次服务端大量CLOSE_WAIT问题的解决](https://blog.csdn.net/yu616568/article/details/44677985)
- [出现过多的close_wait可能是什么原因？](https://blog.csdn.net/qq_33528613/article/details/84987469)
- [浏览器工作原理：从 URL 输入到页面展现到底发生了什么？](https://www.jianshu.com/p/d616d887953a)

