<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈字节序</title>
      <link href="/2020/06/29/byte-order/"/>
      <url>/2020/06/29/byte-order/</url>
      
        <content type="html"><![CDATA[<p>我记得那场面了3个小时的腾讯面试，面试官出了一道颠倒字节序的题目，当时完全不懂……昨晚看书，看到书上讲到了寻址和字节顺序，方才恍然大悟，发现还是自己书读的不够多。</p><a id="more"></a><h3 id="一-大小端"><a href="#一-大小端" class="headerlink" title="一.大小端"></a>一.大小端</h3><p>计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。</p><p>举例来说，数值<code>0x2211</code>使用两个字节储存：高位字节是<code>0x22</code>，低位字节是<code>0x11</code>。</p><blockquote><ul><li><strong>大端字节序</strong>：高位字节在前，低位字节在后，这是人类读写数值的方法。</li><li><strong>小端字节序</strong>：低位字节在前，高位字节在后，即以<code>0x1122</code>形式储存。</li></ul></blockquote><img src="/2020/06/29/byte-order/1.jpg" class="" title="image"><p>同理，<code>0x1234567</code>的大端字节序和小端字节序的写法如下图。</p><img src="/2020/06/29/byte-order/2.gif" class="" title="image"><p>注意，在字<code>0x1234567</code>中，高位字节的十六进制为<code>0x01</code>，而低位字节值为<code>0x67</code>。</p><h3 id="二-计算机如何处理字节序"><a href="#二-计算机如何处理字节序" class="headerlink" title="二.计算机如何处理字节序"></a>二.计算机如何处理字节序</h3><p>大多数的Intel兼容机都只用小端模式。另一方面，IBM和Oracle（从其2010年收购Sun Microsystems开始）的大多数机器则是按大端模式操作。但注意我们说的只是“大多数”。这些规则并没有严格按照企业界限来划分。比如IBM和Oracle制造的个人计算机使用的是Intel兼容的处理器，因此使用小端法。许多比较新的微处理器是<code>双端法（bi-endian）</code>，也就是说可以把它们配置成作为大段或小端的机器运行。然而实际情况是一旦选择了特定的操作系统，那么字节顺序也就固定下来了。例如，许多移动电话的ARM微处理器，其硬件可以按照小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统——Android和iOS——却只能运行于小端模式。</p><p>显然大端法更符合人类的阅读习惯，那为什么要有小端法呢？</p><p>答案是，计算机电路先处理低位字节，效率比较高，<strong>因为计算都是从低位开始的</strong>。所以，计算机的内部处理都是小端字节序。</p><p>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p><p>计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。</p><p>如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。</p><p>理解这一点，才能理解计算机如何处理字节序。</p><p>字节序的处理，就是一句话：</p><blockquote><p><strong>“只有读取的时候，才必须区分字节序，其他情况都不用考虑。”</strong></p></blockquote><p>处理器读取外部数据的时候，必须知道数据的字节序，将其转成正确的值。然后，就正常使用这个值，完全不用再考虑字节序。</p><p>即使是向外部设备写入数据，也不用考虑字节序，正常写入一个值即可。外部设备会自己处理字节序的问题。</p><p>举例来说，处理器读入一个16位整数。如果是大端字节序，就按下面的方式转成值。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = buf[offset] * <span class="number">256</span> + buf[offset+<span class="number">1</span>];</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>buf</code>是整个数据块在内存中的起始地址，<code>offset</code>是当前正在读取的位置。第一个字节乘以256，再加上第二个字节，就是大端字节序的值，这个式子可以用逻辑运算符改写。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = buf[offset]&lt;&lt;<span class="number">8</span> | buf[offset+<span class="number">1</span>];</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，第一个字节左移8位（即后面添8个<code>0</code>），然后再与第二个字节进行或运算。</p><p>如果是小端字节序，用下面的公式转成值。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = buf[offset+<span class="number">1</span>] * <span class="number">256</span> + buf[offset];</span><br></pre></td></tr></table></figure></blockquote><p>32位整数的求值公式也是一样的。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 大端字节序 */</span></span><br><span class="line">i = (data[<span class="number">3</span>]&lt;&lt;<span class="number">0</span>) | (data[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>) | (data[<span class="number">1</span>]&lt;&lt;<span class="number">16</span>) | (data[<span class="number">0</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 小端字节序 */</span></span><br><span class="line">i = (data[<span class="number">0</span>]&lt;&lt;<span class="number">0</span>) | (data[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>) | (data[<span class="number">2</span>]&lt;&lt;<span class="number">16</span>) | (data[<span class="number">3</span>]&lt;&lt;<span class="number">24</span>);</span><br></pre></td></tr></table></figure></blockquote><h3 id="三-判断自己的电脑的字节序"><a href="#三-判断自己的电脑的字节序" class="headerlink" title="三.判断自己的电脑的字节序"></a>三.判断自己的电脑的字节序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x\n"</span>, n);</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span>*)&amp;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %p\n"</span>, *(p+i), p+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*p==<span class="number">10</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Little-endian in this PC."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Big-endian in this PC."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (*(<span class="keyword">char</span> *) &amp;x ==<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Little endian!\n"</span>);</span><br><span class="line">  <span class="keyword">else</span>    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Big endian!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="number">10</span> <span class="number">0x7ffeef765b6c</span></span><br><span class="line"><span class="number">0</span> <span class="number">0x7ffeef765b6d</span></span><br><span class="line"><span class="number">0</span> <span class="number">0x7ffeef765b6e</span></span><br><span class="line"><span class="number">0</span> <span class="number">0x7ffeef765b6f</span></span><br><span class="line">Little-endian in <span class="keyword">this</span> PC.</span><br><span class="line">Little endian!</span><br></pre></td></tr></table></figure><h3 id="四-大小端的转换"><a href="#四-大小端的转换" class="headerlink" title="四.大小端的转换"></a>四.大小端的转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %.2x"</span>, start[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span> *x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">swapInt32</span><span class="params">(<span class="keyword">int32_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">           ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">           ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) |</span><br><span class="line">           ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data is %d\n"</span>, data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bytes order of data is"</span>);   show_int(data);</span><br><span class="line">    <span class="keyword">char</span>* pa = (<span class="keyword">char</span>*) &amp;data;</span><br><span class="line">    <span class="keyword">int</span> big_data = (pa[<span class="number">3</span>]&lt;&lt;<span class="number">0</span>) | (pa[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>) | (pa[<span class="number">1</span>]&lt;&lt;<span class="number">16</span>) | (pa[<span class="number">0</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">int</span> little_data = (pa[<span class="number">0</span>]&lt;&lt;<span class="number">0</span>) | (pa[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>) | (pa[<span class="number">2</span>]&lt;&lt;<span class="number">16</span>) | (pa[<span class="number">3</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"big_endian order data is %d\n"</span>, big_data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"little_endian order data is %d\n"</span>, little_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12345</span>;</span><br><span class="line">    show_int(<span class="number">12345</span>);</span><br><span class="line">    show_float(<span class="number">12345.6789</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    show_pointer(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0x01234567</span>;</span><br><span class="line">    read(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--------After swap bytes order--------\n"</span>);</span><br><span class="line">    data = swapInt32(data);</span><br><span class="line">    read(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">39</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"> b7 e6 <span class="number">40</span> <span class="number">46</span></span><br><span class="line"><span class="number">0x7ffee5f20b5c</span></span><br><span class="line"> <span class="number">5</span>c <span class="number">0b</span> f2 e5 fe <span class="number">7f</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">data is <span class="number">19088743</span></span><br><span class="line">bytes order of data is <span class="number">67</span> <span class="number">45</span> <span class="number">23</span> <span class="number">01</span></span><br><span class="line">big_endian order data is <span class="number">1732584193</span></span><br><span class="line">little_endian order data is <span class="number">19088743</span></span><br><span class="line">--------After swap bytes order--------</span><br><span class="line">data is <span class="number">1732584193</span></span><br><span class="line">bytes order of data is <span class="number">01</span> <span class="number">23</span> <span class="number">45</span> <span class="number">67</span></span><br><span class="line">big_endian order data is <span class="number">19088743</span></span><br><span class="line">little_endian order data is <span class="number">1732584193</span></span><br></pre></td></tr></table></figure><h3 id="五-参考文章"><a href="#五-参考文章" class="headerlink" title="五.参考文章"></a>五.参考文章</h3><ul><li><a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">理解字节序</a></li><li>深入理解计算机系统</li><li><a href="https://blog.csdn.net/qq_37941471/article/details/81301536?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节 序</a></li><li><a href="https://blog.csdn.net/bitzhidu/article/details/106332088" target="_blank" rel="noopener">【百度笔试题】简述大小端字节序的概念并写一个小程序检测当前机器的大小端字节序</a></li><li><a href="https://blog.csdn.net/kuai0705/article/details/20841133" target="_blank" rel="noopener">［c/c++ ］字节序与大小端转换</a></li><li><a href="https://blog.csdn.net/sunboyiris/article/details/77574566" target="_blank" rel="noopener">C/C++ 大小端理解及转换</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 字节序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C/C++整型上下限INT_MAX和INT_MIN及其运算</title>
      <link href="/2020/06/28/INT-MAX-INT-MIN/"/>
      <url>/2020/06/28/INT-MAX-INT-MIN/</url>
      
        <content type="html"><![CDATA[<p>今天在刷题的时候，遇到几道关于处理32位有符号整数的题目：<a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7.整数反转</a>和 <a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8.字符串转换整数 (atoi)</a>。题目看起来不算很难，但如果在面试时遇到这样的题目，想想面试官是要考察你什么？考察你用long抖机灵吗？考察你会捕获异常吗？我想应该是要考察你对C/C++中整型的上下限的理解以及这方面的细节处理。</p><a id="more"></a><h3 id="一-整型数据类型和数据大小"><a href="#一-整型数据类型和数据大小" class="headerlink" title="一.整型数据类型和数据大小"></a>一.整型数据类型和数据大小</h3><p>说到整型数据类型，很多人第一反应就是int。</p><p>int占4个字节，1个字节通常是占8位，所以一个int占32位，根据二进制编码规则，int最大是2^32-1(2147483647)，最小是-2^32(-2147483648)。</p><p>除了int还有吗？</p><p>在C当中：</p><table><thead><tr><th>C声明</th><th></th><th>字节数</th><th></th></tr></thead><tbody><tr><td>有符号</td><td>无符号</td><td>32位</td><td>64位</td></tr><tr><td>[signed] char</td><td>unsigned char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>unsigned</td><td>4</td><td>4</td></tr><tr><td>long</td><td>unsigned long</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>8</td><td>8</td></tr><tr><td>char*</td><td></td><td>4</td><td>8</td></tr><tr><td>float</td><td></td><td>4</td><td>4</td></tr><tr><td>double</td><td></td><td>8</td><td>8</td></tr></tbody></table><p>我们只讨论整数类型，整数我们可以分为两种类型，一种是<strong>有符号</strong>的，这种可以表示负数、零和正数；另一种是<strong>无符号</strong>的，这种只能表示非负数。</p><p>在32位程序上，C语言整型数据类型的典型取值范围如下：</p><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>[signed] char</td><td>-128</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32768</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned</td><td>0</td><td>4294967295</td></tr><tr><td>long</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned long</td><td>0</td><td>4294967295</td></tr><tr><td>int32_t</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>uint32_t</td><td>0</td><td>4294967295</td></tr><tr><td>int64_t</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>uint64_t</td><td>0</td><td>18446744073709551615</td></tr></tbody></table><p>在64位程序上，C语言整型数据类型的典型取值范围如下：</p><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>[signed] char</td><td>-128</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32768</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned</td><td>0</td><td>4294967295</td></tr><tr><td>long</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>unsigned long</td><td>0</td><td>18446744073709551615</td></tr><tr><td>int32_t</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>uint32_t</td><td>0</td><td>4294967295</td></tr><tr><td>int64_t</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>uint64_t</td><td>0</td><td>18446744073709551615</td></tr></tbody></table><p>通过上面两张表我们可以注意到，有符号的整型的取值范围是不对称的——负数的范围比整数的范围大1。这个原因是计算机在用二进制表示负数的时候用到了<strong>补码编码</strong>，最前面一位是符号位，就不在这里啰嗦了……</p><p>C语言标准定义了每种数据类型必须能够表示的最小取值范围：</p><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>[signed] char</td><td>-127</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32767</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-32767</td><td>32767</td></tr><tr><td>unsigned</td><td>0</td><td>65535</td></tr><tr><td>long</td><td>-2147483647</td><td>2147483647</td></tr><tr><td>unsigned long</td><td>0</td><td>4294967295</td></tr><tr><td>int32_t</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>uint32_t</td><td>0</td><td>4294967295</td></tr><tr><td>int64_t</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>uint64_t</td><td>0</td><td>18446744073709551615</td></tr></tbody></table><p>C++中的整型类型和范围如下：</p><table><thead><tr><th>类型</th><th>位</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1 个字节</td><td>-128 到 127 或者 0 到 255</td></tr><tr><td>unsigned char</td><td>1 个字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 个字节</td><td>-128 到 127</td></tr><tr><td>int</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>unsigned int</td><td>4 个字节</td><td>0 到 4294967295</td></tr><tr><td>signed int</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>short int</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>unsigned short int</td><td>2 个字节</td><td>0 到 65,535</td></tr><tr><td>signed short int</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>long int</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>signed long int</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>unsigned long int</td><td>8 个字节</td><td>0 到 18,446,744,073,709,551,615</td></tr><tr><td>float</td><td>4 个字节</td><td>精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr><tr><td>double</td><td>8 个字节</td><td>双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td></tr><tr><td>long double</td><td>16 个字节</td><td>长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr><tr><td>wchar_t</td><td>2 或 4 个字节</td><td>1 个宽字符</td></tr></tbody></table><p>其实 wchar_t 是这样来的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> short <span class="keyword">int</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>所以 wchar_t 实际上的空间是和 short int 一样。</p><p><strong>注意：</strong>不同系统会有所差异，一字节为 8 位。</p><p><strong>注意：</strong>long int 与 int 都是 4 个字节，因为早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的C/C++ 标准兼容了早期的这一设定。</p><blockquote><p>C和C++都支持有符号（默认）和无符号数，Java只支持有符号数</p></blockquote><h3 id="二-INT-MAX和INT-MIN"><a href="#二-INT-MAX和INT-MIN" class="headerlink" title="二.INT_MAX和INT_MIN"></a>二.INT_MAX和INT_MIN</h3><p>我们已经知道了C/C++中一个int占32位，于是为了方便表示int类型的范围，于是在头文件limits.h中，用常量INT_MAX和INT_MIN分别表示最大、最小整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br><span class="line"><span class="comment">//這裏沒有簡單地將INT_MIN賦值成-2147483647，是因為-2147483648對於編譯器而言是個表達式，</span></span><br><span class="line"><span class="comment">//而2147483648對於32-bit整數是無法表示的，所以經過這個表達式的結果是未定義的。</span></span><br><span class="line"><span class="comment">//在GCC上直接寫-2147483648後，編譯器給出了警告，說結果是unsigned。</span></span><br></pre></td></tr></table></figure><p>在C/C++語言中，不能夠直接使用-2147483648來代替最小負數，因為這不是一個數字，而是一個表達式。表達式的意思是對整數21473648取負，但是2147483648已經溢出了int的上限，所以定義為（-INT_MAX -1）。</p><p>记住INT_MAX和INT_MIN的定义，在后面的运算中很重要。</p><p>我们用二进制来表示INT_MAX和INT_MIN：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX == <span class="number">0b01111111111111111111111111111111</span>;<span class="comment">// 31个1</span></span><br><span class="line">INT_MIN == <span class="number">0b10000000000000000000000000000000</span>;<span class="comment">// 31个0</span></span><br></pre></td></tr></table></figure><h3 id="三-运算"><a href="#三-运算" class="headerlink" title="三.运算"></a>三.运算</h3><p>当我们弄清楚了INT_MAX和INT_MIN的本质之后再来谈谈他们的运算。</p><p>整数的运算离不开二进制编码的原码、补码和反码这些规则，所以当在刷算法题涉及到INT_MAX和INT_MIN时我们应该对边界情况考虑周到，考虑溢出的情况，当发生溢出的时候，就不会遵循数学规则了。</p><p><strong>INT_MAX + 1 = INT_MIN</strong></p><p><strong>INT_MIN - 1 = INT_MAX</strong></p><p><strong>abs(INT_MIN) = INT_MIN</strong></p><p>前两条对比二进制做加减法就能一目了然，那么第三条abs()这个怎么解释呢？别忘了<code>#define INT_MIN (-INT_MAX - 1)</code> 所以<code>abs(INT_MIN)</code>也就是<code>abs(-INT_MAX - 1)</code>，结果就是<code>INT_MAX+1</code>，还是<code>INT_MIN</code>。</p><p>同理，<code>-INT_MIN == INT_MIN</code>。</p><p>那么我们可以达到另外一种下溢：</p><p><strong>INT_MIN + INT_MIN = 0</strong></p><p>将上式中的<code>INT_MIN</code>用<code>INT_MAX+1</code>进行替换，我们就得到了另一种上溢：</p><p><strong>INT_MAX + INT_MAX = -2</strong></p><p>总结一下：</p><ol><li>最轻微的上溢是INT_MAX + 1 :结果是 INT_MIN; </li><li>最严重的上溢是INT_MAX + INT_MAX :结果是-2; </li><li>最轻微的下溢是INT_MIN - 1:结果是是INT_MAX; </li><li>最严重的下溢是INT_MIN + INT_MIN:结果是0 。</li></ol><h3 id="四-代码"><a href="#四-代码" class="headerlink" title="四.代码"></a>四.代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0b10000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0b01111111111111111111111111111111</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (i == INT_MIN) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (j == INT_MAX) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-INT_MIN = "</span> &lt;&lt; -INT_MIN &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN = "</span> &lt;&lt; INT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN/10 = "</span> &lt;&lt; INT_MIN/<span class="number">10</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN%10 = "</span> &lt;&lt; INT_MIN%<span class="number">10</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-INT_MIN%10 = "</span> &lt;&lt; -INT_MIN%<span class="number">10</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-(INT_MIN%10) = "</span> &lt;&lt; -(INT_MIN%<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MAX + INT_MAX = "</span> &lt;&lt; INT_MAX + INT_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN + INT_MIN = "</span> &lt;&lt; INT_MIN + INT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/Users/saladdays/Projects/Learn_CPP/INT/int.cpp:16:44: warning: overflow in expression; result is -2 with type 'int' [-Winteger-overflow]</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MAX + INT_MAX = "</span> &lt;&lt; INT_MAX + INT_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                                                  ^</span><br><span class="line">/Users/saladdays/Projects/Learn_CPP/INT/int.cpp:17:44: warning: overflow in expression; result is 0 with type 'int' [-Winteger-overflow]</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN + INT_MIN = "</span> &lt;&lt; INT_MIN + INT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                                                  ^</span><br><span class="line"><span class="number">2</span> warnings generated.</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">-INT_MIN = <span class="number">-2147483648</span></span><br><span class="line">INT_MIN = <span class="number">-2147483648</span></span><br><span class="line">INT_MIN/<span class="number">10</span> = <span class="number">-214748364</span></span><br><span class="line">INT_MIN%<span class="number">10</span> = <span class="number">-8</span></span><br><span class="line">-INT_MIN%<span class="number">10</span> = <span class="number">-8</span></span><br><span class="line">-(INT_MIN%<span class="number">10</span>) = <span class="number">8</span></span><br><span class="line">INT_MAX + INT_MAX = <span class="number">-2</span></span><br><span class="line">INT_MIN + INT_MIN = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="五-参考文章"><a href="#五-参考文章" class="headerlink" title="五.参考文章"></a>五.参考文章</h3><ul><li>深入理解计算机系统</li><li><a href="https://www.runoob.com/cplusplus/cpp-data-types.html" target="_blank" rel="noopener">C++数据类型</a></li><li><a href="https://www.itread01.com/content/1534661783.html" target="_blank" rel="noopener">INT_MIN和INT_MAX註意事項 //C++</a></li><li><a href="https://stackoverflow.com/questions/54292185/why-int-min-is-not-2147483648-for-uint64-t-type" target="_blank" rel="noopener">Why -INT_MIN is NOT 2147483648 for uint64_t type</a></li><li><a href="https://blog.csdn.net/weixin_42372777/article/details/83092086" target="_blank" rel="noopener">C/C++中int型上下限INT_MAX INT_MIN以及溢出</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>initializer_list</title>
      <link href="/2020/06/23/initializer-list/"/>
      <url>/2020/06/23/initializer-list/</url>
      
        <content type="html"><![CDATA[<p>我记得有次面试的时候面试官提过一句initializer_list，当时只是知道这个东西是C++11中的新类型，但并没有去深入了解它，今天突然想到了就看了一些文章，随便记录一下。</p><p>C++11提供的新类型，定义在<initializer_list>头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">initializer_list</span>;</span></span><br></pre></td></tr></table></figure><p>回忆一下我们初始化一个vector有哪些方法？</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: s) </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">4</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(a, a+<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v5</span><span class="params">(v4.begin(), v4.end())</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v6 = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v7&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">show(v1);</span><br><span class="line">show(v2);</span><br><span class="line">show(v3);</span><br><span class="line">show(v4);</span><br><span class="line">show(v5);</span><br><span class="line">show(v6);</span><br><span class="line">show(v7);</span><br><span class="line"><span class="comment">//show(&#123;1,0,3,7&#125;);// invalid: note: candidate template ignored: couldn't infer template argument 'T'</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面罗列了6种初始化vector的方法，但我在电脑上执行的时候，v6报错了：</p><img src="/2020/06/23/initializer-list/1.png" class="" title="image"><p>我们忽略auto语法的warning，专注一下最后一个error：<strong>error:</strong> <strong>non-aggregate type ‘vector&lt; int &gt;’ cannot be initialized with an initializer list</strong>。大概意思就是我们不能用一个initializer list去初始化一个vector&lt; int &gt;，为啥不行呢？</p><p>我们从C++官网可以找到答案：</p><blockquote><p> A <code>std::initializer_list</code> object is automatically constructed when:</p><ul><li>a <em>braced-init-list</em> is used to <a href="https://en.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="noopener">list-initialize</a> an object, where the corresponding constructor accepts an <code>std::initializer_list</code> parameter</li><li>a <em>braced-init-list</em> is used as the right operand of <a href="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_direct_assignment" target="_blank" rel="noopener">assignment</a> or as a <a href="https://en.cppreference.com/w/cpp/language/overload_resolution#Implicit_conversion_sequence_in_list-initialization" target="_blank" rel="noopener">function call argument</a>, and the corresponding assignment operator/function accepts an <code>std::initializer_list</code> parameter</li><li>a <em>braced-init-list</em> is bound to <a href="https://en.cppreference.com/w/cpp/language/auto" target="_blank" rel="noopener"><code>auto</code></a>, including in a <a href="https://en.cppreference.com/w/cpp/language/range-for" target="_blank" rel="noopener">ranged for loop</a></li></ul></blockquote><p>上面这段话的意思大概就是，在这些情况下会自动构造一个<code>std::initializer_list</code>对象：</p><ul><li>对一个对象初始化是使用大括号<code>std::initializer_list</code>初始化的时候，<code>std::initializer_list</code>对象会被自动构造，同时也适用于赋值和函数调用的参数。</li><li>上面的前提是你要初始化的对象、对应的赋值运算符和函数<strong>必须可以接受(accepts)一个<code>std::initializer_list</code>参数</strong>。</li><li>涉及到for循环的时候，或者auto的时候，使用大括号也会也会被自动构造成一个<code>std::initializer_list</code>。</li></ul><p>也就是说initializer_list对象只能用大括号{}初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">10</span>,<span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// the type of il is an initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>在C++11之前的vector这些STL并没有参数为<code>std::initializer_list</code>的构造函数，所以当我们将一个<code>std::initializer_list</code>赋值拷贝或者拷贝构造给一个对象的前提是，这个对象有提供参数为<code>std::initializer_list</code>的赋值拷贝运算符或拷贝构造函数。上面的程序在C++11的环境下执行就没有问题了。</p><p>另外，拷贝一个initializer_list对象并不会拷贝里面的元素。其实只是引用而已。而且里面的元素全部都是const的，所以我们不能去修改一个<code>std::initializer_list</code>里的数值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=il;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; ill=il;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;v);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, il.begin());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, ill.begin());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;il);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;ill);</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x7ffee328a828</span></span><br><span class="line"><span class="comment">//0x10c978e30</span></span><br><span class="line"><span class="comment">//0x10c978e30</span></span><br><span class="line"><span class="comment">//0x7ffee328a840</span></span><br><span class="line"><span class="comment">//0x7ffee328a808</span></span><br></pre></td></tr></table></figure><p>通过查看对象和对象里元素的地址，我们可以证实了，<code>std::initializer_list</code>里的元素作为const是存在常量区里，随着整个程序的结束才被系统释放，而我们定义出来的<code>std::initializer_list ill</code> 和<code>std::vector v</code>是作为局部变量存在栈区的，函数生命周期结束局部变量也就随之释放了内存。</p><p>还有一点关于对<code>std::initializer_list</code>里的元素访问，我们并不能像访问数组那样用数字下标去访问，因为<code>std::initializer_list</code>并没有提供这样的操作符，我们只能像使用vector一样使用迭代器去访问<code>std::initializer_list</code>里的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> beg=il.begin();beg!=il.end();++beg)</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;*beg&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后让我们再品味一下官方提供的代码吧，你细品你细品~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.size() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.end(), l.begin(), l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.size()&#125;;  <span class="comment">// copy list-initialization in return statement</span></span><br><span class="line">                                   <span class="comment">// this is NOT a use of std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: s)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// copy list-initialization</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// list-initialization in function call</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// the rule for auto makes this ranged-for work</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// special rule for auto</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // compiler error! "&#123;1, 2, 3&#125;" is not an expression,</span></span><br><span class="line">                             <span class="comment">// it has no type, and so T cannot be deduced</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// also OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">constructed with a <span class="number">5</span>-element <span class="built_in">list</span></span><br><span class="line">The <span class="built_in">vector</span> size is now <span class="number">8</span> ints:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> </span><br><span class="line">Range-<span class="keyword">for</span> over brace-init-<span class="built_in">list</span>: </span><br><span class="line"><span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span> </span><br><span class="line"><span class="function">The <span class="built_in">list</span> bound to <span class="keyword">auto</span> has <span class="title">size</span><span class="params">()</span> </span>= <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://en.cppreference.com/w/cpp/utility/initializer_list" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/initializer_list</a></li><li><a href="https://www.cnblogs.com/lysuns/p/4278589.html" target="_blank" rel="noopener">C++11中新特性之：initializer_list详解</a></li><li><a href="https://blog.csdn.net/wangkai_123456/article/details/76252073" target="_blank" rel="noopener">C++ 11 initializer_list关键字</a></li><li><a href="https://blog.csdn.net/fengbingchun/article/details/77938005" target="_blank" rel="noopener">C++11中std::initializer_list的使用</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网面试题目梳理</title>
      <link href="/2020/06/23/computer-networking/"/>
      <url>/2020/06/23/computer-networking/</url>
      
        <content type="html"><![CDATA[<p>计算机网络。</p><p>重要性不言而喻。</p><p>考研的那几本书都快翻烂了，书上的东西虽不敢说理解了100%，理解了个60%还是有的。</p><p>背是不可能背下来的，这辈子都不可能死记硬背的，最多面试前突击记一下……那就来看看哪些需要记忆的吧~</p><a id="more"></a><h3 id="一-计算机网络体系结构"><a href="#一-计算机网络体系结构" class="headerlink" title="一.计算机网络体系结构"></a>一.计算机网络体系结构</h3><img src="/2020/06/23/computer-networking/1.png" class="" title="image"><p>我们主要讨论的还是OSI七层模型：</p><img src="/2020/06/23/computer-networking/2.png" class="" title="image"><h5 id="Q1-OSI七层模型的作用"><a href="#Q1-OSI七层模型的作用" class="headerlink" title="Q1.OSI七层模型的作用"></a>Q1.OSI七层模型的作用</h5><ol><li>应用层(数据):确定进程之间通信的性质以满足用户需要以及提供网络与用户应用；</li><li>表示层(数据):主要解决拥护信息的语法表示问题，如加密解密；</li><li>会话层(数据):提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的；</li><li>传输层(段):实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等；</li><li>网络层(包):提供逻辑地址(IP)、选路，数据从源端到目的端的传输；</li><li>数据链路层(帧):将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正；</li><li>物理层(比特流):设备之间比特流的传输，物理接口，电气特性等。</li></ol><h5 id="Q2-各层使用的是哪个数据交换设备-交换机、路由器、网关"><a href="#Q2-各层使用的是哪个数据交换设备-交换机、路由器、网关" class="headerlink" title="Q2.各层使用的是哪个数据交换设备(交换机、路由器、网关)"></a>Q2.各层使用的是哪个数据交换设备(交换机、路由器、网关)</h5><ol><li>网关:应用层、传输层(网关在传输层上以实现网络互连，是最复杂的网络互连设 备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是 互连层。网关既可以用于广域网互连，也可以用于局域网互连)；</li><li>路由器:网络层(路由选择、存储转发)；</li><li>交换机:数据链路层、网络层(识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中)；</li><li>网桥:数据链路层(将两个 LAN 连起来，根据 MAC 地址来转发帧)；</li><li>集线器(Hub):物理层(纯硬件设备，主要用来连接计算机等网络终端)；</li><li>中继器:物理层(在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离)。</li></ol><p>面试最喜欢问的主要就四个相关协议，TCP、UDP、IP、HTTP，简单记录一些相关问题吧。</p><h3 id="二-IP"><a href="#二-IP" class="headerlink" title="二.IP"></a>二.IP</h3><p>IP协议在网络层，同在网络层的还有DNS、ARP、ICMP等IP相关协议。</p><h5 id="Q3-什么是IP协议"><a href="#Q3-什么是IP协议" class="headerlink" title="Q3.什么是IP协议"></a>Q3.什么是IP协议</h5><p><strong>IP即网际协议，处在OSI七层模型中的网络层，网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点(end-to-end) 通信”。</strong>网络层的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进 行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同 的数据链路上也能实现两端节点之间的数据包传输。</p><p>IP大致分为三大作用模块，它们是<strong>IP寻址</strong>、<strong>路由</strong>(最终节点为止的转发)以及<strong>IP分包与组包</strong>。</p><p>IP数据报的格式：</p><img src="/2020/06/23/computer-networking/3.png" class="" title="image"><ul><li><p>版本 : 有 4(IPv4)和 6(IPv6)两个值;</p></li><li><p>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长 度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。</p></li><li><p>总长度 : 包括首部长度和数据部分长度。</p></li><li><p>生存时间 :TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li><li><p>协议 :指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p></li><li><p>首部检验和 :因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算 的工作量。</p></li><li><p>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ul><p>数据报分片的举例</p><img src="/2020/06/23/computer-networking/4.png" class="" title="image"><h5 id="Q4-IPv4和IPv6的区别"><a href="#Q4-IPv4和IPv6的区别" class="headerlink" title="Q4.IPv4和IPv6的区别"></a>Q4.IPv4和IPv6的区别</h5><ul><li><p>地址空间不同，IPv4中规定IP地址长度为32，而IPv6中IP地址的长度为128。</p></li><li><p>路由表大小不同，IPv6的路由表相比IPv4的更小。</p></li><li><p>IPv6的组播支持以及对流的支持要强于IPv4。</p></li><li><p>安全性不同，IPv6的安全性更高，在使用IPv6的网络时，用户可对网络层的数据进行加密。</p></li><li><p>协议扩充不同，IPv6允许协议进行扩充而IPv4不允许。</p></li></ul><h3 id="三-TCP-UDP"><a href="#三-TCP-UDP" class="headerlink" title="三.TCP/UDP"></a>三.TCP/UDP</h3><p>TCP/IP中有两个具有代表性的传输层协议，它们分别是TCP和UDP。TCP提供可靠的通信传输，而UDP 则常被用于让广播和细节控制交给应用的通信传输。总之，根据通信的具体特征，选择合适的传输层协议是非常重要的。</p><h5 id="Q5-TCP和UDP的特点和区别"><a href="#Q5-TCP和UDP的特点和区别" class="headerlink" title="Q5.TCP和UDP的特点和区别"></a>Q5.TCP和UDP的特点和区别</h5><p><strong>用户数据报协议 UDP（User Datagram Protocol）</strong></p><p>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p><p><strong>传输控制协议 TCP（Transmission Control Protocol）</strong></p><p>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p><ol><li>TCP 面向连接，UDP 面向无连接(无需建立连接)</li><li>TCP 面向字节流，UDP 面向报文</li><li>TCP 提供可靠传输服务(数据顺序、正确性)，UDP 传输不可靠</li><li>TCP 协议传输速度慢，UDP 协议传输速度快</li><li>TCP 协议对系统资源要求多(头部开销大)，UDP 协议要求少</li></ol><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="Q6-UDP校验和怎么计算"><a href="#Q6-UDP校验和怎么计算" class="headerlink" title="Q6.UDP校验和怎么计算"></a>Q6.UDP校验和怎么计算</h5><p>UDP 的校验和要计算首部和数据部分。首部还包括伪首部。</p><img src="/2020/06/23/computer-networking/5.png" class="" title="image"><p>多了 12 个字节的伪首部。<br> 注意点:UDP 长度计算两次。<br> 如果检验和有错，则 UDP 数据报被悄悄丢弃，不产生任何差错报文。</p><h5 id="Q7-UDP为什么要加伪首部"><a href="#Q7-UDP为什么要加伪首部" class="headerlink" title="Q7.UDP为什么要加伪首部"></a>Q7.UDP为什么要加伪首部</h5><p>目的是让 UDP 两次检查数据是否已经正确到达目的地。<br> IP 接受正确的目的地址，传送到正确的上层程序。 所有伪首部包括:源 IP 地址，目的 IP 地址，0，协议号，UDP 长度。</p><p>还有一个原因：<strong>TCP/IP或UDP/IP通信中通常采用5个信息来识别(这个信息可以在Unix或Windows系统中通过 netstat -n 命令显示。)一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端 口号”。只要其中某一项不同，则被认为是其他通信。</strong></p><p>TCP/IP中识别一个进行通信的应用需要5大要素，它们分别为“源IP地址”、“目标IP地址”、“源端 口”、“目标端口”、“协议号”。然而，在UDP的首部中只包含它们当中的两项(源端口和目标端口)，余下的3项都包含在IP首部里。</p><p>假定其他3项的信息被破坏会产生什么样的后果呢?很显然，这极有可能会导致应该收包的应用收不到包，不该收到包的应用却收到了包。</p><p>为了避免这类问题，有必要验证一个通信中必要的5项识别码是否正确。为此，在校验和的计算中就引入了伪首部的概念。</p><p>此外，IPv6中的IP首部没有校验和字段。TCP或UDP通过伪首部，得以对5项数字进行校验，从而实 现即使在IP首部并不可靠的情况下仍然能够提供可靠的通信传输。</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="Q8-TCP通过哪些方式来保证传输的可靠性"><a href="#Q8-TCP通过哪些方式来保证传输的可靠性" class="headerlink" title="Q8.TCP通过哪些方式来保证传输的可靠性"></a>Q8.TCP通过哪些方式来保证传输的可靠性</h5><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>确认机制，发送报文后，等待确认。</li><li>重发机制，没有收到确认，将重发数据段。</li><li>保持它首部和数据的校验和。确认数据的准确性。</li><li>排序，丢弃重复的，流量控制。</li></ol><h5 id="Q9-TCP的流量控制机制"><a href="#Q9-TCP的流量控制机制" class="headerlink" title="Q9.TCP的流量控制机制"></a>Q9.TCP的流量控制机制</h5><p>主要是下面的四种机制:</p><p><strong>慢启动(慢开始)</strong>:</p><ol><li><p>慢开始不是指 cwnd 的增长速度慢(指数增长)，而是指 TCP 开始发送设置 cwnd=1。 </p></li><li><p>思路:不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。</p></li><li><p>为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量) 当 cnwd&lt;ssthresh，使用慢开始算法<br> 当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法<br> 当 cnwd&gt;ssthresh，使用拥塞避免算法</p></li></ol><p><strong>拥塞避免</strong>:</p><ol><li><p>拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p></li><li><p>思路:让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控制窗口加一。</p></li></ol><p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理)，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口 设置为 1，执行慢开始算法。 如图所示:</p><img src="/2020/06/23/computer-networking/6.png" class="" title="image"><p><strong>快速重传</strong>:</p><ol><li><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p></li><li><p>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。</p></li></ol><p><strong>快速恢复</strong>:</p><ol><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。 但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小， 然后执行拥塞避免算法。</li></ol><h5 id="Q10-TCP的三次握手和四次挥手"><a href="#Q10-TCP的三次握手和四次挥手" class="headerlink" title="Q10.TCP的三次握手和四次挥手"></a>Q10.TCP的三次握手和四次挥手</h5><p><strong>TCP三次握手</strong></p><img src="/2020/06/23/computer-networking/7.png" class="" title="image"><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN(监听)状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时 也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong> </p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待 一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握 手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确 认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>TCP四次挥手</strong></p><img src="/2020/06/23/computer-networking/8.png" class="" title="image"><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都 为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL(最大报文存活时间)后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong><br>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 </p><p>TIME_WAIT</p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由:</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文， A 等待一段时间就是为了处理这种情况的发生。 </li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h5 id="Q11-服务器端突然出现大量的CLOSE-WAIT状态是什么原因"><a href="#Q11-服务器端突然出现大量的CLOSE-WAIT状态是什么原因" class="headerlink" title="Q11.服务器端突然出现大量的CLOSE_WAIT状态是什么原因"></a>Q11.服务器端突然出现大量的CLOSE_WAIT状态是什么原因</h5><p>（这个题是我在面试百度时被问过，当时直接懵逼……太菜了  : ( </p><p>服务器端出现大量的CLOSE_WAIT状态，说明服务器端没有发送FIN报文，也就是说服务器端的某些进程并没有结束导致服务器端没能向客户端发送FIN报文，通过网上查找资料总结了以下可能的原因：</p><ul><li>服务器端连接了SQL等数据库，执行完之后没有关闭连接；</li><li>服务器端的代码，socket连接，没有写close函数关闭连接，或者出现死循环，服务器端的代码永远执行不到 close。</li><li>客户机响应太慢或者 timeout 设置过小，当服务器端发生阻塞的时候，客户端发出的请求一直在等待，当超时之后就会抛出异常，关闭连接，关闭连接导致客户端发送了FIN报文，但是由于服务器端处理请求的线程还处于阻塞的状态，所以当前的连接状态处于CLOSE_WAIT。</li></ul><h3 id="四-HTTP"><a href="#四-HTTP" class="headerlink" title="四.HTTP"></a>四.HTTP</h3><h5 id="Q12-GET和POST的区别"><a href="#Q12-GET和POST的区别" class="headerlink" title="Q12.GET和POST的区别"></a>Q12.GET和POST的区别</h5><p><strong>作用</strong></p><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><p><strong>参数</strong></p><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在 实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具 (Fiddler)查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code> ，而<code>空格</code>会转换为 <code>%20</code> 。POST 参数支持标准字符集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test&#x2F;demo_form.asp?name1&#x3D;value1&amp;name2&#x3D;value2 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test&#x2F;demo_form.asp HTTP&#x2F;1.1 </span><br><span class="line">Host: w3schools.com </span><br><span class="line">name1&#x3D;value1&amp;name2&#x3D;value2</span><br></pre></td></tr></table></figure><p><strong>安全</strong></p><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数 据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有:HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><table><thead><tr><th>操作方式</th><th>数据位置</th><th>明文密文</th><th>数据安全</th><th>长度限时</th><th>应用场景</th></tr></thead><tbody><tr><td>GET</td><td>HTTP报头</td><td>明文</td><td>不安全</td><td>长度较小</td><td>查询数据</td></tr><tr><td>POST</td><td>HTTP正文</td><td>可明可密</td><td>安全</td><td>支持较大数据传输</td><td>修改数据</td></tr></tbody></table><h5 id="Q13-用浏览器打开一个网页的过程"><a href="#Q13-用浏览器打开一个网页的过程" class="headerlink" title="Q13.用浏览器打开一个网页的过程"></a>Q13.用浏览器打开一个网页的过程</h5><p>(假设主机一开始没有分配IP地址)整个过程可以概括为以下几步：</p><ol><li>DHCP协议自动分配主机IP地址；</li><li>DNS域名解析URL网页的IP地址；</li><li>应用层客户端(浏览器)发送HTTP请求；</li><li>传输层TCP三次握手建立连接，传输报文；</li><li>网络层IP协议把TCP分割好的各种数据包封装到IP包里面传送给接收方，ARP协议将IP地址解析为MAC地址；</li><li>得到下一个(不一定是目的)MAC地址后，数据链路层将IP包封装到数据帧结构中，再通过物理层的比特流送出去（至此客户端发送请求的阶段结束）；</li><li>服务器接收数据，在数据链路层接收到数据报，层层向上直到应用层。这过程中包括在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文；</li><li>服务器响应请求并返回相应文件；</li><li>浏览器开始处理数据信息并渲染页面；</li><li>将渲染好的页面图像显示出来，并开始响应用户的操作。</li></ol><h3 id="五-参考文章"><a href="#五-参考文章" class="headerlink" title="五.参考文章"></a>五.参考文章</h3><ul><li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></li><li>计算机网络·自顶向下方法 第六版</li><li>图解TCP/IP 第五版</li><li><a href="https://www.cnblogs.com/qcrao-2018/p/10182185.html" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗？</a></li><li><a href="https://blog.csdn.net/yu616568/article/details/44677985" target="_blank" rel="noopener">一次服务端大量CLOSE_WAIT问题的解决</a></li><li><a href="https://blog.csdn.net/qq_33528613/article/details/84987469" target="_blank" rel="noopener">出现过多的close_wait可能是什么原因？</a></li><li><a href="https://www.jianshu.com/p/d616d887953a" target="_blank" rel="noopener">浏览器工作原理：从 URL 输入到页面展现到底发生了什么？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C/C++中的char和string</title>
      <link href="/2020/06/19/char-string/"/>
      <url>/2020/06/19/char-string/</url>
      
        <content type="html"><![CDATA[<p>很想写一篇文章来谈一下C/C++中的char和string，顺带也可以说一下python中的string，因为我学习语言的顺序是先学了C再学python然后学C++，一开始对这两个数据类型并没有很敏感，前几天在用C写代码的时候，发现在使用char *和char ch[]的时候有些模糊，而且在给它们初始化或者赋值的时候也会出错。在传统的C里面，我们可以初始化一个定长的char数组，但不能直接给一个定长的char数组赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">20</span>] = <span class="string">"Hello,world!"</span>;<span class="comment">// valid</span></span><br><span class="line"><span class="keyword">char</span> sh[<span class="number">20</span>]；</span><br><span class="line">sh = <span class="string">"Hello,world!"</span>;<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure><p>编译器会提示你：</p><a id="more"></a><p><code>array type &#39;char [20]&#39; is not assignable</code></p><p>这个时候我们需要用到<strong>strcpy()</strong>函数，它存在于string.h头文件当中，使用前你需要include这个头文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sh[<span class="number">20</span>]；</span><br><span class="line">sh = <span class="string">"Hello,world!"</span>;<span class="comment">// invalid</span></span><br><span class="line"><span class="built_in">strcpy</span>(sh, <span class="string">"Hello,world!"</span>);<span class="comment">// valid</span></span><br></pre></td></tr></table></figure><h3 id="一-char类型详解"><a href="#一-char类型详解" class="headerlink" title="一.char类型详解"></a>一.char类型详解</h3><h4 id="1-char与字符的关系"><a href="#1-char与字符的关系" class="headerlink" title="1.char与字符的关系"></a>1.char与字符的关系</h4><p>在C/C++中，char是定义一个字符，存储一个字符，占一个字节(byte)，在内存中占8位(bit)。</p><p>我们需要知道这个知识点，在计算机中，通常8位代表一个字节，即1byte = 8bits。</p><p>所以一个signed char的范围为-128-127，unsigned char的范围为0-255。</p><p>计算机通常用二进制存储信息，所以我们在计算机上看到的汉字、英文等字符是二进制数转换的结果。那么有时候我们在打开一个网页或文件的时候，显示一堆乱码是什么情况呢？这就需要探讨一下不同的字符集。</p><h4 id="2-什么是字符集"><a href="#2-什么是字符集" class="headerlink" title="2.什么是字符集"></a>2.什么是字符集</h4><p><strong>字符集</strong>(charset)是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。常见的字符集比如ASCII码，它是由美国ANSI制定的，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">128</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[%3d -&gt; %c] "</span>, i, i);</span><br><span class="line">  <span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ 32 -&gt;  ] [ 33 -&gt; !] [ 34 -&gt; <span class="string">"] [ 35 -&gt; #] [ 36 -&gt; $] [ 37 -&gt; %] [ 38 -&gt; &amp;] [ 39 -&gt; '] [ 40 -&gt; (] </span></span><br><span class="line"><span class="string">[ 41 -&gt; )] [ 42 -&gt; *] [ 43 -&gt; +] [ 44 -&gt; ,] [ 45 -&gt; -] [ 46 -&gt; .] [ 47 -&gt; /] [ 48 -&gt; 0] [ 49 -&gt; 1] [ 50 -&gt; 2] </span></span><br><span class="line"><span class="string">[ 51 -&gt; 3] [ 52 -&gt; 4] [ 53 -&gt; 5] [ 54 -&gt; 6] [ 55 -&gt; 7] [ 56 -&gt; 8] [ 57 -&gt; 9] [ 58 -&gt; :] [ 59 -&gt; ;] [ 60 -&gt; &lt;] </span></span><br><span class="line"><span class="string">[ 61 -&gt; =] [ 62 -&gt; &gt;] [ 63 -&gt; ?] [ 64 -&gt; @] [ 65 -&gt; A] [ 66 -&gt; B] [ 67 -&gt; C] [ 68 -&gt; D] [ 69 -&gt; E] [ 70 -&gt; F] </span></span><br><span class="line"><span class="string">[ 71 -&gt; G] [ 72 -&gt; H] [ 73 -&gt; I] [ 74 -&gt; J] [ 75 -&gt; K] [ 76 -&gt; L] [ 77 -&gt; M] [ 78 -&gt; N] [ 79 -&gt; O] [ 80 -&gt; P] </span></span><br><span class="line"><span class="string">[ 81 -&gt; Q] [ 82 -&gt; R] [ 83 -&gt; S] [ 84 -&gt; T] [ 85 -&gt; U] [ 86 -&gt; V] [ 87 -&gt; W] [ 88 -&gt; X] [ 89 -&gt; Y] [ 90 -&gt; Z] </span></span><br><span class="line"><span class="string">[ 91 -&gt; [] [ 92 -&gt; \] [ 93 -&gt; ]] [ 94 -&gt; ^] [ 95 -&gt; _] [ 96 -&gt; `] [ 97 -&gt; a] [ 98 -&gt; b] [ 99 -&gt; c] [100 -&gt; d] </span></span><br><span class="line"><span class="string">[101 -&gt; e] [102 -&gt; f] [103 -&gt; g] [104 -&gt; h] [105 -&gt; i] [106 -&gt; j] [107 -&gt; k] [108 -&gt; l] [109 -&gt; m] [110 -&gt; n] </span></span><br><span class="line"><span class="string">[111 -&gt; o] [112 -&gt; p] [113 -&gt; q] [114 -&gt; r] [115 -&gt; s] [116 -&gt; t] [117 -&gt; u] [118 -&gt; v] [119 -&gt; w] [120 -&gt; x] </span></span><br><span class="line"><span class="string">[121 -&gt; y] [122 -&gt; z] [123 -&gt; &#123;] [124 -&gt; |] [125 -&gt; &#125;] [126 -&gt; ~] [127 -&gt; ]</span></span><br></pre></td></tr></table></figure><p>传统的128个ASCII码有33个是控制字符(0-31, 127)，是不可显示的，剩下的都是可显示字符。</p><p>除了ASCII码之外，还有GBxxxx(汉字编码字符集)，Unicode(<strong>统一码</strong>、<strong>万国码</strong>、<strong>单一码</strong>、<strong>标准万国码</strong>)。</p><h4 id="3-如何表示字符"><a href="#3-如何表示字符" class="headerlink" title="3.如何表示字符"></a>3.如何表示字符</h4><p>通俗的说，按照何种规则将字符存储在计算机中，如’a’用什么表示，称为”<strong>编码</strong>“；反之，将存储在计算机中的二进制数解析显示出来，称为”<strong>解码</strong>“，如同密码学中的加密和解密。</p><p>汉字的编码标准，GBK；Unicode的编码标准，UTF。</p><p>在解码过程中，如果使用了错误的解码规则，则导致’a’解析成’b’或者乱码。</p><h4 id="4-C-中的字符类型"><a href="#4-C-中的字符类型" class="headerlink" title="4.C++中的字符类型"></a>4.C++中的字符类型</h4><p>C++提供了几种字符类型，并非只有8bits的char。比如我们熟知的ASCII码，在这种字符集系统上C++的字节确实是8位，然而在国际编程中采用更大的字符集比如Unicode等时，8位组合无法表示所有字符，因此一个字节可能需要16位甚至更多，在这种系统上，C++中的一个字节可能就不是代表8bit了，这是C++对字节的定义，这里我们一定不能搞混淆了。</p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16位</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32位</td></tr></tbody></table><p>其他字符集用于扩展字符集，如wchar_t、char16_t、char32_t。wchar_t类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型char16_t和char32_t则为Unicode字符集服务。</p><h3 id="二-char数组和char指针的区别和联系"><a href="#二-char数组和char指针的区别和联系" class="headerlink" title="二.char数组和char指针的区别和联系"></a>二.char数组和char指针的区别和联系</h3><p>在C语言中，对字符串的操作主要有两种方式，一是字符数组(char[])，二是使用字符指针(char*)。</p><h4 id="1-char数组"><a href="#1-char数组" class="headerlink" title="1.char数组"></a>1.char数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'~'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c[] = <span class="string">"hello~"</span>;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] = <span class="string">"Hello~"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%lu\n"</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(c); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%lu\n"</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(ch); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, ch[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/06/19/char-string/1.png" class="" title="image"><p>这张图可以很明显看出来不同方式声明并初始化char数组的效果是不同的。</p><p>第一种 <code>char a[] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;~&#39;};</code> 声明了一个char数组，不知道分配多大空间，根据右边的字符数组初始化char数组来确定最终的分配空间，给了6个字符，分配了6个sizeof(char)；</p><p>第二种 <code>char c[] = &quot;hello~&quot;;</code> 也是声明了一个不知道分配多少空间的char数组，但使用字符串字面值(string literal)初始化char数组之后，实际分配的空间比我们看到的字符串面值的要多一个&lt;0x00&gt;，也表示为’\0’；</p><p>第三种 <code>char ch[10] = &quot;Hello~&quot;;</code>  声明了长度为10的char数组，<strong>编译器为该数组分配了10个单位的内存</strong>，然后初始化，多余没有用到的内存就用’\0’填充，如果初始化的字符串字面值长度比分配的内存长，则会报错。</p><p>但C语言不允许我们直接声明一个不知道会分配多少内存空间的char数组，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[];<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure><p>char[]经过初始化后就会变成有固定长度的char数组。</p><p>但这个时候我们如果想给char数组重新赋值，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>];</span><br><span class="line">ch = <span class="string">"World!"</span>;<span class="comment">// invalid</span></span><br><span class="line"><span class="comment">// error: array type 'char [6]' is not assignable</span></span><br><span class="line"><span class="built_in">strcpy</span>(ch, <span class="string">"World!"</span>);<span class="comment">// valid</span></span><br></pre></td></tr></table></figure><p>我们要怎么去理解上面这个操作呢？</p><p>我记得我在大一学C语言的时候，老师讲过说，<strong>数组名可以理解为指向这个数组的指针</strong>。那既然是指针为什么不能给这个指针重新赋值呢？</p><p>很简单，数组名是数组名，指针是指针，他们是不能划等号的，老师说的是让你理解成指针，并不是说数组名就是指针！！！</p><p>有个很简单的方法可以证明，你就看<code>sizeof(a)</code>。</p><p>指针是指向一个内存地址的对象，无论是void <em>，char <em>还是int * ，C语言中指向各种数据的指针大小是一致的，在64位的机器上，</em></em>占8个字节**，32位的机器上是4个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] = <span class="string">"hello~"</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* pa = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(p)==%lu\n"</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(ch)==%lu\n"</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(pa)==%lu\n"</span>, <span class="keyword">sizeof</span>(pa));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(a)==%lu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(p)==8</span></span><br><span class="line"><span class="comment">// sizeof(ch)==10</span></span><br><span class="line"><span class="comment">// sizeof(pa)==8</span></span><br><span class="line"><span class="comment">// sizeof(a)==16</span></span><br></pre></td></tr></table></figure><p>通过看sizeof()的大小，我们可以发现数组名并不是指针，那数组名到底是什么呢？它和指针又有什么关系呢？</p><p>那我们不如来看一下他们的“庐山真面目”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p = ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" p ==%p\n"</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ch ==%p\n"</span>, ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;p ==%p\n"</span>, &amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;ch==%p\n"</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" a ==%p\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pa ==%p\n"</span>, pa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;a ==%p\n"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pa==%p\n"</span>, &amp;pa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  p ==0x7ffeec66e8f4</span></span><br><span class="line"><span class="comment">// ch ==0x7ffeec66e8f4</span></span><br><span class="line"><span class="comment">// &amp;p ==0x7ffeec66e8a8</span></span><br><span class="line"><span class="comment">// &amp;ch==0x7ffeec66e8f4</span></span><br><span class="line"><span class="comment">//  a ==0x7ffeec66e8e0</span></span><br><span class="line"><span class="comment">// pa ==0x7ffeec66e8e0</span></span><br><span class="line"><span class="comment">// &amp;a ==0x7ffeec66e8e0</span></span><br><span class="line"><span class="comment">// &amp;pa==0x7ffeec66e8a0</span></span><br></pre></td></tr></table></figure><p>通过上面的打印结果我们可以看到，指针指向的地址和存放这个指针的地址是不一样的，而数组名指向的地址和数组名所在的地址是一样的……听着有点绕，其实已经很清楚了：</p><p>ch数组名代表的就是char数组第一个元素地址的值，但<strong>它不是指针</strong>，只是对应着（而不是指向）一块内存，是个常量(const)，常量是不可以修改的，所以我们是不能给这个常量去赋值。</p><p>简言之，<strong>数组名是一个地址，而非指针，虽然两者数值相同，但是不是同一个东西。</strong></p><p><strong>所以我们要记住，数组名只是代表数组第一个元素的地址的值，比如数组 <code>int a[10]</code>，<code>a</code>实际上就是 <code>&amp;a[0]</code>，它只是一个值，就像 <code>5</code> 这类东西一样，是不能作为左值的，不能给它赋值。</strong></p><p>我想把数组名的真相继续深究下去，就拿<code>char ch[10];</code>来说，ch不是「指向char的指针」类型，ch是「长度为10的char数组」类型；&amp;ch也不是「指向指针的指针」类型，而是「指向长度为10的char数组的指针」类型，虽然ch和&amp;ch的值是一样的，但他们是完全不同的类型，不可混淆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p1 = &amp;ch;<span class="comment">// invalid</span></span><br><span class="line"><span class="comment">// error: cannot initialize a variable of type 'char *' with an rvalue of type 'char (*)[10]'</span></span><br><span class="line"><span class="keyword">char</span>* p1 = &amp;ch[<span class="number">0</span>];<span class="comment">// valid</span></span><br><span class="line"><span class="keyword">char</span> (*p2)[<span class="number">10</span>] = &amp;ch;<span class="comment">// valid:p2是指向长度为10的char数组的指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, p2[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, (*p2)[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>虽然p2看起来像个二维数组，但我们还是要弄清楚他们的本质是不一样的，因为二维数组是数组的数组，而p2是数组的指针。</p><p>以上，除了<strong>sizeof(ch)</strong>和<strong>&amp;ch</strong>以外，其余的情况下，ch可以看成指向首地址的指针，可以看成char* 类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch[<span class="number">1</span>] = <span class="string">'E'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hEllo~</span></span><br></pre></td></tr></table></figure><h4 id="2-char指针"><a href="#2-char指针" class="headerlink" title="2.char指针"></a>2.char指针</h4><p>当我们使用char指针来定义一个字符串的时候，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p0 = <span class="string">"C++!!!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// warning: conversion from string literal to 'char *' is deprecated [-Wc++11-compat-deprecated-writable-strings]</span></span><br></pre></td></tr></table></figure><p>把这个warning转换成中文的意思是：“警告：不建议将字符串文字转换为’char *’[-Wc ++ 11-compat-deprecated-writable-strings]”。</p><p>虽说是个warning，说明执行是没有问题的，但后面提示说这个语法不推荐使用(deprecated)，这是为什么呢？</p><p>在继续讲之前我们需要说一下C/C++的内存分配，内存分配是面试时候面试官问的高频问题。当我们定义一个字符串数组char a[]，这是属于静态分配，建立的静态数组，它是在<strong>栈空间分配内存</strong>；而动态方式使用new或malloc，是在<strong>堆上分配内存</strong>。string literal(字符串字面值)是常量(const)，常量存储在<strong>常量区</strong>，常量的字符串一般存在常量区，程序结束后由系统释放。</p><p>我们再回过头来看上面的定义和初始化语句：<code>char* p0 = &quot;C++!!!&quot;;</code> p0在栈上，而字符串常量”C++!!!\0“在常量区。我们可以这么理解，我们在栈上定义了一个指针p0，这个时候并没有为其分配内存，同时在常量区分配了一块内存放字符串常量”C++!!!\0”，然后让p0指向常量区这块内存的首地址。听起来没有问题，但为什么会有warning？</p><p>主要问题还是在于等号右边的这个string literal，它是个const啊，<a href="https://raoxuntian.github.io/2020/06/03/learnCpp-const/">const是不能修改的</a> (可以回顾一下这篇文章)。我们不能用一个简单的pointer去指向一个const，得用pointer to const，这样指针所指向的对象才是常量，不可变的。</p><p>所以正确的写法应该是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p0 = <span class="string">"C++!!!"</span>;<span class="comment">// valid</span></span><br><span class="line">p0 = <span class="string">"JAVA~"</span>;<span class="comment">// valid: 这里并没有修改*p0的值，而是把p0重新指向了"JAVA~"</span></span><br><span class="line">*p0 = <span class="string">"Python..."</span>;<span class="comment">// invalid: read-only variable is not assignable</span></span><br><span class="line">p0[<span class="number">1</span>] = <span class="string">'a'</span>;<span class="comment">// invalid: read-only variable is not assignable</span></span><br></pre></td></tr></table></figure><p>这种情况下我们并不好去修改p0所指向的字符串的值，这个时候我们可以想起数组……</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[] = <span class="string">"Gooooo"</span>;</span><br><span class="line"><span class="comment">//char* p1 = &amp;ch;// invalid</span></span><br><span class="line"><span class="comment">//char* p1 = ch;// valid: 当数组名作为右值的时候，我们可以简单理解为数组的指针</span></span><br><span class="line"><span class="keyword">char</span>* p1 = &amp;ch[<span class="number">0</span>];<span class="comment">// valid</span></span><br><span class="line">p1[<span class="number">3</span>] = <span class="string">'O'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch);</span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"Golang"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %s\n"</span>, p1, ch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// GooOoo</span></span><br><span class="line"><span class="comment">// Golang Golang</span></span><br></pre></td></tr></table></figure><h3 id="三-string和char的区别"><a href="#三-string和char的区别" class="headerlink" title="三.string和char的区别"></a>三.string和char的区别</h3><p>刚刚我们谈了关于char的很多东西，那么string和char又有什么关系呢？</p><p>在C++ primer一书中有介绍说，char字符属于C++的基本内置类型，包括前面说的wchar_t、char16_t和char32_t，都是primitive type（原始类型）。而在C++里。string是作为标准库类型，成为了一个类(class)，封装在string头文件里，当我们使用string类时，需要先include&lt; string &gt;，string表示的是可变长的字符序列。</p><p>关于string的语法我后面会再写一篇文章来记录，就不在此多说了，发表一下个人看法，有了string类之后，可以弥补之前char指针和char数组在字符串相关操作的不足，然而，熟悉C++语法的人也知道，string类也不只是封装了个char数组这么简单。虽说string中重载了各种操作符，还有各种find函数，给我们带来便利，但我们也不能忽视在复杂环境或多线程下频繁处理string类时的安全性，string不是万能的，不管是在C++还是Python当中，你使用时没有发生错误只是因为你只走到了这一步，并不意味它真的是完美(perfect)的。</p><p>顺带说一笔Python中的string吧，Python中有五个标准的数据类型：</p><ul><li><p>Numbers（数字）</p></li><li><p>String（字符串）</p></li><li><p>List（列表）</p></li><li><p>Tuple（元组）</p></li><li><p>Dictionary（字典）</p></li></ul><p>  没错。Python没有char类型，所以在Python中，<code>str = &quot;Hello~&quot;</code>和<code>str = &#39;Hello~&#39;</code>是没有区别的，str都是字符串，而在C/C++中，字符串或者char数组对应的需要用双引号来表示，而字符对应的需要用单引号来表示，如果你<code>char c = &quot;C&quot;</code>，那这就是错的。</p><h3 id="四-相关文章"><a href="#四-相关文章" class="headerlink" title="四.相关文章"></a>四.相关文章</h3><ul><li><a href="https://blog.csdn.net/Sylvernass/article/details/44604459" target="_blank" rel="noopener">C++中char类型详解</a></li><li><a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html" target="_blank" rel="noopener">字符集和字符编码（Charset &amp; Encoding）</a></li><li><a href="https://segmentfault.com/q/1010000003793687" target="_blank" rel="noopener">C 语言里为什么这样初始化字符串是错误的？</a></li><li><a href="https://blog.csdn.net/self_mind/article/details/49705227" target="_blank" rel="noopener">char数组与char指针的区别与联系</a></li><li><a href="https://www.zhihu.com/question/41805285" target="_blank" rel="noopener">知乎：c中，数组名跟指针有区别吗？</a></li><li><a href="https://blog.csdn.net/wangtie_123/article/details/9629111" target="_blank" rel="noopener">Conversion from string literal to ‘char *’ is deprecated 问题原因</a></li><li><a href="https://blog.csdn.net/u011555996/article/details/79496156" target="_blank" rel="noopener">C++ 数组在内存中的分配</a></li><li><a href="https://blog.csdn.net/yejinxiong001/article/details/78436310" target="_blank" rel="noopener">c/c++中string与char的区别</a></li></ul><h2 id="五-文章中的源码"><a href="#五-文章中的源码" class="headerlink" title="五.文章中的源码"></a>五.文章中的源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">// ASCII码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">128</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%3d -&gt; %c] "</span>, i, i);</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> a[] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'~'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c[] = <span class="string">"hello~"</span>;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] = <span class="string">"Hello~"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%lu\n"</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(c); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%lu\n"</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(ch); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, ch[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">"world"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ch, <span class="string">"world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%s %s\n"</span>, a, ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p %p %p\n"</span>, a, c, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] = <span class="string">"hello~"</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* pa = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(p)==%lu\n"</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(ch)==%lu\n"</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(pa)==%lu\n"</span>, <span class="keyword">sizeof</span>(pa));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(a)==%lu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line">p = ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" p ==%p\n"</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ch ==%p\n"</span>, ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;p ==%p\n"</span>, &amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;ch==%p\n"</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" a ==%p\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pa ==%p\n"</span>, pa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;a ==%p\n"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pa==%p\n"</span>, &amp;pa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//char* p1 = &amp;ch;</span></span><br><span class="line"><span class="keyword">char</span>* p1 = &amp;ch[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">char</span> (*p2)[<span class="number">10</span>] = &amp;ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, p2[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, (*p2)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">ch[<span class="number">1</span>] = <span class="string">'E'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//char* p0 = "C++!!!";</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p0 = <span class="string">"C++!!!"</span>;</span><br><span class="line">p0 = <span class="string">"JAVA~"</span>;</span><br><span class="line"><span class="comment">//*p0 = "Python...";</span></span><br><span class="line"><span class="comment">//p0[1] = 'a';</span></span><br><span class="line"><span class="keyword">char</span> ch[] = <span class="string">"Gooooo"</span>;</span><br><span class="line"><span class="comment">//char* p1 = &amp;ch[0];</span></span><br><span class="line"><span class="keyword">char</span>* p1 = ch;</span><br><span class="line">p1[<span class="number">3</span>] = <span class="string">'O'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch);</span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"Golang"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %s\n"</span>, p1, ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> char </tag>
            
            <tag> string </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie Tree</title>
      <link href="/2020/06/18/trie-tree/"/>
      <url>/2020/06/18/trie-tree/</url>
      
        <content type="html"><![CDATA[<h3 id="一-什么是Trie树"><a href="#一-什么是Trie树" class="headerlink" title="一.什么是Trie树"></a>一.什么是Trie树</h3><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p><img src="/2020/06/18/trie-tree/1.png" class="" title="TrieTree"><a id="more"></a><p>上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质：</p><p>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。<br>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>每个节点的所有子节点包含的字符互不相同。<br>通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。</p><p>可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。</p><h3 id="二-Trie树的优缺点"><a href="#二-Trie树的优缺点" class="headerlink" title="二.Trie树的优缺点"></a>二.Trie树的优缺点</h3><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>插入和查询的效率很高，都为O(m)，其中 m 是待插入/查询的字符串的长度。</p><p>关于查询，会有人说 hash 表时间复杂度是O(1)不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。<br>Trie树中不同的关键字不会产生冲突。</p></li><li><p>Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。</p></li><li><p>Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。</p></li><li><p>Trie树可以对关键字按<strong>字典序</strong>排序。</p></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。</li><li>空间消耗比较大。</li></ol><h3 id="三-Trie树的实现"><a href="#三-Trie树的实现" class="headerlink" title="三.Trie树的实现"></a>三.Trie树的实现</h3><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    Trie *child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        isWord=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; ++i)</span><br><span class="line">            child[i]=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:<span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                t-&gt;child[c-<span class="string">'a'</span>]=<span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;isWord=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:<span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="四-Trie树的应用"><a href="#四-Trie树的应用" class="headerlink" title="四.Trie树的应用"></a>四.Trie树的应用</h3><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p><p>这是一道easy级别的题目，编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p>示例 1:</p><p><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</code><br><code>输出: &quot;fl&quot;</code></p><p>示例 2:</p><p><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</code><br><code>输出: &quot;&quot;</code><br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 a-z 。</p><p>常规方法，也就是暴力法，假设最短字符串长度为m，字符串数组长度为n，那么时间复杂度就是O(m*n)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; ; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> str: strs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;=str.<span class="built_in">size</span>() || str[i]!=strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> str.substr(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们引用Trie树这一数据结构来解决这道题目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    Trie *child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        isWord=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; ++i)</span><br><span class="line">            child[i]=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:<span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                t-&gt;child[c-<span class="string">'a'</span>]=<span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;isWord=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:<span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  判断当前这个节点是否是整个树的前缀，也就是孩子只有一个字母 */</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">isPrefixNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> c=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;child[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                c=(<span class="keyword">char</span>) (<span class="string">'a'</span>+i);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt&gt;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt==<span class="number">1</span>?c:<span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">searchMaxPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span> c = t-&gt;isPrefixNode();</span><br><span class="line">        <span class="keyword">while</span> (!t-&gt;isWord &amp;&amp; c!=<span class="string">'\0'</span>) &#123;</span><br><span class="line">            res+=c;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">            c=t-&gt;isPrefixNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        Trie *root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str:strs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str==<span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            root-&gt;insert(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;searchMaxPrefix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>算上构建Trie树的时间，可能还不如暴力法快，但在实际情况中，面向更海量的数据，如果将不用vector<string>来存储这些字符串，而是用一棵Trie树来存储这些字符串，那么无论是空间复杂度还是寻找最长前缀的时间复杂度，都将更优。</p><p>Trie树还有的一些应用：</p><h4 id="1、字符串检索"><a href="#1、字符串检索" class="headerlink" title="1、字符串检索"></a>1、字符串检索</h4><p>检索/查询功能是Trie树最原始的功能。思路就是从根节点开始一个一个字符进行比较：</p><ul><li>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</li><li>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isKey;   <span class="comment">// 标记该节点是否代表一个关键字</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、词频统计"><a href="#2、词频统计" class="headerlink" title="2、词频统计"></a>2、词频统计</h4><p>Trie树常被搜索引擎系统用于文本词频统计 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路：为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。</p><p>注意：第一、第二种应用也都可以用 hash table 来做。</p><h4 id="3、字符串排序"><a href="#3、字符串排序" class="headerlink" title="3、字符串排序"></a>3、字符串排序</h4><p>Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。</p><h4 id="4、前缀匹配"><a href="#4、前缀匹配" class="headerlink" title="4、前缀匹配"></a>4、前缀匹配</h4><p>例如：找出一个字符串集合中所有以ab开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以a-&gt;b-&gt;开头的路径上的关键字即可。</p><p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p><h4 id="5、作为其他数据结构和算法的辅助结构"><a href="#5、作为其他数据结构和算法的辅助结构" class="headerlink" title="5、作为其他数据结构和算法的辅助结构"></a>5、作为其他数据结构和算法的辅助结构</h4><p>如后缀树，AC自动机等。</p><h3 id="五-相关文章"><a href="#五-相关文章" class="headerlink" title="五.相关文章"></a>五.相关文章</h3><ul><li><a href="https://blog.csdn.net/lisonglisonglisong/article/details/45584721" target="_blank" rel="noopener">https://blog.csdn.net/lisonglisonglisong/article/details/45584721</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> data structure </tag>
            
            <tag> trie tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Car Information Management System (车辆信息管理系统) with C</title>
      <link href="/2020/06/17/c-carIMS/"/>
      <url>/2020/06/17/c-carIMS/</url>
      
        <content type="html"><![CDATA[<p>这几天在家接了个私活，帮一个本科生做C语言课设…难度虽然不大，但回想起我大一时C语言的期末考试，又想起前一阵子看到清华贵系大一C语言课设——雷课堂，看着不同学校不同的标准，感慨万千…</p><p>开发环境 Linux + gcc 9.0</p><p>无GUI界面</p><p>数据结构用的是多层次的十字链表，数据存储在文件当中。</p><img src="/2020/06/17/c-carIMS/1.png" class="" title="image"><a id="more"></a><p>主要的操作就是定义结构体，链表的增删查改，文件的读写，模糊查询用到KMP算法。</p><p>C定义结构体可以和C++风格一致，但也有属于C自己风格的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OrderInfo</span>    // 租车订单信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">20</span>];            <span class="comment">// 订单编号</span></span><br><span class="line">    <span class="keyword">char</span> clientName[<span class="number">20</span>];    <span class="comment">// 客户姓名</span></span><br><span class="line">    <span class="keyword">char</span> clientId[<span class="number">20</span>];      <span class="comment">// 客户身份证号码</span></span><br><span class="line">    <span class="keyword">char</span> clientPhone[<span class="number">20</span>];<span class="comment">// 客户电话号码</span></span><br><span class="line">    <span class="keyword">int</span> carNo;          <span class="comment">// 租用的车辆编号</span></span><br><span class="line">    <span class="keyword">char</span> startTime[<span class="number">18</span>];     <span class="comment">// 取车时间</span></span><br><span class="line">    <span class="keyword">float</span> deposit;          <span class="comment">// 押金</span></span><br><span class="line">    <span class="keyword">char</span> planEndTime[<span class="number">18</span>];   <span class="comment">// 预约还车时间</span></span><br><span class="line">    <span class="keyword">char</span> actualEndTime[<span class="number">18</span>]; <span class="comment">// 实际还车时间</span></span><br><span class="line">    <span class="keyword">float</span> planCost;         <span class="comment">// 应缴费用</span></span><br><span class="line">    <span class="keyword">float</span> actualCost;       <span class="comment">// 实缴费用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OrderInfo</span>* <span class="title">next</span>;</span> <span class="comment">// 下一个订单</span></span><br><span class="line">&#125; order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CarInfo</span>  // 车辆基本信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> carNo;          <span class="comment">// 车辆编号</span></span><br><span class="line">    <span class="keyword">char</span> carId[<span class="number">3</span>];         <span class="comment">// 车辆类型编码   '1'-'5'</span></span><br><span class="line">    <span class="keyword">char</span> license[<span class="number">10</span>];   <span class="comment">// 车牌号 </span></span><br><span class="line">    <span class="keyword">char</span> carName[<span class="number">20</span>];   <span class="comment">// 车辆名称</span></span><br><span class="line">    <span class="keyword">char</span> carWay[<span class="number">10</span>];    <span class="comment">// 排档方式</span></span><br><span class="line">    <span class="keyword">float</span> price;        <span class="comment">// 每日租金</span></span><br><span class="line">    <span class="keyword">char</span> status[<span class="number">3</span>];        <span class="comment">// 出租状态 'y' 'n'</span></span><br><span class="line">    order* firstOrder;  <span class="comment">// 此车辆的订单追踪</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CarInfo</span>* <span class="title">next</span>;</span><span class="comment">// 指向同类型的下一个车辆</span></span><br><span class="line">&#125; car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CarType</span>  // 车辆分类信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> carId[<span class="number">3</span>];         <span class="comment">// 车辆类型编码   '1'-'5'</span></span><br><span class="line">    <span class="keyword">char</span> type[<span class="number">20</span>];      <span class="comment">// 车辆类型名称</span></span><br><span class="line">    <span class="keyword">int</span> count;          <span class="comment">// 库存数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CarType</span>* <span class="title">next</span>;</span>      <span class="comment">// 下一个车辆分类信息</span></span><br><span class="line">    car* sub;           <span class="comment">// 此类型车辆的具体车辆信息</span></span><br><span class="line">&#125; cartype;</span><br></pre></td></tr></table></figure><p>链表的增删查改，插入的时候一般有头插法和尾插法，就不赘述了。</p><p>查询的时候我想用hash结构，但发现C里面并没有哈希表，得自己造轮子……</p><p>而且C也没有动态数组……没有容器……都是定义指针、分配地址</p><p>说到分配地址，面试的时候面试官可能就会问new和malloc关键词有什么区别？</p><p>很显然，new是C++的关键词，而malloc是C的关键词。</p><p>new一个对象后一般用delete释放内存，malloc用free释放内存。</p><p>new的时候不需要指定内存块的大小，编译器会帮你计算，而malloc需要输入内存块大小，一般用sizeof(obj)。</p><p>具体的区别如下：</p><blockquote><ol start="0"><li>属性</li></ol><p>new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</p><ol><li>参数</li></ol><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p><ol start="2"><li>返回类型</li></ol><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p><ol start="3"><li>分配失败</li></ol><p>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p><ol start="4"><li><p>自定义类型</p><p> new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。</p><p> malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p></li><li><p>重载</p></li></ol><p>C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</p><ol start="6"><li>内存区域</li></ol><p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p></blockquote><p>关于KMP算法，也是面试时候的一个难点，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP算法的辅助数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">(<span class="keyword">char</span> *T,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模糊查询的核心算法 KMP算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[MAX_LINE_SIZE];</span><br><span class="line">    Next(T,next);<span class="comment">//根据模式串T,初始化next数组</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="comment">//j==0:代表模式串的第一个字符就和当前测试的字符不相等；S[i-1]==T[j-1],如果对应位置字符相等，两种情况下，指向当前测试的两个指针下标i和j都向后移</span></span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span> || S[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];<span class="comment">//如果测试的两个字符不相等，i不动，j变为当前测试字符串的next值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;<span class="built_in">strlen</span>(T)) &#123;<span class="comment">//如果条件为真，说明匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-(<span class="keyword">int</span>)<span class="built_in">strlen</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言文件读取这一块我感觉还是比C++和python麻烦，用fopen选择文件路径和打开的模式(mode)，这里想记录一下，文件读写结构体数据，fwrite()和fread()，如果结构体里有指针，那么这个结构体存入文件再读取的话，指针指向的地址可能已经释放了，成了野指针，所以从文件里读取结构体后需要对指针重新赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取车辆类型信息csv</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_car_type_csv</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cartype* p;</span><br><span class="line">    p = p_type_head = (cartype*) <span class="built_in">malloc</span> (CARTYPESIZE);</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *filePath = <span class="string">"./output/车辆分类信息表_.csv"</span>;</span><br><span class="line">    fp = fopen(filePath, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[打开文件『 %s 』失败...]\n"</span>, filePath);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[正在读取%s...]\n"</span>, filePath);</span><br><span class="line">    <span class="keyword">char</span> buff[MAX_LINE_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *info;</span><br><span class="line">    <span class="keyword">char</span> *tok;</span><br><span class="line">    info = fgets(buff, MAX_LINE_SIZE, fp);   <span class="comment">// 读取csv内容到buff</span></span><br><span class="line">    <span class="comment">//printf("%s\n", buff);</span></span><br><span class="line">    tok = strtok(buff, <span class="string">","</span>);</span><br><span class="line">    tok = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">    tok = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">    <span class="keyword">while</span> ((info = fgets(buff, MAX_LINE_SIZE, fp)) != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("%s\n", buff);</span></span><br><span class="line">        cartype* cur;</span><br><span class="line">        cur = (cartype*) <span class="built_in">malloc</span> (CARTYPESIZE+<span class="number">1</span>);</span><br><span class="line">        tok = strtok(buff, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (tok == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(cur-&gt;carId, tok);</span><br><span class="line">        tok = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (tok == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(cur-&gt;type, tok);</span><br><span class="line">        tok = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (tok == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur-&gt;count = atoi(tok);</span><br><span class="line">        cur-&gt;sub = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next = cur;</span><br><span class="line">        p = cur;</span><br><span class="line">        show_car_type(cur);</span><br><span class="line">        <span class="comment">//printf("%s | %s | %d\n", cur-&gt;carId, cur-&gt;type, cur-&gt;count);</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;sub = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s读取成功...]\n"</span>, filePath);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言太久没接触了，这次写代码感觉经常出现内存方面的问题，通过排查发现绝大多数原因还是指针没有分配地址或者指针指向无效的地址这些原因导致的，所以写C的时候，一定要认真细致啊~</p><p>代码: <a href="https://github.com/RaoXuntian/c_carIMS" target="_blank" rel="noopener">https://github.com/RaoXuntian/c_carIMS</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C++关键字之static</title>
      <link href="/2020/06/05/learnCpp-static/"/>
      <url>/2020/06/05/learnCpp-static/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是static"><a href="#1-什么是static" class="headerlink" title="1.什么是static"></a>1.什么是static</h3><p>static 是 C/C++ 中很常用的修饰符，它被用来控制变量的存储方式和可见性。</p><h4 id="1-1-static的引入"><a href="#1-1-static的引入" class="headerlink" title="1.1.static的引入"></a>1.1.static的引入</h4><p>我们知道在函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义为全局的变量，但定义一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数控制）。static 关键字则可以很好的解决这个问题。</p><p>另外，在 C++ 中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。</p><a id="more"></a><h4 id="1-2-静态数据存储"><a href="#1-2-静态数据存储" class="headerlink" title="1.2.静态数据存储"></a>1.2.静态数据存储</h4><p><strong>全局（静态）存储区</strong>：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</p><p>在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。</p><p>这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main() 函数前的全局数据声明和定义处。</p><p>静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的”尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。</p><p>static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p><p><strong>优势：</strong>可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。</p><h3 id="2-static的作用"><a href="#2-static的作用" class="headerlink" title="2.static的作用"></a>2.static的作用</h3><h4 id="2-1-全局静态变量"><a href="#2-1-全局静态变量" class="headerlink" title="2.1.全局静态变量"></a>2.1.全局静态变量</h4><p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。</p><p>内存中的位置：静态存储区，在整个程序运行期间一直存在。</p><p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。</p><p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p><h4 id="2-2-局部静态变量"><a href="#2-2-局部静态变量" class="headerlink" title="2.2.局部静态变量"></a>2.2.局部静态变量</h4><p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p><p>内存中的位置：静态存储区。</p><p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。</p><p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">count_calls</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure><h4 id="2-3-静态函数"><a href="#2-3-静态函数" class="headerlink" title="2.3.静态函数"></a>2.3.静态函数</h4><p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p><p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。</p><p>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰。</p><h4 id="2-4-类的静态成员"><a href="#2-4-类的静态成员" class="headerlink" title="2.4.类的静态成员"></a>2.4.类的静态成员</h4><p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用，而且不需要生成对象就可以访问该成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> y;      <span class="comment">//普通变量成员</span></span><br><span class="line">  <span class="keyword">int</span> &amp;r;     <span class="comment">//引用成员变量</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> d;    <span class="comment">//常量成员变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c;   <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">A():y(<span class="number">1</span>), r(y), d(<span class="number">3</span>)&#123;&#125;;</span><br><span class="line">~A()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::c = <span class="number">1</span>;<span class="comment">// 初始化静态成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">A b;</span><br><span class="line">a.c=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 2</span></span><br><span class="line">b.c=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.c &lt;&lt; <span class="string">" "</span> &lt;&lt; b.c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 3 3</span></span><br><span class="line">A::c=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.c &lt;&lt; <span class="string">" "</span> &lt;&lt; b.c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 4 4</span></span><br><span class="line">A c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c.c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 4</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享。</strong>对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，<strong>静态变量不能使用构造函数初始化</strong>。</p><h4 id="2-5-类的静态函数"><a href="#2-5-类的静态函数" class="headerlink" title="2.5.类的静态函数"></a>2.5.类的静态函数</h4><p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p><p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running ~A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A::f();<span class="comment">// 调用类的静态函数，不需要对象名</span></span><br><span class="line">&#123;</span><br><span class="line">A a;</span><br><span class="line">a.f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"END of main"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">running f()</span><br><span class="line">running A()</span><br><span class="line">running f()</span><br><span class="line">running ~A()</span><br><span class="line">END of main</span><br></pre></td></tr></table></figure><p>在上面的程序中，类A的对象a在括号内是非静态的，所以出了括号之后，a的”生命“也就结束了。如果在括号内将类的对象声明为静态的会怎么样呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running ~A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A::f();</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> A a;</span><br><span class="line">a.f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"END of main"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">running f()</span><br><span class="line">running A()</span><br><span class="line">running f()</span><br><span class="line">END of main</span><br><span class="line">running ~A()</span><br></pre></td></tr></table></figure><p>我们可以清晰地看到，a的析构函数是在main函数结束之后才调用的。这是因为，静态对象的范围是贯穿程序的生命周期。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul><li>（1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。</li><li>（2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</li><li>（3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</li><li>（4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。</li><li>（5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）</li></ul><h3 id="4-相关文章"><a href="#4-相关文章" class="headerlink" title="4.相关文章"></a>4.相关文章</h3><ul><li><a href="https://www.runoob.com/w3cnote/cpp-static-usage.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-static-usage.html</a></li><li><a href="https://blog.csdn.net/men_wen/article/details/64443040" target="_blank" rel="noopener">https://blog.csdn.net/men_wen/article/details/64443040</a></li><li><a href="https://light-city.club/sc/basic_content/static/" target="_blank" rel="noopener">https://light-city.club/sc/basic_content/static/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈c++的指针与引用</title>
      <link href="/2020/06/04/pointer-and-reference/"/>
      <url>/2020/06/04/pointer-and-reference/</url>
      
        <content type="html"><![CDATA[<h3 id="1-指针与引用"><a href="#1-指针与引用" class="headerlink" title="1.指针与引用"></a>1.指针与引用</h3><h4 id="1-1指针和引用的区别"><a href="#1-1指针和引用的区别" class="headerlink" title="1.1指针和引用的区别"></a>1.1指针和引用的区别</h4><p>1.指针有自己的一块空间，而引用只是一个别名；</p><p>2.使用sizeof看一个指针的大小是4或8，而引用则是被引用对象的大小；</p><p>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</p><p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p><p>5.可以有const指针，但是没有const引用；</p><p>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</p><p>7.指针可以有多级指针（**p），而引用只有一级；</p><p>8.指针和引用使用++运算符的意义不一样；</p><p>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *pt = &amp;i, &amp;ri = i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//pt = 0x7ffee43d269c</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ri &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//ri = 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(pt) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// sizeof(pt) = 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(ri) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// sizeof(ri) = 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptt;<span class="comment">// 合法，但ptt为野指针，需要小心使用</span></span><br><span class="line"><span class="keyword">int</span> *pttt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//int &amp;rii;// 错误：引用必须初始化</span></span><br><span class="line"><span class="comment">//int &amp;riii = 1;// 错误：非const引用不能指向const</span></span><br><span class="line"><span class="comment">//上面语句实际的操作是分两步</span></span><br><span class="line"><span class="comment">//const int tmp = 1;</span></span><br><span class="line"><span class="comment">//int &amp;riii = tmp;// 这一步错误</span></span><br><span class="line"></span><br><span class="line">ri++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// i = 4</span></span><br><span class="line">(*pt)++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// i = 5</span></span><br><span class="line"><span class="comment">//*pt++;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; pt &lt;&lt; endl; // pt = 0x7ffee43d26a0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><h4 id="2-1引用概念"><a href="#2-1引用概念" class="headerlink" title="2.1引用概念"></a>2.1引用概念</h4><p><strong>引用</strong>(<strong>reference</strong>)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;<span class="comment">// refVal指向ival(是ival的另一个名字)</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;<span class="comment">// 报错：引用必须被初始化</span></span><br></pre></td></tr></table></figure><p>一般在初始化话变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序吧引用和它的初始值<strong>绑定</strong>(<strong>bind</strong>)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p><p><strong>引用即别名</strong></p><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p><p>定义一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">refVal = <span class="number">2</span>;<span class="comment">// 把2赋给refVal指向的对象，此处即是赋给了ival</span></span><br><span class="line"><span class="keyword">int</span> ii = refVal;<span class="comment">// 与ii = ival执行结果一样</span></span><br></pre></td></tr></table></figure><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valid:refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal;</span><br><span class="line"><span class="comment">// 利用与refVal绑定的对象的值初始化变量i</span></span><br><span class="line"><span class="keyword">int</span> i = refVal;<span class="comment">//valid:i被初始化为ival的值</span></span><br></pre></td></tr></table></figure><p>因为引用本事不是一个对象，所以不能定义引用的引用。</p><h4 id="2-2引用的定义"><a href="#2-2引用的定义" class="headerlink" title="2.2引用的定义"></a>2.2引用的定义</h4><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, i2 = <span class="number">2048</span>;<span class="comment">// i和i2都是int</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = i, r2 = i2;<span class="comment">// r是一个引用，与i绑定在一起，r2是int</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3;<span class="comment">// i3是int，ri是一个引用，与i3绑定在一起</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = i3, &amp;r4 = i2;<span class="comment">// r3和r4都是引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;refVal4 = <span class="number">10</span>;<span class="comment">// 错误：引用类型初始值必须是一个对象</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal5 = dval;<span class="comment">// 错误：此处引用类型的初始值必须是int型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;refVal4 = <span class="number">10</span>; <span class="comment">// valid</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;refVal5 = dval;<span class="comment">// valid</span></span><br></pre></td></tr></table></figure><h4 id="2-3左值引用"><a href="#2-3左值引用" class="headerlink" title="2.3左值引用"></a>2.3左值引用</h4><p>严格来说，当我们使用术语“引用(reference)”时，指的其实就是“左值引用(lvalue reference)”。</p><p>常规引用，一般表示对象的身份</p><h4 id="2-4右值引用"><a href="#2-4右值引用" class="headerlink" title="2.4右值引用"></a>2.4右值引用</h4><p>敬请期待。。。</p><h3 id="3-指针"><a href="#3-指针" class="headerlink" title="3.指针"></a>3.指针</h3><h4 id="3-1指针概念"><a href="#3-1指针概念" class="headerlink" title="3.1指针概念"></a>3.1指针概念</h4><p><strong>指针</strong>(<strong>pointer</strong>)是“指向(<strong>point to</strong>)”另外一种类型的复合类型。</p><p>与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。</p><ol><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li><li>指针无须在定义时赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li></ol><h4 id="3-2指针值"><a href="#3-2指针值" class="headerlink" title="3.2指针值"></a>3.2指针值</h4><p>指针的值（即地址）应该属于下列4种状态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p>试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法估计，因此程序猿必须清楚任意给定的指针是否有效。</p><p>尽管第2、3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。</p><h4 id="3-3空指针"><a href="#3-3空指针" class="headerlink" title="3.3空指针"></a>3.3空指针</h4><p><strong>空指针</strong>(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;<span class="comment">// 等价于int *p1 = 0;</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;<span class="comment">// 直接将p2初始化为字母常量0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;<span class="comment">// 等价于int *p3 = 0;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0x0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0x0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p3 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0x0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">long</span>)p1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>在效验一个指针是否为一个有效指针时，我们应该倾向于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip)</span><br></pre></td></tr></table></figure><p>为什么有人会用if(ip)这种方式校验一个指针非空，而且在C++中不会出现错误呢？而且现在很多人都会这样写。<br>原因是这样的，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define   NULL   pointer   value   */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>   NULL   </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span>   __cplusplus   </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span>   NULL      0   </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span>   </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span>   NULL      ((void   *)0)   </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//   NULL</span></span></span><br></pre></td></tr></table></figure><p>思考一道腾讯面试题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = (<span class="keyword">long</span>)(((<span class="keyword">int</span> *)<span class="number">0</span>)+<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>a = 8</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> b = (<span class="keyword">long</span>)(((<span class="keyword">int</span> *)<span class="number">8</span>)+<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>b = 24</p><h4 id="3-4野指针"><a href="#3-4野指针" class="headerlink" title="3.4野指针"></a>3.4野指针</h4><p>野指针不是空指针，是一个指向垃圾内存的指针。</p><p><strong>形成原因</strong></p><ol><li><p>指针变量没有初始化。</p><p>任何指针变量被刚创建时不会被自动初始化为<strong>NULL</strong>指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为<strong>NULL</strong>，要么让它指向合法的内存。例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="literal">NULL</span>;  </span><br><span class="line"><span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>指针被free或delete之后，没有设置NULL，让人误以为是合法指针。</p><p><strong>free</strong>和<strong>delete</strong>只是把指针所指向的内存给释放掉，但并没有把指针本身给清理掉。这时候的指针依然指向原来的位置，只不过这个位置的内存数据已经被毁尸灭迹，此时的这个指针指向的内存就是一个垃圾内存。但是此时的指针由于并不是一个<strong>NULL</strong>指针（在没有置为<strong>NULL</strong>的前提下），在做如下指针校验的时候：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>会逃过校验，此时的p不是一个NULL指针，也不指向一个合法的内存块，造成会面程序中指针访问的失败。</p></li><li><p>指针操作超越了变量的作用范围。</p><p>由于C/C++中指针有++操作，因而在执行该操作的时候，稍有不慎，就容易指针访问越界，访问了一个不该访问的内存，结果程序崩溃<br>另一种情况是指针指向一个临时变量的引用，当该变量被释放时，此时的指针就变成了一个野指针，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A *p;<span class="comment">// A为一个自定义对象  </span></span><br><span class="line">&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    p = &amp;a;<span class="comment">// 注意 a 的生命期 ，只在这个程序块中（花括号里面的两行），而不是整个test函数  </span></span><br><span class="line">&#125;  </span><br><span class="line">p-&gt;Func();<span class="comment">// p是“野指针”</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-相关文章"><a href="#4-相关文章" class="headerlink" title="4.相关文章"></a>4.相关文章</h3><ul><li><a href="https://blog.csdn.net/u014647208/article/details/53383223" target="_blank" rel="noopener">https://blog.csdn.net/u014647208/article/details/53383223</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C++关键字之const</title>
      <link href="/2020/06/03/learnCpp-const/"/>
      <url>/2020/06/03/learnCpp-const/</url>
      
        <content type="html"><![CDATA[<p>C++关键字之const</p><h3 id="1-const含义"><a href="#1-const含义" class="headerlink" title="1.const含义"></a>1.const含义</h3><p>const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。</p><h3 id="2-const作用"><a href="#2-const作用" class="headerlink" title="2.const作用"></a>2.const作用</h3><h4 id="2-1定义const常量"><a href="#2-1定义const常量" class="headerlink" title="2.1定义const常量"></a>2.1定义const常量</h4><p><code>const int* bufSize = 64;</code></p><h4 id="2-2便于进行类型检查"><a href="#2-2便于进行类型检查" class="headerlink" title="2.2便于进行类型检查"></a>2.2便于进行类型检查</h4><p>const*常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误。</p><a id="more"></a><h4 id="2-3可以保护别修饰的东西"><a href="#2-3可以保护别修饰的东西" class="headerlink" title="2.3可以保护别修饰的东西"></a>2.3可以保护别修饰的东西</h4><p>防止修改，起保护作用，增加程序健壮性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">i++; <span class="comment">//error!    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4为函数重载提供一个参考"><a href="#2-4为函数重载提供一个参考" class="headerlink" title="2.4为函数重载提供一个参考"></a>2.4为函数重载提供一个参考</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">           ......</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span>       </span>&#123;......&#125; <span class="comment">//一个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;......&#125; <span class="comment">//上一个函数的重载</span></span><br><span class="line">           ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-5可以节省空间，避免不必要的内存分配"><a href="#2-5可以节省空间，避免不必要的内存分配" class="headerlink" title="2.5可以节省空间，避免不必要的内存分配"></a>2.5可以节省空间，避免不必要的内存分配</h4><p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159         <span class="comment">//常量宏</span></span></span><br><span class="line"><span class="keyword">const</span> doulbe  Pi=<span class="number">3.14159</span>;  <span class="comment">//此时并未将Pi放入ROM中</span></span><br><span class="line">              ......</span><br><span class="line"><span class="keyword">double</span> i=Pi;   <span class="comment">//此时为Pi分配内存，以后不再分配！</span></span><br><span class="line"><span class="keyword">double</span> I=PI;  <span class="comment">//编译期间进行宏替换，分配内存</span></span><br><span class="line"><span class="keyword">double</span> j=Pi;  <span class="comment">//没有内存分配</span></span><br><span class="line"><span class="keyword">double</span> J=PI;  <span class="comment">//再进行宏替换，又一次分配内存！</span></span><br></pre></td></tr></table></figure><h4 id="2-6提高了效率"><a href="#2-6提高了效率" class="headerlink" title="2.6提高了效率"></a>2.6提高了效率</h4><p>可以很方便地进行参数的调整和修改，同宏定义一样，可以做到不变则已，一变都变。</p><p>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</p><h3 id="3-const使用"><a href="#3-const使用" class="headerlink" title="3.const使用"></a>3.const使用</h3><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰函数相关，包括修饰函数参数和函数返回值；</li><li>修饰类成员函数，说明该成员函数内不能修改成员变量。</li></ol><h4 id="3-1修饰变量"><a href="#3-1修饰变量" class="headerlink" title="3.1修饰变量"></a>3.1修饰变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>; </span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> bufSize1 = <span class="number">1024</span>; </span><br><span class="line"><span class="comment">// 以上两种定义形式在本质上是一样的，const修饰的类型为int的变量是不可变的</span></span><br><span class="line">bufSize = <span class="number">1024</span><span class="comment">// 错误：试图向const int对象写值，不能改变bufSize</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = a;<span class="comment">// ci=64</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cis = <span class="keyword">sizeof</span>(a);<span class="comment">// cis=4</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;<span class="comment">// 错误：k是一个未经初始化的变量</span></span><br></pre></td></tr></table></figure><h4 id="3-2修饰指针"><a href="#3-2修饰指针" class="headerlink" title="3.2修饰指针"></a>3.2修饰指针</h4><p>将const用于指针有一些很微妙的地方（指针本身看上去就很微妙），我们将详细探讨一下用两种不同的方式将const关键字用于指针。</p><h5 id="3-2-1-pointer-to-const"><a href="#3-2-1-pointer-to-const" class="headerlink" title="3.2.1 pointer to const"></a>3.2.1 pointer to const</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pt = &amp;age;<span class="comment">// a pointer to const int</span></span><br><span class="line"><span class="comment">// 该声明指出，pt指向一个const int(这里是17)，因此不能用pt来改变这个值。</span></span><br><span class="line"><span class="comment">// 换句话说，*pt的值为const，不能修改。</span></span><br><span class="line"></span><br><span class="line">(*pt)++;<span class="comment">// 错误：指针pt指向的对象是const int</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; *pt<span class="comment">// 错误：同上</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 现在来看一个微妙的问题。</span></span><br><span class="line"><span class="comment">// pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。</span></span><br><span class="line">*pt = <span class="number">23</span>;<span class="comment">// 错误：指针pt指向的对象是const int</span></span><br><span class="line">age = <span class="number">23</span>;<span class="comment">// valid:beacause age is not declared to be const</span></span><br></pre></td></tr></table></figure><h5 id="3-2-2-const-pointer"><a href="#3-2-2-const-pointer" class="headerlink" title="3.2.2 const pointer"></a>3.2.2 const pointer</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sloth = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ps = &amp;sloth;<span class="comment">// a pointer to const int</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> finger = &amp;sloth;<span class="comment">// a const pointer to int</span></span><br><span class="line"><span class="comment">// finger只能指向sloth，但允许使用finger来修改sloth的值。</span></span><br><span class="line"><span class="comment">// ps不能修改sloth的值，但允许ps指向另一个位置。</span></span><br><span class="line">finger = &amp;age;<span class="comment">// invalid</span></span><br><span class="line">*finger = <span class="number">5</span>;<span class="comment">// valid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简言之：finger和*ps都是const，而*finger和ps不是</span></span><br></pre></td></tr></table></figure><h5 id="3-2-3-summary"><a href="#3-2-3-summary" class="headerlink" title="3.2.3 summary"></a>3.2.3 summary</h5><ul><li><p>指针所指向的内容是常量不可变。<br><code>const int *pt;</code></p></li><li><p>指针本身是常量不可变。<br><code>int * const pt;</code></p></li><li><p>两者都不可变。<br><code>const int * const pt;</code></p></li></ul><p><strong>const在*前面，对象是const；</strong><br><strong>const在*后面，指针是const。</strong></p><table><thead><tr><th align="left">Pointers and constants</th><th align="left">int i;</th><th align="left">const int ci = 3;</th></tr></thead><tbody><tr><td align="left">int *ip;//可以通过ip修改</td><td align="left">ip = &i;</td><td align="left">ip = &ci;  // ERROR!</td></tr><tr><td align="left">const int *cip;//不可以通过cip修改</td><td align="left">cip = &i;</td><td align="left">cip = &ci;</td></tr></tbody></table><blockquote><p><strong>尽可能使用const</strong></p><p>将指针参数声明为指向常量数据的指针有两条理由：</p><ul><li>这样可以避免由于无意间修改数据而导致的编程错误。</li><li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。</li></ul><p>如果条件允许，则应该将指针形参声明为指向const的指针。</p></blockquote><h4 id="3-3修饰引用"><a href="#3-3修饰引用" class="headerlink" title="3.3修饰引用"></a>3.3修饰引用</h4><p>可以把引用绑定到const对象上，就像绑定到其它对象上一样，我们称之为对<strong>常量的引用</strong>(<strong>reference to const</strong>)。</p><p>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;<span class="comment">// 正确：引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">// 错误：r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;<span class="comment">// 错误：试图让一个非常量引用(r2)指向一个常量对象(ci)</span></span><br></pre></td></tr></table></figure><p>因为不允许直接为ci赋值，当然也不能通过引用去改变ci。因此，对r2的初始化是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确的。</p><blockquote><p><strong>术语：常量引用是对const的引用</strong></p><hr><p>c++程序猿们经常把词组”对const的引用“简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。</p><p>严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于c++语言并不允许随意改变引用所绑定的对象，所以从这层意思上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。</p></blockquote><ul><li>指向常量的引用(reference to const)</li><li>没有const reference，因为引用本身就是const pointer</li></ul><p><strong>对const的引用可能引用一个并非const的对象</strong></p><p>必须认识到，<strong>常量引用仅对引用可参与的操作做出了限定</strong>，对应引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i; <span class="comment">// 引用r1绑定对象i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;<span class="comment">// r2也绑定对象i，但不允许通过r2修改i的值</span></span><br><span class="line">r1 = <span class="number">0</span>;<span class="comment">// r1并非常量，i的值修改为0</span></span><br><span class="line">r2 = <span class="number">0</span>;<span class="comment">// 错误：r2是一个常量引用</span></span><br></pre></td></tr></table></figure><h4 id="3-4修饰函数相关"><a href="#3-4修饰函数相关" class="headerlink" title="3.4修饰函数相关"></a>3.4修饰函数相关</h4><h5 id="3-4-1修饰函数参数"><a href="#3-4-1修饰函数参数" class="headerlink" title="3.4.1修饰函数参数"></a>3.4.1修饰函数参数</h5><ol><li><p>传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)</p><p><code>void function(const int Var);</code></p></li><li><p>参数指针所指内容为常量不可变</p><p><code>void function(const char* Var);</code></p></li><li><p>参数指针本身为常量不可变(也无意义，因为char* Var也是形参)</p><p><code>void function(char* const Var);</code></p></li><li><p>参数为引用，为了增加效率同时防止修改。修饰引用参数时：</p><p><code>void function(const Class&amp; Var); //引用参数在函数内不可以改变</code></p><p><code>void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变</code></p></li></ol><p>这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的，他禁止对引用的对象的一切修改，唯一不同的是按值传递会先建立一个类对象的副本， 然后传递过去,而它直接传递地址，所以这种传递比按值传递更有效。另外只有引用的const传递可以传递一个临时对象，因为临时对象都是const属性，且是不可见的，他短时间存在一个局部域中，所以不能使用指针，只有引用的const传递能够捕捉到这个家伙。</p><h5 id="3-4-2修饰函数返回值"><a href="#3-4-2修饰函数返回值" class="headerlink" title="3.4.2修饰函数返回值"></a>3.4.2修饰函数返回值</h5><p> const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。</p><ol><li><p><code>const int fun1()</code>    </p><p>   //这个其实无意义，因为参数返回本身就是赋值。</p></li><li><p><code>const int * fun2()</code></p><p>   //调用时 const int *pValue = fun2();<br>   //我们可以把fun2()看作成一个变量，即指针内容不可变。</p></li><li><p><code>int* const fun3()</code></p><p>   //调用时 int * const pValue = fun2();<br>   //我们可以把fun2()看作成一个变量，即指针本身不可变。</p></li></ol><p><strong><em>一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。</em></strong>原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp; test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。</p><h4 id="3-5修饰类成员函数"><a href="#3-5修饰类成员函数" class="headerlink" title="3.5修饰类成员函数"></a>3.5修饰类成员函数</h4><h5 id="3-5-1-const修饰成员变量"><a href="#3-5-1-const修饰成员变量" class="headerlink" title="3.5.1 const修饰成员变量"></a>3.5.1 const修饰成员变量</h5><p>const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        …</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> nValue;         <span class="comment">//成员常量不能被修改</span></span><br><span class="line">        …</span><br><span class="line">        A(<span class="keyword">int</span> x): nValue(x) &#123; &#125; ; <span class="comment">//只能在初始化列表中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-2-const修饰成员函数"><a href="#3-5-2-const修饰成员函数" class="headerlink" title="3.5.2 const修饰成员函数"></a>3.5.2 const修饰成员函数</h5><p>const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。<strong>也就是说，这些函数是”只读”函数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        …</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//常成员函数, 它不改变对象的成员变量.                        </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也不能调用类中任何非const成员函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。</p><p>a. const成员函数不被允许修改它所在对象的任何一个数据成员。</p><p>b. const成员函数能够访问对象的const成员，而其他成员函数不可以。</p><h5 id="3-5-3-const修饰类对象-对象指针-对象引用"><a href="#3-5-3-const修饰类对象-对象指针-对象引用" class="headerlink" title="3.5.3 const修饰类对象/对象指针/对象引用"></a>3.5.3 const修饰类对象/对象指针/对象引用</h5><p>·             const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。</p><p>·             const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。</p><p>·             const对象只能访问const成员函数，而非const对象可以访问任意的成员函数,包括const成员函数。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> AAA aObj;</span><br><span class="line">aObj.func1();<span class="comment">// invalid</span></span><br><span class="line">aObj.func2();<span class="comment">// valid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AAA* aObj = <span class="keyword">new</span> AAA();</span><br><span class="line">aObj-&gt; func1();<span class="comment">// invalid</span></span><br><span class="line">aObj-&gt; func2();<span class="comment">// valid</span></span><br></pre></td></tr></table></figure><h5 id="3-5-4-const修饰重载运算符"><a href="#3-5-4-const修饰重载运算符" class="headerlink" title="3.5.4 const修饰重载运算符"></a>3.5.4 const修饰重载运算符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> student &amp;a ) <span class="keyword">const</span>&#123;     </span><br><span class="line">        <span class="keyword">if</span>(score!=a.score) <span class="keyword">return</span> score&lt;a.score;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(name.compare(a.name)!=<span class="number">0</span>) <span class="keyword">return</span> name&lt;a.name;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(age!=a.age)<span class="keyword">return</span> age&lt;a.age;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>加const是因为：</strong></p><ol><li><p>我们不希望在这个函数中对用来进行赋值的“原版”做任何修改。<strong>函数加上const后缀的作用是表明函数本身不会修改类成员变量。</strong></p></li><li><p>加上const，对于const的和非const的实参，函数就能接受；如果不加，就只能接受非const的实参。</p></li></ol><p><strong>另外补充，用引用是因为：</strong><br>这样可以避免在函数调用时对实参的一次拷贝，提高了效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 指针变量，指向常对象</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure><h3 id="4-const对象默认为文件局部变量"><a href="#4-const对象默认为文件局部变量" class="headerlink" title="4.const对象默认为文件局部变量"></a>4.const对象默认为文件局部变量</h3><p>注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p><h3 id="5-相关文章"><a href="#5-相关文章" class="headerlink" title="5.相关文章"></a>5.相关文章</h3><ul><li>C++ Primer中文版第5版</li><li>C++ Primer Plus中文版第五版</li><li><a href="https://blog.csdn.net/Eric_Jo/article/details/4138548" target="_blank" rel="noopener">https://blog.csdn.net/Eric_Jo/article/details/4138548</a></li><li><a href="https://interview.huihut.com/#/?id=const" target="_blank" rel="noopener">https://interview.huihut.com/#/?id=const</a></li><li><a href="https://blog.csdn.net/qq_36770641/article/details/89884807" target="_blank" rel="noopener">https://blog.csdn.net/qq_36770641/article/details/89884807</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用指令小结</title>
      <link href="/2020/06/02/git/"/>
      <url>/2020/06/02/git/</url>
      
        <content type="html"><![CDATA[<!--<font face="黑体" size=6>Git常用指令小结</font>--><p>废话不多说，直接总结，方便自己以后查~</p><h2 id="1-获得项目的git仓库"><a href="#1-获得项目的git仓库" class="headerlink" title="1.获得项目的git仓库"></a>1.获得项目的git仓库</h2><h3 id="1-1通过git-init初始化本地的新仓库"><a href="#1-1通过git-init初始化本地的新仓库" class="headerlink" title="1.1通过git init初始化本地的新仓库"></a>1.1通过git init初始化本地的新仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir git</span><br><span class="line"><span class="built_in">cd</span> git</span><br><span class="line">git init <span class="comment"># 初始化git仓库</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-2通过git-clone克隆已有的仓库"><a href="#1-2通过git-clone克隆已有的仓库" class="headerlink" title="1.2通过git clone克隆已有的仓库"></a>1.2通过git clone克隆已有的仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><p>比如克隆一个具体的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RaoXuntian/raoxuntian.github.io.git</span><br></pre></td></tr></table></figure><p>如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RaoXuntian/raoxuntian.github.io.git myBlog</span><br></pre></td></tr></table></figure><p>如果希望克隆时直检出指定的分支，可以指定 <code>-b &lt;分支名&gt;</code> 选项，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo https://github.com/RaoXuntian/raoxuntian.github.io.git myBlog</span><br></pre></td></tr></table></figure><p>通常clone命令会把整个仓库的(包含所有分支的)版本数据给克隆下来，如果只想获取某个分支的版本数据，只需要加上 <code>--single-branch</code>选项，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --single-branch -b hexo https://github.com/RaoXuntian/raoxuntian.github.io.git myBlog</span><br></pre></td></tr></table></figure><p>如果你想在克隆仓库时给仓库设置一些不同于全局的git配置，可以通过 <code>--config</code> 选项，其简写选项是 <code>-c</code>，比如，你想给克隆的仓库设置 用户名 和 邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --config user.name=小饶 -c user.email=raoxuntian@gmail.com https://github.com/RaoXuntian/raoxuntian.github.io.git myBlog</span><br></pre></td></tr></table></figure><h2 id="2-添加跟踪文件、暂存"><a href="#2-添加跟踪文件、暂存" class="headerlink" title="2.添加跟踪文件、暂存"></a>2.添加跟踪文件、暂存</h2><p>用命令git add告诉Git，把文件添加到仓库(实际上就是把文件修改添加到暂存区)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br><span class="line"></span><br><span class="line">git add -A</span><br></pre></td></tr></table></figure><h2 id="3-提交更新"><a href="#3-提交更新" class="headerlink" title="3.提交更新"></a>3.提交更新</h2><p>用命令git commit告诉Git，把文件提交到仓库(实际上就是把暂存区的所有内容提交到当前分支)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"有意义的附加说明"</span></span><br></pre></td></tr></table></figure><h2 id="4-检测当前工作区状态"><a href="#4-检测当前工作区状态" class="headerlink" title="4.检测当前工作区状态"></a>4.检测当前工作区状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">git status -sb</span><br></pre></td></tr></table></figure><h2 id="5-查看修改内容"><a href="#5-查看修改内容" class="headerlink" title="5.查看修改内容"></a>5.查看修改内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><h2 id="6-移除文件"><a href="#6-移除文件" class="headerlink" title="6.移除文件"></a>6.移除文件</h2><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm 文件</span><br></pre></td></tr></table></figure><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆.a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件</span><br></pre></td></tr></table></figure><p>后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm <span class="built_in">log</span>/\*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有log/ 目录下扩展名为 .log 的文件。类似的比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm \*~</span><br></pre></td></tr></table></figure><p>会递归删除当前目录及其子目录中所有 ~ 结尾的文件。</p><h2 id="7-查看历史"><a href="#7-查看历史" class="headerlink" title="7.查看历史"></a>7.查看历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline   <span class="comment">#——要求版本信息只能在一行中显示</span></span><br></pre></td></tr></table></figure><h2 id="8-撤销修改"><a href="#8-撤销修改" class="headerlink" title="8.撤销修改"></a>8.撤销修改</h2><h3 id="8-1修改最后一次提交"><a href="#8-1修改最后一次提交" class="headerlink" title="8.1修改最后一次提交"></a>8.1修改最后一次提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。<br> 如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 <code>--amend</code> 提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'initial commit'</span></span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p><h3 id="8-2取消已经暂存的文件"><a href="#8-2取消已经暂存的文件" class="headerlink" title="8.2取消已经暂存的文件"></a>8.2取消已经暂存的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;…</span><br></pre></td></tr></table></figure><h3 id="8-3取消对文件的修改"><a href="#8-3取消对文件的修改" class="headerlink" title="8.3取消对文件的修改"></a>8.3取消对文件的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;…</span><br></pre></td></tr></table></figure><p>命令git checkout – filename意思就是，把filename文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是filename自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是filename已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，版本回退，不过前提是没有推送到远程库。</p><h2 id="9-移动文件"><a href="#9-移动文件" class="headerlink" title="9.移动文件"></a>9.移动文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv 文件_from  文件_to</span><br></pre></td></tr></table></figure><p>其实，运行 git mv 就相当于运行了下面三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv  文件_from  文件_to </span><br><span class="line">git rm  文件_from </span><br><span class="line">git add  文件_to</span><br></pre></td></tr></table></figure><h2 id="10-远程仓库"><a href="#10-远程仓库" class="headerlink" title="10.远程仓库"></a>10.远程仓库</h2><h3 id="10-1查看当前远程库"><a href="#10-1查看当前远程库" class="headerlink" title="10.1查看当前远程库"></a>10.1查看当前远程库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><p>查看当前配置的远程仓库。它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v ：（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址，提供更多信息；</span><br></pre></td></tr></table></figure><h3 id="10-2添加远程仓库"><a href="#10-2添加远程仓库" class="headerlink" title="10.2添加远程仓库"></a>10.2添加远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [仓库名] [url]</span><br></pre></td></tr></table></figure><p>添加一个新的远程仓库，指定名字为 <code>仓库名</code>，以便将来引用；</p><h3 id="10-3从远程仓库抓取数据"><a href="#10-3从远程仓库抓取数据" class="headerlink" title="10.3从远程仓库抓取数据"></a>10.3从远程仓库抓取数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [远程仓库名]</span><br></pre></td></tr></table></figure><p>此命令会到名为 <code>远程仓库名</code> 的远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。</p><p>如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，<code>git fetch origin</code> 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。<br> 如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用 <code>git pull</code>  命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 <code>git clone</code> 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 <code>git pull</code>，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p><h3 id="10-4推送数据到远程仓库"><a href="#10-4推送数据到远程仓库" class="headerlink" title="10.4推送数据到远程仓库"></a>10.4推送数据到远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库S] [本地分支L]:[远程分支R]</span><br></pre></td></tr></table></figure><p>表示：把 <code>本地分支L</code> 推送到 <code>远程仓库S</code> 的 <code>远程分支R</code> 中，如果 <code>远程仓库S</code> 中不存在 <code>远程分支R</code>，则会在 <code>远程仓库S</code> 中 创建 <code>远程分支R</code> 并把 <code>本地分支L</code> 推送到 <code>远程分支R</code> 中；如果本地分支L和远程分支R名字相同，则可以简写为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库S] [本地分支L]</span><br></pre></td></tr></table></figure><p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那 你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p><h3 id="10-5删除远程分支"><a href="#10-5删除远程分支" class="headerlink" title="10.5删除远程分支"></a>10.5删除远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库S] :[远程分支R]</span><br></pre></td></tr></table></figure><p>这个命令的格式意义比较无理头，为了方便记忆，可以这样理解：它是省略了本地分支名的推送命令 <code>git push [远程仓库S] [本地分支L]:[远程分支R]</code>，省略 <code>本地分支L</code> 表示：在这里提取空白然后把它变成 <code>远程分支R</code>。</p><h3 id="10-6查看远程仓库信息"><a href="#10-6查看远程仓库信息" class="headerlink" title="10.6查看远程仓库信息"></a>10.6查看远程仓库信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [远程仓库名]</span><br></pre></td></tr></table></figure><p>查看名为 <code>远程仓库名</code> 的远程仓库的详细信息</p><h3 id="10-7远程仓库的重命名"><a href="#10-7远程仓库的重命名" class="headerlink" title="10.7远程仓库的重命名"></a>10.7远程仓库的重命名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename  [远程仓库旧名]   [远程仓库新名]</span><br></pre></td></tr></table></figure><p>修改某个远程仓库在本地的名称（新版 Git 中支持）；<br>注意，对远程仓库的重命名，也会使对应的分支名称发生变化;</p><h3 id="10-8远程仓库的删除"><a href="#10-8远程仓库的删除" class="headerlink" title="10.8远程仓库的删除"></a>10.8远程仓库的删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm  [远程仓库名]</span><br></pre></td></tr></table></figure><h3 id="10-9本地仓库同步远程仓库"><a href="#10-9本地仓库同步远程仓库" class="headerlink" title="10.9本地仓库同步远程仓库"></a>10.9本地仓库同步远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/RaoXuntian/raoxuntian.github.io.git<span class="comment"># 本地添加远程仓库</span></span><br><span class="line">git push -u origin master:hexo<span class="comment"># 本地master分支同步到远程的hexo分支</span></span><br></pre></td></tr></table></figure><h2 id="11-分支"><a href="#11-分支" class="headerlink" title="11.分支"></a>11.分支</h2><h3 id="11-1新建分支"><a href="#11-1新建分支" class="headerlink" title="11.1新建分支"></a>11.1新建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch  [分支名]</span><br></pre></td></tr></table></figure><p>注意：此命令仅仅是建立了一个新的分支，但不会自动切换到这个分支中去；</p><h3 id="11-2切换分支"><a href="#11-2切换分支" class="headerlink" title="11.2切换分支"></a>11.2切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [分支名]</span><br></pre></td></tr></table></figure><h3 id="11-3新建并切换分支"><a href="#11-3新建并切换分支" class="headerlink" title="11.3新建并切换分支"></a>11.3新建并切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [分支名]</span><br></pre></td></tr></table></figure><p>相当于以下2条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch [分支名]</span><br><span class="line">git checkout [分支名]</span><br></pre></td></tr></table></figure><h3 id="11-4合并分支"><a href="#11-4合并分支" class="headerlink" title="11.4合并分支"></a>11.4合并分支</h3><p>设当前分支为A</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [分支B]</span><br></pre></td></tr></table></figure><p>此命令表示，把分支B合并到分支A</p><h3 id="11-5删除分支"><a href="#11-5删除分支" class="headerlink" title="11.5删除分支"></a>11.5删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [分支名]</span><br></pre></td></tr></table></figure><h3 id="11-6强制删除分支"><a href="#11-6强制删除分支" class="headerlink" title="11.6强制删除分支"></a>11.6强制删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D [分支名]</span><br></pre></td></tr></table></figure><h3 id="11-7查看当前分支列表"><a href="#11-7查看当前分支列表" class="headerlink" title="11.7查看当前分支列表"></a>11.7查看当前分支列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch -a <span class="comment"># 包括远端的分支</span></span><br></pre></td></tr></table></figure><p>返回结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* master</span><br><span class="line">  remotes&#x2F;origin&#x2F;hexo</span><br></pre></td></tr></table></figure><p>带有 <code>*</code> 的分支表示是当前所在的分支；</p><h3 id="11-8查看各个分支最后一次提交对象的信息"><a href="#11-8查看各个分支最后一次提交对象的信息" class="headerlink" title="11.8查看各个分支最后一次提交对象的信息"></a>11.8查看各个分支最后一次提交对象的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><h3 id="11-9查看已经合并到当前所在分支的分支"><a href="#11-9查看已经合并到当前所在分支的分支" class="headerlink" title="11.9查看已经合并到当前所在分支的分支"></a>11.9查看已经合并到当前所在分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure><h3 id="11-10查看未合并到当前所在分支的分支"><a href="#11-10查看未合并到当前所在分支的分支" class="headerlink" title="11.10查看未合并到当前所在分支的分支"></a>11.10查看未合并到当前所在分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure><h3 id="11-11删除远程分支"><a href="#11-11删除远程分支" class="headerlink" title="11.11删除远程分支"></a>11.11删除远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库S] :[远程分支R]</span><br></pre></td></tr></table></figure><p>这个命令的格式意义比较无理头，为了方便记忆，可以这样理解：它是省略了本地分支名的推送命令 <code>git push [远程仓库S] [本地分支L]:[远程分支R]</code>，省略 <code>本地分支L</code> 表示：在这里提取空白然后把它变成 <code>远程分支R</code>。</p><h2 id="12-恢复之前的版本"><a href="#12-恢复之前的版本" class="headerlink" title="12.恢复之前的版本"></a>12.恢复之前的版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看之前版本号</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 版本回退</span></span><br><span class="line">git reset --hard 目标版本号</span><br><span class="line"><span class="comment"># 提交更改</span></span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><h2 id="13-相关文章"><a href="#13-相关文章" class="headerlink" title="13.相关文章"></a>13.相关文章</h2><ul><li><a href="https://github.com/windard/learngit/blob/master/git.txt" target="_blank" rel="noopener">https://github.com/windard/learngit/blob/master/git.txt</a></li><li><a href="https://www.jianshu.com/p/15a4dee9c5df" target="_blank" rel="noopener">https://www.jianshu.com/p/15a4dee9c5df</a></li><li><a href="https://blog.csdn.net/yxlshk/article/details/79944535" target="_blank" rel="noopener">https://blog.csdn.net/yxlshk/article/details/79944535</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/05/29/myFirstBlog/"/>
      <url>/2020/05/29/myFirstBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h2><p>现在是凌晨四点钟，我依旧失眠。</p><p>花了一天半的时间，终于搭建好了第一个个人博客。</p><p>其实本来只想花一天的时间来搭建，但因为一些不能拒绝的琐事而耽误了；</p><p>我虽然不是完美主义者，但也希望这个博客能以最完美的功能和版本online，原本准备在六一正式上线这个博客，但现在必须得提前了，尽管她并不完美……</p><a id="more"></a><h2 id="Welcome-to-my-Salad-Days！"><a href="#Welcome-to-my-Salad-Days！" class="headerlink" title="Welcome to my Salad Days！"></a><em>Welcome to my Salad Days！</em></h2><p><img src="https://tva2.sinaimg.cn/large/005LF7wugy1gf9710jjt1j30j60y3jwp.jpg" alt="image"></p><h2 id="who-am-I"><a href="#who-am-I" class="headerlink" title="who am I ?"></a>who am I ?</h2><p>我是华中科技大学计算机技术专业的硕士研究生，你们可以叫我小饶。</p><p>我曾是一名志愿者，在云南财经大学信息学院青年志愿者协会工作三年。</p><p>我是经常熬夜失眠头秃的孤独患者。</p><p><img src="https://tvax4.sinaimg.cn/large/005LF7wugy1gf97efs2ysj30ib0wlag2.jpg" alt="image"></p><h2 id="what-I-do"><a href="#what-I-do" class="headerlink" title="what I do ?"></a>what I do ?</h2><p>我一开始在实验室研究机器学习和自然语言处理方向的算法，一年的时间也确实自己do了一些算法，但去找实习的时候发现连简历都过不了关，于是现在准备转做工程项目吧，做个低端码农，立志从后端走向全栈。</p><p>我对计算机和编程并没有充满热情，只是比起其他专业，可能这个专业更适合我吧……</p><p>我也不是大佬，我只希望明年毕业的时候能有一份对得起”华科“这个标签的offer。</p><p><img src="https://tvax1.sinaimg.cn/large/005LF7wugy1gf97fj20moj30j60y4qa1.jpg" alt="image"></p><h2 id="what-I-love-？"><a href="#what-I-love-？" class="headerlink" title="what I love ？"></a>what I love ？</h2><p>我喜欢聊天，但我不喜欢闲聊。</p><blockquote><p>我想谈论原子、 死亡、性、外星人、 魔法、智力、生命的意义、遥远的星系，让你想跳舞的音乐、有趣的回忆、你说的谎言、你的缺点、你最喜欢的气味、你的童年、让你彻夜难眠的东西、你的不安全感和恐惧。</p></blockquote><p>我喜欢生活，喜欢记录美好。</p><p>我喜欢五月天。</p><p>我喜欢粤语歌，喜欢张敬轩，喜欢陈奕迅，喜欢杨千嬅。</p><p>我喜欢林夕和黄伟文的词。</p><p><img src="https://tva2.sinaimg.cn/large/005LF7wugy1gf97fw5l15j30j60y3dlv.jpg" alt="image"></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>做这个博客的愿景是希望记录自己成长的点点滴滴，希望自己不是三分钟热度吧.</p><p>六一也快到了，祝我自己六一快乐 :)</p><p><img src="https://tvax1.sinaimg.cn/large/005LF7wugy1gf97g5muo3j30j60y4wjs.jpg" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
