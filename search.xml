<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈MySQL存储引擎</title>
      <link href="/2020/08/03/mysql-engine/"/>
      <url>/2020/08/03/mysql-engine/</url>
      
        <content type="html"><![CDATA[<p>数据库存储引擎是数据库底层软件组织,数据库管理系统(DBMS)使用数据引擎进行创建 查询 更新和删除数据 不同的存储引擎提供不同的存储机制 索引技巧 锁定水平等功能,使用不同的存储引擎,还可以 获得特定的功能 现在许多不同的数据库管理系统都支持多种不同的数据引擎 MySql的核心就是插件式存储引擎。</p><a id="more"></a><h3 id="一-MySQL的存储引擎"><a href="#一-MySQL的存储引擎" class="headerlink" title="一.MySQL的存储引擎"></a>一.MySQL的存储引擎</h3><p>在MySQL下面，我们输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES</span><br></pre></td></tr></table></figure><p>就可以查看MySQL的存储引擎。</p><p>在MySQL中,不需要在整个服务器中使用同一种存储引擎,针对具体的要求,可以对每一个表使用不同的存储引擎 Support列的值表示某种引擎是否能使用:YES表示可以使用 NO表示不能使用 DEFAULT表示该引擎为当前默认的存储引擎 下面来看一下其中几种常用的引擎。</p><h4 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h4><p>InnoDB是事务型数据库的默认引擎，只有在需要它不支持的特性时，才考虑用其它的存储引擎。</p><ul><li>主索引是<strong>聚簇索引</strong>，在索引中保存了数据从而避免直接读取磁盘，因此对查询性能有很大的提升；</li><li>支持事务（ACID）；</li><li>支持行级锁和外键；</li><li>实现了四个标准的隔离级别，默认级别是可重复读。在可重复读的隔离级别下，通过多版本并发控制（MVCC）+间隙锁（Next-Key Locking）防止幻影读；</li><li>支持提交（COMMIT）、回滚（ROLLBACK）、崩溃恢复；</li><li>支持真正的在线热备份；</li><li>内部做了很多优化，包括从磁盘读取数据时采用的可预读性读，能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</li></ul><h4 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h4><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><ul><li>不支持事务和外键；</li><li>不支持行级锁，但支持表级锁，读取时会对需要读到的所有表加共享锁（S锁），写入时则对表加排它锁（X锁）。但在表有读取操作的时候，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）；</li><li>可以手动或自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的；</li><li>不支持在线热备份；</li><li>不支持崩溃后的安全恢复，MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复速度也很慢；</li><li>支持BLOB和TEXT的前500个字符索引，<strong>支持全文索引</strong>；</li><li><strong>支持延迟更新索引</strong>，极大地提升了写入性能；</li><li>对于不会进行修改的表，支持 <strong>压缩表</strong> ，极大地减少了磁盘空间的占用。</li></ul><p>使用MyISAM引擎创建数据库，将产生3个文件，文件的名字以表名字开始，扩展名之处文件类型:frm文件存储表定义，数据文件的扩展名为.MYD(MYData) 索引文件的扩展名时.MYI(MYIndex)。</p><h4 id="3-MEMORY"><a href="#3-MEMORY" class="headerlink" title="3.MEMORY"></a>3.MEMORY</h4><p>MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。</p><p>所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p><h4 id="4-存储引擎的选择"><a href="#4-存储引擎的选择" class="headerlink" title="4.存储引擎的选择"></a>4.存储引擎的选择</h4><p>在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题，每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好，但建议选择使用InnoDB。</p><p>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。</p><p>如果你的应用程序对查询性能要求较高，就要使用MYISAM了。MYISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MYISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。</p><p>《MySQL高性能》上面有一句话这样写到:</p><blockquote><p>不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p></blockquote><p>一般情况下我们选择 InnoDB 都是没有问题的，但是某事情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p><p>注意：同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</p><h3 id="二-为什么InnoDB用B-树做索引"><a href="#二-为什么InnoDB用B-树做索引" class="headerlink" title="二.为什么InnoDB用B+树做索引"></a>二.为什么InnoDB用B+树做索引</h3><h4 id="1-B-树和红黑树的比较"><a href="#1-B-树和红黑树的比较" class="headerlink" title="1.B+树和红黑树的比较"></a>1.B+树和红黑树的比较</h4><p>为什么MySQL用B+树作为其搜索引擎而不用红黑树呢？</p><p>如果不了解红黑树可以先看看红黑树的介绍<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">红黑树</a>。</p><p>红黑树等平衡树也是可以用来实现索引的，但文件系统以及数据库系统普遍采用B+树作为索引结构，主要有以下两个原因：</p><ol><li><p>更少的查找次数</p><p>平衡树查找操作的时间复杂度和树高h相关，O(h)=O(logdN)，其中d为每个节点的出度。</p><p>红黑树的出度为2，而B+树的出度一般都比较大，至少是可以大于2的，所以红黑树的树高h很明显比B+树大的多，所以查找的次数也就更多。</p></li><li><p>利用磁盘预读原理</p><p>AVL 树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘I/O代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B+树的一个节点可以有多个子女，从几十到上千，可以降低树的高度。</p><p>为了减少I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。在预读的过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度切回非常快。</p><p>数据库系统的设计者巧妙利用了磁盘预读原理，<strong>将索引的一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</strong>为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p></li></ol><h4 id="2-B-树和B树的比较"><a href="#2-B-树和B树的比较" class="headerlink" title="2.B+树和B树的比较"></a>2.B+树和B树的比较</h4><p>B+树是大多数MySQL存储引擎的索引类型，</p><p>B树是MongoDB的索引类型</p><p>区别</p><p>B+树：</p><ol><li>数据只出现在叶子节点</li><li>所有叶子节点之间有链指针</li></ol><p>B树：</p><ol><li>树内每个节点都存储数据</li><li>叶子节点之间无指针相连</li></ol><h3 id="三-聚簇索引"><a href="#三-聚簇索引" class="headerlink" title="三.聚簇索引"></a>三.聚簇索引</h3><p>聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录</p><p>InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。</p><p>下图形象说明了聚簇索引表(InnoDB)和非聚簇索引(MyISAM)的区别：</p> <img src="/2020/08/03/mysql-engine/1.png" class="" title="image"><p>1.对于<strong>非聚簇索引表</strong>来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。</p><p>2.对于<strong>聚簇索引表</strong>来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。</p><h4 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h4><p>1.当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。</p><p>2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。</p><p>3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p><h4 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h4><p>1.<strong>插入速度严重依赖于插入顺序</strong>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</p><p>2.<strong>更新主键的代价很高，因为将会导致被更新的行移动</strong>。因此，对于InnoDB表，我们一般定义主键为不可更新。</p><p>3.<strong>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</strong></p><p>二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p><p>4.<strong>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多</strong>，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://segmentfault.com/a/1190000012588602" target="_blank" rel="noopener">MySQL - 常见的三种存储引擎</a></li><li><a href="https://blog.csdn.net/qq_35923749/article/details/88068659" target="_blank" rel="noopener">为什么mysql用B+树做索引而不用B-树或红黑树</a></li><li><a href="https://juejin.im/post/6844903616902332430" target="_blank" rel="noopener">MySQL常见的两种存储引擎：MyISAM与InnoDB的爱恨情仇</a></li><li><a href="https://blog.csdn.net/temp77J/article/details/40653549" target="_blank" rel="noopener">mysql何时使用myisam, 何时使用innodb ?</a></li><li><a href="https://juejin.im/post/6844903845554814983" target="_blank" rel="noopener">说一下聚簇索引 &amp; 非聚簇索引</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> datastruct </tag>
            
            <tag> B树 </tag>
            
            <tag> 红黑树 </tag>
            
            <tag> B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法小结</title>
      <link href="/2020/08/01/sort/"/>
      <url>/2020/08/01/sort/</url>
      
        <content type="html"><![CDATA[<p>排序算法，面试中最经常被问到的问题，我们需要熟悉并了解各种算法的时间和空间复杂度、时间复杂度平均、最坏、最好的情况和是否为稳定排序。</p> <img src="/2020/08/01/sort/0.png" class="" title="image"><a id="more"></a><h3 id="1-插入排序（Insertion-Sort）"><a href="#1-插入排序（Insertion-Sort）" class="headerlink" title="1.插入排序（Insertion Sort）"></a>1.插入排序（Insertion Sort）</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>插入排序的原理有点像我们平时打扑克牌，假设手中的扑克牌要从左到右依次从大到小，你每次抽牌的时候，从右边最小的牌与所抽到的牌比较，从右到左比较，直到找到第一张不小于所抽牌数值大小的牌，插入在其后面，这样就完成了一次插入排序的操作。显然，这样的操作最坏的情况就是每次都要遍历一遍数组，而且如果不是链表这种结构的话，数据插入数组，后面的所有数据都要往后一个位置，造成的开销会很大，时间复杂度O(n^2)。如果数组一开始就是有序的话，那就是最好的时间复杂度，每次插入到最后的位置，且只需要和数组的最后一个元素比较大小，时间复杂度O(n)。</p><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/1.gif" class="" title="image"><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = arr.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.size();</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">-1</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Round "</span> &lt;&lt; count &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">show(arr);</span><br><span class="line"><span class="keyword">while</span> (++cur &lt; len) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur; ~i; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt;= arr[i<span class="number">-1</span>]) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> swap(arr[i], arr[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Round "</span> &lt;&lt; ++count &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">show(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the number of elements: "</span>;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">arr.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Insertion sorting ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">insertionSort(arr);</span><br><span class="line">show(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-希尔排序（Shell-Sort）"><a href="#2-希尔排序（Shell-Sort）" class="headerlink" title="2.希尔排序（Shell Sort）"></a>2.希尔排序（Shell Sort）</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p><strong>希尔排序</strong>（Shellsort），也称<strong>递减增量排序算法</strong>，是<a href="https://zh.wikipedia.org/wiki/插入排序" target="_blank" rel="noopener">插入排序</a>的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到<a href="https://zh.wikipedia.org/w/index.php?title=線性排序&action=edit&redlink=1" target="_blank" rel="noopener">线性排序</a>的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>原始的算法实现在最坏的情况下需要进行<a href="https://zh.wikipedia.org/wiki/大O符号" target="_blank" rel="noopener">O</a>(<em>n</em>2)的比较和交换。 V. Pratt的书<a href="https://zh.wikipedia.org/wiki/希尔排序#cite_note-1" target="_blank" rel="noopener">[1]</a>对算法进行了少量修改，可以使得性能提升至O(<em>n</em> log2 <em>n</em>)。这比最好的<a href="https://zh.wikipedia.org/w/index.php?title=比較算法&action=edit&redlink=1" target="_blank" rel="noopener">比较算法</a>的O(<em>n</em> log <em>n</em>)要差一些。</p><p>希尔排序通过将比较的全部元素分为几个区域来提升<a href="https://zh.wikipedia.org/wiki/插入排序" target="_blank" rel="noopener">插入排序</a>的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的<a href="https://zh.wikipedia.org/wiki/插入排序" target="_blank" rel="noopener">插入排序</a>，但是到了这步，需排序的数据几乎是已排好的了（此时<a href="https://zh.wikipedia.org/wiki/插入排序" target="_blank" rel="noopener">插入排序</a>较快）。</p><p>假设有一个很小的数据在一个已按升序排好序的<a href="https://zh.wikipedia.org/wiki/數組" target="_blank" rel="noopener">数组</a>的末端。如果用复杂度为O(<em>n</em>2)的排序（<a href="https://zh.wikipedia.org/wiki/冒泡排序" target="_blank" rel="noopener">冒泡排序</a>或<a href="https://zh.wikipedia.org/wiki/插入排序" target="_blank" rel="noopener">插入排序</a>），可能会进行<em>n</em>次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p><p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用<a href="https://zh.wikipedia.org/wiki/插入排序" target="_blank" rel="noopener">插入排序</a>）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用<code>i += step_size</code>而不是<code>i++</code>）。</p><p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>然后我们对每列进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>排序之后变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p><h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/2.gif" class="" title="image"><h3 id="3-选择排序（Selection-Sort）"><a href="#3-选择排序（Selection-Sort）" class="headerlink" title="3.选择排序（Selection Sort）"></a>3.选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/3.gif" class="" title="image"><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = arr.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.size();</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">-1</span>, count = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Round "</span> &lt;&lt; ++count &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">show(arr);</span><br><span class="line"><span class="keyword">while</span>(++cur &lt; len<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> minIndex = cur;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur+<span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">minIndex = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr[cur], arr[minIndex]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Round "</span> &lt;&lt; ++count &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">show(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the number of elements: "</span>;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">arr.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Selection sorting ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">selectionSort(arr);</span><br><span class="line">show(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-堆排序（Heap-Sort）"><a href="#4-堆排序（Heap-Sort）" class="headerlink" title="4.堆排序（Heap Sort）"></a>4.堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/4.gif" class="" title="image"><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*堆排序</span></span><br><span class="line"><span class="comment">1.建（大根）堆</span></span><br><span class="line"><span class="comment">2.堆首（最大值）和堆尾互换</span></span><br><span class="line"><span class="comment">3.堆的尺寸缩小1，调整大根堆</span></span><br><span class="line"><span class="comment">4.重复2-3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "Round " &lt;&lt; ++count &lt;&lt; ": ";</span></span><br><span class="line"><span class="keyword">int</span> size = arr.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bigIndex = i;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[bigIndex]) bigIndex = l;</span><br><span class="line"><span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[bigIndex]) bigIndex = r;</span><br><span class="line"><span class="keyword">if</span> (bigIndex != i) &#123;</span><br><span class="line">swap(arr[i], arr[bigIndex]);</span><br><span class="line">heapify(arr, bigIndex, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> round = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; ~i; --i) &#123;</span><br><span class="line">swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">heapify(arr, <span class="number">0</span>, i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Round "</span> &lt;&lt; ++round &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">show(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">builtMaxHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span><span class="number">-1</span>; ~i; i--) &#123;</span><br><span class="line">heapify(arr, i, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the number of elements: "</span>;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">arr.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Built max heap..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">builtMaxHeap(arr, size);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Max Heap: "</span>;</span><br><span class="line">show(arr);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Heap sorting ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">heapSort(arr, size);</span><br><span class="line">show(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-冒泡排序（Bubble-Sort）"><a href="#5-冒泡排序（Bubble-Sort）" class="headerlink" title="5.冒泡排序（Bubble Sort）"></a>5.冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h4 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/5.gif" class="" title="image"><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = arr.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.size();</span><br><span class="line"><span class="keyword">int</span> right = len;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i<span class="number">-1</span>] &gt; arr[i]) swap(arr[i<span class="number">-1</span>], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Round "</span> &lt;&lt; ++count &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">show(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the number of elements: "</span>;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">arr.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Bubble sorting ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">bubbleSort(arr);</span><br><span class="line">show(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><p>（！！！这个需要重点掌握）</p><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="图示-5"><a href="#图示-5" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/6.gif" class="" title="image"><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = arr.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> target = arr[low];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= target) high--;</span><br><span class="line"><span class="keyword">if</span> (arr[high] &lt; target) arr[low++] = arr[high];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= target) low++;</span><br><span class="line"><span class="keyword">if</span> (arr[low] &gt; target) arr[high--] = arr[low];</span><br><span class="line">&#125;</span><br><span class="line">arr[low] = target;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Round x: "</span> ;</span><br><span class="line">show(arr);</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> p = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">quickSort(arr, low, p<span class="number">-1</span>);</span><br><span class="line">quickSort(arr, p+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the number of elements: "</span>;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">arr.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//quick sort</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Quick sorting ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">quickSort(arr, <span class="number">0</span>, size<span class="number">-1</span>);</span><br><span class="line">show(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-归并排序（Merge-Sort）"><a href="#7-归并排序（Merge-Sort）" class="headerlink" title="7.归并排序（Merge Sort）"></a>7.归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="图示-6"><a href="#图示-6" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/7.gif" class="" title="image"><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Round "</span> &lt;&lt; ++count &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"><span class="keyword">int</span> size = arr.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> midIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur = endIndex;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = midIndex + <span class="number">1</span>; i &lt;= endIndex; i++) tmp.push_back(arr[i]);</span><br><span class="line"><span class="keyword">int</span> p1 = midIndex, p2 = endIndex-midIndex<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (~(p1-startIndex) &amp;&amp; ~p2) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp[p2] &lt; arr[p1]) arr[cur--] = arr[p1--];</span><br><span class="line"><span class="keyword">else</span> arr[cur--] = tmp[p2--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (~p2) &#123;</span><br><span class="line">arr[cur--] = tmp[p2--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (~(p1-startIndex)) &#123;</span><br><span class="line">arr[cur--] = arr[p1--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (startIndex &lt; endIndex) &#123;</span><br><span class="line"><span class="keyword">int</span> midIndex = startIndex + ((endIndex - startIndex) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mergeSort(arr, startIndex, midIndex);</span><br><span class="line">mergeSort(arr, midIndex+<span class="number">1</span>, endIndex);</span><br><span class="line"></span><br><span class="line">show(arr, p);</span><br><span class="line">merge(arr, startIndex, midIndex, endIndex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the number of elements: "</span>;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">arr.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Merge sorting ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mergeSort(arr, <span class="number">0</span>, size<span class="number">-1</span>);</span><br><span class="line">show(arr, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="图示-7"><a href="#图示-7" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/8.gif" class="" title="image"><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h4 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h4 id="图示-8"><a href="#图示-8" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/9.png" class="" title="image"><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大</p><h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="图示-9"><a href="#图示-9" class="headerlink" title="图示"></a>图示</h4> <img src="/2020/08/01/sort/10.gif" class="" title="image"><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">希尔排序</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2020/07/21/Linux-command/"/>
      <url>/2020/07/21/Linux-command/</url>
      
        <content type="html"><![CDATA[<p>在实际工作中，许多服务器是Linux操作系统，作为程序员无法避免和Linux打交道，所以在应届生面试的时候，Linux常用指令也是面试官经常考察的一个点。</p><p>除了我们常用的<code>cd</code>、<code>ls</code>，我们应该掌握一些常用的指令</p><h4 id="面试常见的Linux指令"><a href="#面试常见的Linux指令" class="headerlink" title="面试常见的Linux指令"></a>面试常见的Linux指令</h4><a id="more"></a><h3 id="1-pwd"><a href="#1-pwd" class="headerlink" title="1.pwd"></a>1.pwd</h3><ul><li><code>pwd</code>:显示当前目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp1783u2o2usauzn9srez bin]<span class="comment"># pwd</span></span><br><span class="line">/root/miniconda3/bin</span><br></pre></td></tr></table></figure><h3 id="2-mkdir-rmdir"><a href="#2-mkdir-rmdir" class="headerlink" title="2.mkdir/rmdir"></a>2.mkdir/rmdir</h3><ul><li><code>mkdir</code>:建立一个新目录</li></ul><p>这个指令在默认的情况下是要一层一层地建立你所需要的目录。默认的时候你要建立的目录的上级目录必须也要存在，如果想一次建立多层目录，可以<code>-p</code>选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp1783u2o2usauzn9srez ~]<span class="comment"># mkdir test1/test2</span></span><br><span class="line">mkdir: 无法创建目录<span class="string">"test1/test2"</span>: 没有那个文件或目录</span><br><span class="line">[root@izbp1783u2o2usauzn9srez ~]<span class="comment"># mkdir test1/test2 -p</span></span><br><span class="line">[root@izbp1783u2o2usauzn9srez ~]<span class="comment"># ll |grep test</span></span><br><span class="line">drwxr-xr-x  3 root root      4096 7月  22 15:45 test1</span><br></pre></td></tr></table></figure><ul><li><code>rmdir</code>:删除一个<strong>空</strong>目录</li></ul><p>注意这个指令默认是删除一个空目录，加入<code>-p</code>选项连同上层“空的”目录也一起删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp1783u2o2usauzn9srez ~]<span class="comment"># rmdir test1/ &lt;==因为尚有内容，无法删除</span></span><br><span class="line">rmdir: 删除 <span class="string">"test1/"</span> 失败: 目录非空</span><br><span class="line">[root@izbp1783u2o2usauzn9srez ~]<span class="comment"># rmdir test1/test2/ -p</span></span><br><span class="line">[root@izbp1783u2o2usauzn9srez ~]<span class="comment"># ll |grep test</span></span><br></pre></td></tr></table></figure><p>如果想把目录下的东西都删除，这个时候可以使用<code>rm -rf</code>。</p><h3 id="3-cp-rm-mv"><a href="#3-cp-rm-mv" class="headerlink" title="3.cp/rm/mv"></a>3.cp/rm/mv</h3><ul><li><code>cp</code>:复制文件或目录</li></ul><p><code>cp</code>这个指令很重要的，不同身份者执行这个命令会有不同的结果产生。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cp [-adfilprsu] 源文件(<span class="built_in">source</span>) 目标文件(destination)</span><br><span class="line">cp [option] source1 source2 source3 …… directory</span><br><span class="line">选项与参数：</span><br><span class="line">-a:相当于-dr --preserve=all的意思（常用）</span><br><span class="line">-d:若源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；</span><br><span class="line">-i:若目标文件（destination）已经存在，在覆盖时会先询问操作的进行（常用）；</span><br><span class="line">-p:连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</span><br><span class="line">-r:递归复制，用于目录的复制操作（常用）；</span><br><span class="line">最后需要注意的是，如果源文件有两个以上，则最后一个目标文件一定要是“目录”才行。</span><br></pre></td></tr></table></figure><ul><li><code>rm</code>:删除文件或目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-f:就是force的意思，忽略不存在文件，不会出现警告信息；</span><br><span class="line">-I:交互模式，在删除前会询问使用者是否操作；</span><br><span class="line">-r:递归删除，最常用于目录的删除，这是非常危险的选项。</span><br></pre></td></tr></table></figure><p>我们在网上经常看到删库跑路的梗<code>rm -rf /</code>，现在你应该知道这个命令的意思了吧~</p><ul><li><code>mv</code>:移动文件或目录，或重命名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mv [-fiu] source destination</span><br><span class="line">mv [option] source1 source2 source3 …… directory</span><br><span class="line">选项与参数：</span><br><span class="line">-f:就是force的意思，如果目标文件以及存在，不会询问而直接覆盖；</span><br><span class="line">-i:若目标文件（destination）已经存在，就会询问是否覆盖；</span><br><span class="line">-u:若目标文件已经存在，且source比较新，才会更新（update）。</span><br></pre></td></tr></table></figure><h3 id="4-cat-tac-nl-more-less-head-tail-od"><a href="#4-cat-tac-nl-more-less-head-tail-od" class="headerlink" title="4.cat/tac/nl/more/less/head/tail/od"></a>4.cat/tac/nl/more/less/head/tail/od</h3><ul><li><code>cat</code>:从第一行开始显示文件内容。</li><li><code>tac</code>:从最后一行开始显示，可以看出tac是cat的倒着写。</li><li><code>nl</code>:显示的时候，同时输出行号。</li><li><code>more</code>:一页一页地显示文件内容。</li><li><code>less</code>:与more类似，但是比more更好的是，它可以往前翻页。</li><li><code>head</code>:只看前面几行。</li><li><code>tail</code>:只看后面几行。</li><li><code>od</code>:以二进制的方式读取文件内容。</li></ul><h3 id="5-touch"><a href="#5-touch" class="headerlink" title="5.touch"></a>5.touch</h3><ul><li><code>touch</code>:创建新文件或修改文件时间</li></ul><p><code>touch</code>可以创建新文件并不新鲜，但很多人可能不知道它可以修改文件时间，在说修改文件时间之前，我们看看Linux下的文件有哪些时间：</p><ul><li><p>修改时间（modification time, mtime）</p><p>当该文件的<strong>内容数据</strong>变更时，就会更新这个时间，内容数据指的是文件的内容，而不是文件的属性或权限。</p></li><li><p>状态时间（status time, ctime）</p><p>当该文件的<strong>状态（status）</strong>改变时，就会更新这个时间，举例来说，像是权限与属性被更改了都会更新这个时间。</p></li><li><p>读取时间（access time, atime）</p><p>当<strong>该文件的内容被读取</strong>时，就会更新这个读取时间（access），举例来说，我们使用cat去读取file.txt，就会更新该文件的atime。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@izbp1783u2o2usauzn9srez ~]<span class="comment"># date; ll /etc/man_db.conf; ll --time=ctime /etc/man_db.conf; ll --time=atime /etc/man_db.conf </span></span><br><span class="line">2020年 07月 24日 星期五 23:49:14 CST</span><br><span class="line">-rw-r--r--. 1 root root 5171 6月  10 2014 /etc/man_db.conf&lt;== 这是mtime</span><br><span class="line">-rw-r--r--. 1 root root 5171 8月  18 2017 /etc/man_db.conf&lt;== 这是ctime</span><br><span class="line">-rw-r--r--. 1 root root 5171 7月  23 03:48 /etc/man_db.conf&lt;== 这是atime</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">touch [-acdmt] 文件</span><br><span class="line">参数：</span><br><span class="line">-a : 仅修改访问时间。</span><br><span class="line">-c : 仅修改文件的时间，若该文件不存在则不新建文件。</span><br><span class="line">-d : 后面可以接欲修改的日期而不使用目前的日期。</span><br><span class="line">-m : 仅修改 mtime。</span><br><span class="line">-t : 后面可以接欲修改的时间而不用目前的时间，格式为[YYMMDDhhmm]。</span><br></pre></td></tr></table></figure><p>无论如何，<code>touch</code>这个命令最常被使用的情况是：</p><ul><li>建立一个空文件</li><li>将某个文件日期自定义为目前（mtime和atime）</li></ul><h3 id="6-find"><a href="#6-find" class="headerlink" title="6.find"></a>6.find</h3><ul><li><code>find</code>:查找某路径下指定文件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /root（路径） -name 文件名</span><br><span class="line">find /root（路径） -mtime 0 当前目录下查找今天之内有改动的文件  </span><br><span class="line">-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；  </span><br><span class="line">-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；</span><br></pre></td></tr></table></figure><h3 id="7-grep-wc"><a href="#7-grep-wc" class="headerlink" title="7.grep/wc"></a>7.grep/wc</h3><ul><li><code>grep</code>:文本搜索</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：grep 参数 查找条件 文件名（注：是文件名，目录名下查找不行）</span><br><span class="line">主要参数：</span><br><span class="line">－i：不区分大小写(只适用于字母字符。）</span><br><span class="line">－l：查询多文件时只输出包含匹配字符的 文件名。</span><br><span class="line">－n：显示匹配行内容及行号。</span><br></pre></td></tr></table></figure><ul><li><code>wc</code>:统计字数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wc [-clw][--<span class="built_in">help</span>][--version][文件...]</span><br><span class="line">参数：</span><br><span class="line">-c或--bytes或--chars 只显示Bytes数。</span><br><span class="line">-l或--lines 只显示行数。</span><br><span class="line">-w或--words 只显示字数。</span><br><span class="line">--<span class="built_in">help</span> 在线帮助。</span><br><span class="line">--version 显示版本信息。</span><br></pre></td></tr></table></figure><p>在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。使用的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) saladdays@MacBook-Pro _posts % wc learnCpp-static.md </span><br><span class="line">     222     516    9427 learnCpp-static.md</span><br></pre></td></tr></table></figure><p>找出某个文件里关键字出现的次数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 字符串 文件名 | wc -l</span><br></pre></td></tr></table></figure><h3 id="8-ps-top-kill"><a href="#8-ps-top-kill" class="headerlink" title="8.ps/top/kill"></a>8.ps/top/kill</h3><ul><li><p><code>ps</code>:查看进程，显示系统中进程的信息。包括进程ID、控制进程终端、执行时间和命令。</p></li><li><p><code>top</code>:显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等。</p><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p></li><li><p><code>kill</code>:杀死进程。</p></li></ul><h3 id="9-netstat-lsof"><a href="#9-netstat-lsof" class="headerlink" title="9.netstat/lsof"></a>9.netstat/lsof</h3><ul><li><code>netstat</code>:常用于查看路由表，显示各种网络相关信息，如网络连接，路由表，接口状态(Interface Statistics),masquerade连接，多播成员。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">命令参数</span><br><span class="line"></span><br><span class="line">注：netstat命令默认是不显示LISTEN状态的网络连接和LISTEING状态的UNIX域连接，只有使用带-a或者-l参数的命令才能显示出来。</span><br><span class="line"></span><br><span class="line">    -a (all)显示所有状态的连接</span><br><span class="line">    -t (tcp)仅显示tcp相关连接</span><br><span class="line">    -u (udp)仅显示udp相关连接</span><br><span class="line">    -n 拒绝显示别名，能显示数字的全部转化成数字。</span><br><span class="line">    -l 仅列出有在监听状态的连接</span><br><span class="line"></span><br><span class="line">    -p 显示建立相关链接的程序名</span><br><span class="line">    -r 显示路由信息，路由表</span><br><span class="line">    -e 显示扩展信息，例如uid等</span><br><span class="line">    -s 按各个协议进行统计</span><br><span class="line">    -c 每隔一个固定时间，执行该netstat命令。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">常用命令参考</span><br><span class="line"></span><br><span class="line">a、列出所有连接（包括监听和未监听状态）</span><br><span class="line"></span><br><span class="line">    命令：netstat -a；列出所有状态下的连接</span><br><span class="line"></span><br><span class="line">    命令：netstat -at；列出所有状态下的tcp连接</span><br><span class="line"></span><br><span class="line">    命令：netstat -au；列出所有状态下的udp连接 </span><br><span class="line"></span><br><span class="line">    命令：netstat -ax；列出所有状态下的UNINX域连接</span><br><span class="line"></span><br><span class="line">b、列出处于LISTEN状态的连接</span><br><span class="line"></span><br><span class="line">    命令：netstat -l；列出所有处于LISTEN状态的连接</span><br><span class="line"></span><br><span class="line">    命令：netstat -lt；列出所有处于LISTEN状态的tcp连接</span><br><span class="line"></span><br><span class="line">    命令：netstat -lu；列出所有处于LISTEN状态的udp连接</span><br><span class="line"></span><br><span class="line">    命令：netstat-lx；列出所有处于LISTENING状态的UNIX域连接</span><br><span class="line"></span><br><span class="line">c、统计通信协议连接信息</span><br><span class="line"></span><br><span class="line">    命令：netstat -s；统计所有连接的通信协议连接信息</span><br><span class="line"></span><br><span class="line">    命令：netstat -st；统计基于tcp连接的通信协议连接信息</span><br><span class="line"></span><br><span class="line">    命令：netstat -su；统计基于udp连接的通信协议连接信息</span><br><span class="line"></span><br><span class="line">d、输出中显示进程ID和进程名信息（可搭配其他参数使用）</span><br><span class="line"></span><br><span class="line">    命令：netstat -p；列出除LISTEN和LISTENING状态下的连接，包含连接所属进程的进程ID和进程名</span><br><span class="line"></span><br><span class="line">    命令：netstat -tp；列出除LISTEN和LISTENING状态下的tcp连接，包含连接所属进程的进程ID和进程名</span><br><span class="line"></span><br><span class="line">    命令：netstat -up；列出除LISTEN和LISTENING状态下的udp连接，包含连接所属进程的进程ID和进程名</span><br><span class="line"></span><br><span class="line">e、动态输出连接信息</span><br><span class="line"></span><br><span class="line">    命令：netstat -c；每间隔一秒输出当前连接信息</span><br><span class="line"></span><br><span class="line">f、列出特定的连接</span><br><span class="line"></span><br><span class="line">    命令：netstat -ap|grep postgres</span><br></pre></td></tr></table></figure><ul><li><code>lsof</code>:查端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:443 <span class="comment">#显示所有打开443端口的进程</span></span><br><span class="line">netstat -an | grep tcp | grep 80</span><br></pre></td></tr></table></figure><h3 id="10-scp"><a href="#10-scp" class="headerlink" title="10.scp"></a>10.scp</h3><ul><li><code>scp</code>:通过网络在两台主机之间拷贝文件，可以支持Windows。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder <span class="comment">#本地复制到远程，文件未重命名。</span></span><br><span class="line">scp local_file remote_username@remote_ip:remote_file <span class="comment">#本地复制到远程，文件重命名。</span></span><br><span class="line">scp local_file remote_ip:remote_folder <span class="comment">#未指定用户名，执行后需输入用户名和密码，未修改文件名进行移动文件。</span></span><br><span class="line">scp local_file remote_ip:remote_file <span class="comment">#未指定用户名，执行后需输入用户名和密码，修改文件名进行移动文件。</span></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-r 递归拷贝指定的整个文件夹。</span><br></pre></td></tr></table></figure><p>从远程复制到本地，只需要将上述命令的后2个参数调换顺序就可以了。<br> 相比于CP命令，主要就是在source跟dest之前加上remote_username@remote_ip:，通过加的位置的不同区分出到底从远程到本地还是本地到远程。</p><h3 id="11-tar-zip"><a href="#11-tar-zip" class="headerlink" title="11.tar/zip"></a>11.tar/zip</h3><ul><li><code>tar</code>:打包/压缩文件</li><li><code>zip</code>:打包/压缩文件</li></ul><p>详见：</p><p><a href="https://www.cnblogs.com/centos2017/p/7896807.html" target="_blank" rel="noopener">打包 压缩 命令tar zip</a></p><p><a href="https://blog.csdn.net/guo_qiangqiang/article/details/87934655" target="_blank" rel="noopener">Linux中常用的tar解压打包命令语法介绍</a></p><h3 id="12-chmod"><a href="#12-chmod" class="headerlink" title="12.chmod"></a>12.chmod</h3><ul><li><code>chmod</code>:改变文件的权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：chmod [options] mode files </span><br><span class="line">options：-R 可递归遍历子目录，把修改应到目录下所有文件和子目录 </span><br><span class="line">who：u 用户 、 g 组 、o 其他 、a 所有用户 </span><br><span class="line">opcode：+ 增加权限 、 - 删除权限 、= 重新分配权限 </span><br><span class="line">permission： r 读 、w 写 、 x 执行</span><br></pre></td></tr></table></figure><p>我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x file ：给file的属主增加执行权限</span><br><span class="line"></span><br><span class="line">chmod 751 file ：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</span><br><span class="line"></span><br><span class="line">chmod u=rwx,g=rx,o=x file ：上例的另一种形式</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://blog.csdn.net/zlx312/article/details/79398557" target="_blank" rel="noopener">面试常见的Linux命令及问题整理</a></li><li><a href="https://blog.csdn.net/gexiaoyizhimei/article/details/100122368" target="_blank" rel="noopener">Linux文件操作高频使用命令</a></li><li><a href="https://blog.csdn.net/jjwyll/article/details/62091307" target="_blank" rel="noopener">linux命令——ps和netstat</a></li><li><a href="https://blog.csdn.net/wojiaopanpan/article/details/7286430" target="_blank" rel="noopener">Linux如何查看进程、杀死进程、启动进程等常用命令</a></li><li><a href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="noopener">每天一个linux命令（44）：top命令</a></li><li><a href="https://www.jianshu.com/p/552322d2c412" target="_blank" rel="noopener">linux中scp命令的使用</a></li><li><a href="https://www.cnblogs.com/centos2017/p/7896807.html" target="_blank" rel="noopener">打包 压缩 命令tar zip</a></li><li><a href="https://blog.csdn.net/guo_qiangqiang/article/details/87934655" target="_blank" rel="noopener">Linux中常用的tar解压打包命令语法介绍</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态虚函数表详解(多重继承、多继承情况)</title>
      <link href="/2020/07/21/learnCpp-virtual-function/"/>
      <url>/2020/07/21/learnCpp-virtual-function/</url>
      
        <content type="html"><![CDATA[<p><strong>本文转载自<a href="https://blog.csdn.net/qq_36359022/article/details/81870219" target="_blank" rel="noopener">C++多态虚函数表详解(多重继承、多继承情况)</a></strong></p><p>在前面的<a href="https://raoxuntian.github.io/2020/07/20/learnCpp-Polymorphism/">文章</a>中我们已经简单的了解了C++中面向对象的三大特征：封装、继承、多态。封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法——“一个接口，多种方法”。</p><p>C++相对其他面向对象语言来说，之所以灵活、高效。很大程度的占比在于其多态技术和模板技术。</p><p>多态有静态多态和动态多态，其中静态多态是通过重载实现，在编译时就确实；而动态多态则是通过虚函数的机制实现的，在运行期间动态绑定。<strong>C++虚函数表是支撑C++多态的重要技术，它是C++动态绑定技术的核心。</strong></p><a id="more"></a><h3 id="一、多态起手式以及内存分布"><a href="#一、多态起手式以及内存分布" class="headerlink" title="一、多态起手式以及内存分布"></a>一、多态起手式以及内存分布</h3><p>假设有一个基类ClassA，一个继承了该基类的派生类ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。<br>我们在代码中运用多态这个特性时，通常以两种方式起手：<br>(1) ClassA *a = new ClassB();<br>(2) ClassB b; ClassA *a = &b;<br>以上两种方式都是用基类指针去指向一个派生类实例，区别在于第1个用了new关键字而分配在堆上，第2个分配在栈上。</p><img src="/2020/07/21/learnCpp-virtual-function/1.png" class="" title="image"><p>请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。<br>以左图为例，ClassA <em>a是一个栈上的指针。<br>该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向*</em>该类的虚函数表(这里是类ClassB)**的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。</p><img src="/2020/07/21/learnCpp-virtual-function/2.png" class="" title="image"><h3 id="二、类的虚函数表与类实例的虚函数指针"><a href="#二、类的虚函数表与类实例的虚函数指针" class="headerlink" title="二、类的虚函数表与类实例的虚函数指针"></a>二、类的虚函数表与类实例的虚函数指针</h3><p>首先不考虑继承的情况。如果一个类中有虚函数，那么该类就有一个虚函数表。<br>这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表。<br>从第一部分的图中我们也能看到，一个类的实例要么在堆上，要么在栈上。也就是说一个类可以有很多很多个实例。但是！一个类只能有一个虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中。</p><h3 id="三、多态代码及多重继承情况"><a href="#三、多态代码及多重继承情况" class="headerlink" title="三、多态代码及多重继承情况"></a>三、多态代码及多重继承情况</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA::ClassA()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~ClassA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA::~ClassA()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA::func1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA::func2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA::vfunc1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA::vfunc2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> aData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> :</span> <span class="keyword">public</span> ClassA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB::ClassB()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~ClassB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB::~ClassB()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB::func1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassB::vfunc1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> bData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> :</span> <span class="keyword">public</span> ClassB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClassC() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::ClassC()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~ClassC() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::~ClassC()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::func2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::vfunc2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> cData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在第二部分中，我们讨论了在没有继承的情况下，虚函数表的逻辑结构。<br>那么在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。<br>请看上面代码<br>(1) ClassA是基类, 有普通函数: func1() func2() 。虚函数: vfunc1() vfunc2() ~ClassA()<br>(2) ClassB继承ClassA, 有普通函数: func1()。虚函数: vfunc1() ~ClassB()<br>(3) ClassC继承ClassB, 有普通函数: func2()。虚函数: vfunc2() ~ClassB()<br>基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份。</p><img src="/2020/07/21/learnCpp-virtual-function/3.png" class="" title="image"><p>ClassB继承与ClassA，其虚函数表是在ClassA虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在<strong>内容上是一致的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassA *a = <span class="keyword">new</span> ClassB();</span><br><span class="line">a-&gt;func1();                    <span class="comment">// "ClassA::func1()"   隐藏了ClassB的func1()</span></span><br><span class="line">a-&gt;func2();                    <span class="comment">// "ClassA::func2()"</span></span><br><span class="line">a-&gt;vfunc1();                   <span class="comment">// "ClassB::vfunc1()"  重写了ClassA的vfunc1()</span></span><br><span class="line">a-&gt;vfunc2();                   <span class="comment">// "ClassA::vfunc2()"</span></span><br></pre></td></tr></table></figure><p>这个结果不难想象，看上图，ClassA类型的指针a能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同<br>这个结果已经说明了C++的隐藏、重写(覆盖)特性。</p><p>同理，也就不难推导出ClassC的逻辑结构图了<br>类的继承情况是: ClassC继承ClassB，ClassB继承ClassA<br>这是一个多次单继承的情况。(多重继承)</p><img src="/2020/07/21/learnCpp-virtual-function/4.png" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassA* a = <span class="keyword">new</span> ClassC;</span><br><span class="line">a-&gt;func1();          <span class="comment">// "ClassA::func1()"   隐藏ClassB::func1()               </span></span><br><span class="line">a-&gt;func2();          <span class="comment">// "ClassA::func2()"隐藏ClassC::func2()</span></span><br><span class="line">a-&gt;vfunc1();     <span class="comment">// "ClassB::vfunc1()"ClassB把ClassA::vfunc1()覆盖了</span></span><br><span class="line">a-&gt;vfunc2();     <span class="comment">// "ClassC::vfunc2()"ClassC把ClassA::vfunc2()覆盖了</span></span><br><span class="line"></span><br><span class="line">ClassB* b = <span class="keyword">new</span> ClassC;</span><br><span class="line">b-&gt;func1();<span class="comment">// "ClassB::func1()"有权限操作时，子类优先</span></span><br><span class="line">b-&gt;func2();<span class="comment">// "ClassA::func2()"隐藏ClassC::func2()</span></span><br><span class="line">b-&gt;vfunc1();<span class="comment">// "ClassB::vfunc1()"ClassB把ClassA::vfunc1()覆盖了</span></span><br><span class="line">b-&gt;vfunc2();<span class="comment">// "ClassB::vfunc2()"ClassC把ClassA::vfunc2()覆盖了</span></span><br></pre></td></tr></table></figure><h3 id="四、多继承下的虚函数表-同时继承多个基类"><a href="#四、多继承下的虚函数表-同时继承多个基类" class="headerlink" title="四、多继承下的虚函数表 (同时继承多个基类)"></a>四、多继承下的虚函数表 (同时继承多个基类)</h3><p>多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClassA1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA1::ClassA1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~ClassA1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA1::~ClassA1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA1::func1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA1::vfunc1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA1::vfunc2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a1Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClassA2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA2::ClassA2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~ClassA2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA2::~ClassA2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA2::func1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA2::vfunc1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA2::vfunc2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc4</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassA2::vfunc4()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a2Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> :</span> <span class="keyword">public</span> ClassA1, <span class="keyword">public</span> ClassA2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClassC() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::ClassC()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~ClassC() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::~ClassC()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::func1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::vfunc1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::vfunc2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"ClassC::vfunc3()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ClassA1是第一个基类，拥有普通函数func1()，虚函数vfunc1() vfunc2()。<br>ClassA2是第二个基类，拥有普通函数func1()，虚函数vfunc1() vfunc2()，vfunc4()。<br>ClassC依次继承ClassA1、ClassA2。普通函数func1(),虚函数vfunc1() vfunc2() vfunc3()。</p><img src="/2020/07/21/learnCpp-virtual-function/5.png" class="" title="image"><p>在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。<br>如图，虚函数表指针01指向的虚函数表是以ClassA1的虚函数表为基础的，子类的ClassC::vfunc1(),和vfunc2()的函数指针覆盖了虚函数表01中的虚函数指针01的位置、02位置。当子类有多出来的虚函数时，添加在第一个虚函数表中。<br>当有多个虚函数表时，虚函数表的结果是0代表没有下一个虚函数表。” * “号位置在不同操作系统中实现不同，代表有下一个虚函数表。<br>注意：<br>1.子类虚函数会覆盖每一个父类的每一个同名虚函数。<br>2.父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。<br>3.父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用。</p><p>最后给出代码和结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassA1 *a1 = <span class="keyword">new</span> ClassC;</span><br><span class="line">a1-&gt;func1();               <span class="comment">// "ClassA1::func1()"    隐藏子类同名函数</span></span><br><span class="line">a1-&gt;vfunc1();              <span class="comment">// "ClassC::vfunc1()"    覆盖父类ClassA1虚函数</span></span><br><span class="line">a1-&gt;vfunc2();              <span class="comment">// "ClassC::vfunc2()"    覆盖父类ClassA1虚函数</span></span><br><span class="line">没有a1-&gt;vfunc3()，父类没有这个虚函数</span><br><span class="line"></span><br><span class="line">ClassA2 *a2 = <span class="keyword">new</span> ClassC;</span><br><span class="line">a2-&gt;func1();               <span class="comment">// "ClassA2::func1()"    隐藏子类同名函数</span></span><br><span class="line">a2-&gt;vfunc1();              <span class="comment">// "ClassC::vfunc1()"    覆盖父类ClassA2虚函数</span></span><br><span class="line">a2-&gt;vfunc2();              <span class="comment">// "ClassC::vfunc2()"    覆盖父类ClassA2虚函数</span></span><br><span class="line">a2-&gt;vfunc4();              <span class="comment">// "ClassA2::vfunc4()"   未被子类重写的父类虚函数</span></span><br><span class="line"></span><br><span class="line">ClassC *c = <span class="keyword">new</span> ClassC;</span><br><span class="line">c-&gt;func1();                <span class="comment">// "ClassC::func1()"</span></span><br><span class="line">c-&gt;vfunc1();               <span class="comment">// "ClassC::vfunc1()"</span></span><br><span class="line">c-&gt;vfunc2();               <span class="comment">// "ClassC::vfunc2()"</span></span><br><span class="line">c-&gt;vfunc3();               <span class="comment">// "ClassC::vfunc3()"</span></span><br><span class="line">c-&gt;vfunc4();               <span class="comment">// "ClassA2::func4()"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多态 </tag>
            
            <tag> 虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C++的封装、继承、多态</title>
      <link href="/2020/07/20/learnCpp-Polymorphism/"/>
      <url>/2020/07/20/learnCpp-Polymorphism/</url>
      
        <content type="html"><![CDATA[<p>面向对象的三个基本特征：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。其中，<strong>封装</strong>可以隐藏实现细节，使得代码模块化；<strong>继承</strong>可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而<strong>多态</strong>则是为了实现另一个目的——接口重用！</p><a id="more"></a><h4 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h4><p>封装可以隐藏实现细节，使得代码模块化；封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。在面向对象编程上可理解为：<strong>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</strong></p><p>封装是指保护类的成员不被随意访问的能力。我们在C++中使用的class类就是常用的一种封装思想。分离类的实现与接口，从而隐藏了类的实现细节。在C++语言中，通过把实现部分设为private完成封装的任务。</p><p>封装的优点：</p><ol><li>确保用户代码不会无意间破坏封装对象的状态；</li><li>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</li></ol><p>一旦把数据成员定义成private的，类的作者就可以比较自由地修改数据了。当时实现的部分发生改变时，只需要检查类的代码本身以确认这次改变有什么影响；换句话说，只要类的接口不变，用户代码就无须改变。如果数据是public的，则所有使用了原来数据成员的代码都可能失效，这时我们必须定位并重写所有依赖于老版本实现的代码，之后才能重新使用该程序。</p><p>把数据成员的访问权限设为private还有另一个好处，这么做能防止由于用户的原因造成数据被破坏。如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷：因为只有实现部分的代码可能产生这样的错误。因此，错误的搜索限制在有限范围内将能极大地简化更改问题及修正程序等工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> money;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">person():height(<span class="number">180</span>), weight(<span class="number">100</span>), name(<span class="string">"Jack"</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建默认人物……\n"</span>;&#125;;</span><br><span class="line">person(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">const</span> <span class="built_in">string</span> s):height(a), weight(b), name(s)&#123;&#125;;</span><br><span class="line">~person()&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money+=x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">costMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money-=x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;<span class="keyword">if</span> (money&gt;<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">"是有钱人！\n"</span>; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">"是穷逼！\n"</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">remainMoney</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> money;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.height &lt;&lt; <span class="string">" "</span> &lt;&lt; a.weight &lt;&lt; <span class="string">" "</span> &lt;&lt; a.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a.costMoney(<span class="number">50</span>);</span><br><span class="line">a.judge();</span><br><span class="line">person *b = <span class="keyword">new</span> person(<span class="number">178</span>, <span class="number">160</span>, <span class="string">"Tom"</span>);</span><br><span class="line">b-&gt;getMoney(<span class="number">100</span>);</span><br><span class="line">b-&gt;judge();</span><br><span class="line"><span class="comment">//a.money();//error: 'money' is a private member of 'person'</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.name &lt;&lt; <span class="string">"还有"</span> &lt;&lt; a.remainMoney() &lt;&lt; <span class="string">"元。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b-&gt;name &lt;&lt; <span class="string">"还有"</span> &lt;&lt; b-&gt;remainMoney() &lt;&lt; <span class="string">"元。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h4><p>面向对象程序设计的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似的关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。</p><p>通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类(base class)，也称为父类，其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类(derived class)，也称为子类。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p><p>在子类继承父类的过程中，构造函数和析构函数比较特殊，他们是不能被子类继承的。</p><p><strong>构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么。</strong></p><p>所以，<strong>在整个层次中的所有的构造函数和析构函数都必须被调用，也就是说，构造函数和析构函数不能被继承。</strong></p><p>子类的构造函数会显示的调用父类的构造函数或隐式的调用父类的默认的构造函数进行父类部分的初始化。</p><p>析构函数也一样。它们都是每个类都有的东西，如果能被继承，那就没有办法初始化了。</p><p>此外，在创建子类对象时，为了初始化从父类继承来的数据成员，系统需要调用其父类的构造方法。</p><p>如果没有显式的构造函数，编译器会给一个默认的构造函数，并且该默认的构造函数仅仅在没有显式地声明构造函数情况下创建。</p><p>构造原则如下：</p><ol><li>如果子类没有定义构造方法，则调用父类的无参数的构造方法。</li><li>如果子类定义了构造方法，不论是无参数还是带参数，在创建子类的对象的时候,首先执行父类无参数的构造方法，然后执行自己的构造方法。</li><li>在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数，则会调用父类的默认无参构造函数。</li><li>在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类自己提供了无参构造函数，则会调用父类自己的无参构造函数。</li><li>在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类只定义了自己的有参构造函数，则会出错（如果父类只有有参数的构造方法，则子类必须显示调用此带参构造方法）。</li><li>如果子类调用父类带参数的构造方法，需要用初始化父类成员对象的方式，</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> money;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">person():height(<span class="number">180</span>), weight(<span class="number">100</span>), name(<span class="string">"Jack"</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"person()\n"</span>;&#125;;</span><br><span class="line">person(<span class="keyword">const</span> <span class="built_in">string</span> s):height(<span class="number">180</span>), weight(<span class="number">100</span>), name(s) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"person(string name)\n"</span>;&#125;;</span><br><span class="line">person(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">const</span> <span class="built_in">string</span> s):height(a), weight(b), name(s)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"person(int height, int weight, string name)\n"</span>;&#125;;</span><br><span class="line">~person()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~person()\n"</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money+=x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">costMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money-=x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;<span class="keyword">if</span> (money&gt;<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">"是有钱人！\n"</span>; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">"是穷逼！\n"</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">remainMoney</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> money;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testSex</span>:</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">bool</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; height &lt;&lt; <span class="string">" "</span> &lt;&lt; weight &lt;&lt; <span class="string">" "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span>:</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">bool</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">boy():sex(<span class="literal">true</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"boy()\n"</span>;&#125;;</span><br><span class="line">boy(<span class="keyword">const</span> <span class="built_in">string</span> s):sex(<span class="literal">true</span>), person(s) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"boy(string name)\n"</span>;&#125;;</span><br><span class="line">boy(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">const</span> <span class="built_in">string</span> s):sex(<span class="literal">true</span>), person(a, b, s) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"boy(int height, int weight, string name)\n"</span>;&#125;;</span><br><span class="line">~boy()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~boy()\n"</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span></span>&#123;<span class="built_in">string</span> sexx; sexx=sex?<span class="string">"Boy"</span>:<span class="string">"Girl"</span>; <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" is a "</span> &lt;&lt; sexx &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span>:</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">bool</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">girl():sex(<span class="literal">false</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"girl()\n"</span>;&#125;;</span><br><span class="line">girl(<span class="keyword">const</span> <span class="built_in">string</span> s):sex(<span class="literal">false</span>), person(s) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"girl(string name)\n"</span>;&#125;;</span><br><span class="line">girl(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="built_in">string</span> s):sex(<span class="literal">false</span>), person(a, b, s)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"girl(int height, int weight, string name)\n"</span>;&#125;;</span><br><span class="line">~girl()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~girl()\n"</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span></span>&#123;<span class="built_in">string</span> sexx; sexx=sex?<span class="string">"Boy"</span>:<span class="string">"Girl"</span>; <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" is a "</span> &lt;&lt; sexx &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">boy <span class="title">c</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>, <span class="string">"Milky"</span>)</span></span>;</span><br><span class="line"><span class="function">girl <span class="title">d</span><span class="params">(<span class="string">"Rose"</span>)</span></span>;</span><br><span class="line">boy e;</span><br><span class="line">c.getSex();</span><br><span class="line">d.getSex();</span><br><span class="line">testSex test;</span><br><span class="line">test.show();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="keyword">int</span> height, <span class="keyword">int</span> weight, <span class="built_in">string</span> name)</span><br><span class="line">boy(<span class="keyword">int</span> height, <span class="keyword">int</span> weight, <span class="built_in">string</span> name)</span><br><span class="line">person(<span class="built_in">string</span> name)</span><br><span class="line">girl(<span class="built_in">string</span> name)</span><br><span class="line">person()</span><br><span class="line">boy()</span><br><span class="line">Milky is a Boy</span><br><span class="line">Rose is a Girl</span><br><span class="line">person()</span><br><span class="line"><span class="number">180</span> <span class="number">100</span> Jack</span><br><span class="line">~person()</span><br><span class="line">~boy()</span><br><span class="line">~person()</span><br><span class="line">~girl()</span><br><span class="line">~person()</span><br><span class="line">~boy()</span><br><span class="line">~person()</span><br><span class="line">[Finished in <span class="number">1.0</span>s]</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们还可以用new的方法来定义一个对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//girl *f = new person();// error!</span></span><br><span class="line">person *f = <span class="keyword">new</span> girl();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f-&gt;remainMoney() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> f;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person()</span><br><span class="line">girl()</span><br><span class="line"><span class="number">0</span></span><br><span class="line">~person()</span><br><span class="line">[Finished in <span class="number">2.9</span>s]</span><br></pre></td></tr></table></figure><p>我们可以看到，因为在子类对象中含有与其父类对应的组成部分，所以我们能把子类的对象当成父类对象来使用，而且我们也能将<strong>父类的指针或引用绑定到子类的对象中的父类部分上</strong>。</p><p>这种转换通常称为<strong>派生类到基类</strong>(derived-to-base)的类型转换。和其他类型转换一样，编译器会隐式地执行派生类（子类）到基类（父类）的转换。</p><p>可以将父类的指针或引用绑定到子类对象上有一层极为重要的含义：当使用父类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是父类的对象，也可能是子类的对象。</p><p>反之，不存在从基类（父类）向派生类（子类）的隐式类型转换……</p><h4 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h4><p>多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。多态(polymorphism)，字面意思多种形状。</p><p>C++多态性是通过<strong>虚函数</strong>来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为<strong>覆盖</strong>(override)，或者称为<strong>重写</strong>。（这里我觉得要补充，重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）而<strong>重载</strong>(overload)则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。</p><p>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p><p>那么多态的作用是什么呢，封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p><p>最常见的用法就是<strong>声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法</strong>。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种方法的目的了。</p><p>让我们再次修改一下之前的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">double</span> money;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">  person(<span class="keyword">const</span> person &amp;p)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"person(person p)\n"</span>;&#125;;</span><br><span class="line">person():height(<span class="number">180</span>), weight(<span class="number">100</span>), name(<span class="string">"Jack"</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"person()\n"</span>;&#125;;</span><br><span class="line">person(<span class="keyword">const</span> <span class="built_in">string</span> s):height(<span class="number">180</span>), weight(<span class="number">100</span>), name(s) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"person(string name)\n"</span>;&#125;;</span><br><span class="line">person(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">const</span> <span class="built_in">string</span> s):height(a), weight(b), name(s)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"person(int height, int weight, string name)\n"</span>;&#125;;</span><br><span class="line"><span class="keyword">virtual</span> ~person()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~person()\n"</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money+=x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">costMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money-=x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">slogan</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a person."</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">slogan</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; s &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;<span class="keyword">if</span> (money&gt;<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">"是有钱人！\n"</span>; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">"是穷逼！\n"</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">remainMoney</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> money;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testSex</span>:</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">bool</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; height &lt;&lt; <span class="string">" "</span> &lt;&lt; weight &lt;&lt; <span class="string">" "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span>:</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">bool</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">boy():sex(<span class="literal">true</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"boy()\n"</span>;&#125;;</span><br><span class="line">boy(<span class="keyword">const</span> <span class="built_in">string</span> s):sex(<span class="literal">true</span>), person(s) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"boy(string name)\n"</span>;&#125;;</span><br><span class="line">boy(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">const</span> <span class="built_in">string</span> s):sex(<span class="literal">true</span>), person(a, b, s) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"boy(int height, int weight, string name)\n"</span>;&#125;;</span><br><span class="line">~boy()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~boy()\n"</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span></span>&#123;<span class="built_in">string</span> sexx; sexx=sex?<span class="string">"Boy"</span>:<span class="string">"Girl"</span>; <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" is a "</span> &lt;&lt; sexx &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money+=x*<span class="number">2</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">costMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money-=x*<span class="number">0.5</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slogan</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a boy."</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span>:</span> <span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">bool</span> sex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">girl():sex(<span class="literal">false</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"girl()\n"</span>;&#125;;</span><br><span class="line">girl(<span class="keyword">const</span> <span class="built_in">string</span> s):sex(<span class="literal">false</span>), person(s) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"girl(string name)\n"</span>;&#125;;</span><br><span class="line">girl(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="built_in">string</span> s):sex(<span class="literal">false</span>), person(a, b, s)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"girl(int height, int weight, string name)\n"</span>;&#125;;</span><br><span class="line">~girl()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"~girl()\n"</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSex</span><span class="params">()</span></span>&#123;<span class="built_in">string</span> sexx; sexx=sex?<span class="string">"Boy"</span>:<span class="string">"Girl"</span>; <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" is a "</span> &lt;&lt; sexx &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money+=x*<span class="number">1.5</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">costMoney</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;money-=x*<span class="number">3</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slogan</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a girl."</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person g;</span><br><span class="line">boy h;</span><br><span class="line">girl i;</span><br><span class="line">g.slogan();</span><br><span class="line">g.slogan(<span class="string">"doctor"</span>);</span><br><span class="line">h.slogan();</span><br><span class="line">i.slogan();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><p>所谓的重载(overload)就是，两个函数名相同，但是参数列表不同（个数、类型），返回值类型也可能不同。</p><p>比如在父类person中我们就对slogan()函数进行了重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">slogan</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a person."</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">slogan</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; s &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br></pre></td></tr></table></figure><p>所谓的重写(override)，也就是覆盖，子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写。</p><p>上面的代码输出结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">person()</span><br><span class="line">person()</span><br><span class="line">boy()</span><br><span class="line">person()</span><br><span class="line">girl()</span><br><span class="line">I am a person.</span><br><span class="line">I am a doctor.</span><br><span class="line">I am a boy.</span><br><span class="line">I am a girl.</span><br><span class="line">~girl()</span><br><span class="line">~person()</span><br><span class="line">~boy()</span><br><span class="line">~person()</span><br><span class="line">~person()</span><br><span class="line">[Finished in <span class="number">0.9</span>s]</span><br></pre></td></tr></table></figure><p>我们对子类中的slogan()函数进行了重写，重新定义了父类中的虚函数，方法是将父类中的slogan()添加虚函数关键词virtual。</p><p>除此之外，还对getMoney()和costMoney()进行了重写，这两个函数涉及到person中的private成员变量money，<strong>子类无法访问父类的private成员</strong>，因此只有把money改为<strong>protected</strong>成员变量。</p><p>我们再做个试验，我们尝试着将子类赋值拷贝给父类、父类的指针或引用绑定到子类对象，看看会有什么结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// girl i;</span></span><br><span class="line">person j = i;</span><br><span class="line">person &amp;j_ref = i;</span><br><span class="line">person *j_p = &amp;i;</span><br><span class="line">j.slogan();</span><br><span class="line">j_ref.slogan();</span><br><span class="line">j_p-&gt;slogan();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">I am a person.</span></span><br><span class="line"><span class="comment">I am a girl.</span></span><br><span class="line"><span class="comment">I am a girl.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>person j = i;</code>将子类对象i赋值拷贝给父类对象j，i和j是两个独立的对象，他们的地址不同，i是girl，j是person，所以j.slogan()是执行person类的slogan();</p><p><code>person &amp;j_ref = i;</code>和<code>person *j_p = &amp;i;</code>则是用父类的引用或指针绑定到一个子类的对象或地址，引用和指针虽然是父类，但绑定的是子类的对象啊！</p><p>当我们使用父类的引用或指针调用子类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个父类的对象，也可能是一个子类的对象。如果该函数时虚函数，则直到运行时才会决定到底执行哪个版本，<strong>判断的依据是引用或指针所绑定的对象的真实类型</strong>。</p><p>总结一下：</p><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在<strong>编译</strong>的时候就已经确定；动态多态是用虚函数机制实现的，在<strong>运行</strong>期间动态绑定。</p><p>举个例子：一个父类类型的指针指向一个子类对象的时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键词的函数，在子类中重写的时候不需要加virtual也是虚函数。</p><p>关于虚函数更详细的原理，请听下回分解。</p><h4 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h4><ul><li>C++ Primer 5th</li><li><a href="https://blog.csdn.net/ruyue_ruyue/article/details/8211809" target="_blank" rel="noopener">C++封装继承多态总结</a></li><li><a href="https://blog.csdn.net/hemmingway/article/details/7853713" target="_blank" rel="noopener">在C++中子类继承和调用父类的构造函数方法</a></li><li><a href="https://www.cnblogs.com/zzdbullet/p/10470681.html" target="_blank" rel="noopener">构造函数与析构函数不能被继承</a></li><li><a href="https://blog.csdn.net/Hackbuteer1/article/details/7475622" target="_blank" rel="noopener">浅谈C++多态性</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> interview </tag>
            
            <tag> 多态 </tag>
            
            <tag> 虚函数 </tag>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++中的内存对齐</title>
      <link href="/2020/07/03/memory-alignment/"/>
      <url>/2020/07/03/memory-alignment/</url>
      
        <content type="html"><![CDATA[<p>内存对齐这个东西我一开始也是不知道的，后来又一次面试被问到了，然后张总跟我随口普及了一下，其实还是蛮简单的，有一点点C的基础估计五分钟就能学会内存对齐的规则了。但如果你想刨根问底，为什么我们现有的计算机要内存对齐，里面的学问还是蛮深的，涉及到了处理器、寄存器这些很核心的内存硬件。</p><a id="more"></a><h3 id="一-引子"><a href="#一-引子" class="headerlink" title="一.引子"></a>一.引子</h3><p>我们知道，任何一个数据结构在计算机内存当中要占据一定的字节(byte)数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"type: \t\t"</span> &lt;&lt; <span class="string">"************size**************"</span>&lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"bool: \t\t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"char: \t\t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"signed char: \t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned char: \t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wchar_t: \t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"short: \t\t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(short) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"int: \t\t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned: \t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"long: \t\t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned long: \t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"double: \t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"long double: \t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"float: \t\t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size_t: \t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"string: \t"</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">string</span>) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"type: \t\t"</span> &lt;&lt; <span class="string">"************size**************"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type: ************size**************</span><br><span class="line"><span class="keyword">bool</span>: 所占字节数：<span class="number">1</span></span><br><span class="line"><span class="keyword">char</span>: 所占字节数：<span class="number">1</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span>: 所占字节数：<span class="number">1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>: 所占字节数：<span class="number">1</span></span><br><span class="line"><span class="keyword">wchar_t</span>: 所占字节数：<span class="number">4</span></span><br><span class="line">short: 所占字节数：<span class="number">2</span></span><br><span class="line"><span class="keyword">int</span>: 所占字节数：<span class="number">4</span></span><br><span class="line"><span class="keyword">unsigned</span>: 所占字节数：<span class="number">4</span></span><br><span class="line"><span class="keyword">long</span>: 所占字节数：<span class="number">8</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>: 所占字节数：<span class="number">8</span></span><br><span class="line"><span class="keyword">double</span>: 所占字节数：<span class="number">8</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span>: 所占字节数：<span class="number">16</span></span><br><span class="line"><span class="keyword">float</span>: 所占字节数：<span class="number">4</span></span><br><span class="line"><span class="keyword">size_t</span>: 所占字节数：<span class="number">8</span></span><br><span class="line"><span class="built_in">string</span>: 所占字节数：<span class="number">24</span></span><br><span class="line">type: ************size**************</span><br><span class="line">[Finished in <span class="number">0.9</span>s]</span><br></pre></td></tr></table></figure><p>那我们来写一个class或struct</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">short s;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那一个A的对象的大小是多少呢？</p><p>1+2+4+5+4=16？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br></pre></td></tr></table></figure><p>打印的结果是20.</p><p>多做几个实验，你会不会感到奇怪，sizeof的结果往往都比你声明的变量总长度要大，这是怎么回事呢？</p><h3 id="二-内存（字节）对齐"><a href="#二-内存（字节）对齐" class="headerlink" title="二.内存（字节）对齐"></a>二.内存（字节）对齐</h3><p>网上随手一搜搜到的三个内存对齐的原则：</p><ol><li>结构体的总大小，必须要是其内部最大成员的整数倍，不足的要补齐。</li><li>结构体或联合的数据成员，第一个数据成员是要放在offset == 0的地方，如果遇上子成员，要根据子成员的类型存放在对应的整数倍的地址上。</li><li>如果结构体作为成员，则要找到这个结构体中的最大元素，然后从这个最大成员的整数倍地址开始存储。</li></ol><p>对照这三个原则，我们再来看看之前的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">// [0]--&gt;[1] 补齐1个字节</span></span><br><span class="line">short s;<span class="comment">// [2]...[3]</span></span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">// [4]...[7]</span></span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">5</span>];<span class="comment">// [8]...[12]--&gt;[15] 补齐3个字节 (ch占8个字节 8是4的整数倍)</span></span><br><span class="line"><span class="keyword">float</span> f;<span class="comment">// [16]...[19]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>A的内部最大成员是int和float的4字节，所以内部成员在内存对齐的时候遵循4k原则，尽可能从4的整数倍的地址开始存放数据。我们再来看一个复杂点的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">A a;<span class="comment">// [0]...[19]</span></span><br><span class="line">short s;<span class="comment">// [20]...[21]</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">// [22]--&gt;[23]</span></span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">// [24]...[27]--&gt;[31]</span></span><br><span class="line"><span class="keyword">double</span> d;<span class="comment">// [32]...[39]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>B当中有A，也多了一个8字节的double类型，那么根据原则三，B中最大成员是8字节的double（注意不是20字节的A！），所有每个内部成员在内存对齐的时候遵循8k原则，尽可能才能够8的整数倍的地址开始存放数据。</p><p>稍微算一下，就可以得到sizeof(B)是40字节。</p><p>讲到这里相信很多人已经弄清楚了内存字节对齐是个什么回事了，但我想接着这个<code>class B</code>再分享两点</p><ul><li>假如我把B里的<code>char c</code>换个位置，移到最后会发生什么呢？读者可以花上一分钟时间自行计算一下此时的B的大小。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">A a;<span class="comment">// [0]...[19]</span></span><br><span class="line">short s;<span class="comment">// [20]...[21]</span></span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">// [24]...[27]--&gt;[31]</span></span><br><span class="line"><span class="keyword">double</span> d;<span class="comment">// [32]...[39]</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">// [40]...[47]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没错，你会发现我只是调换了一下位置，<code>sizeof(B)</code>就从40–&gt;48了！</p><p>虽然我还没有接触过正式的C++工程开发项目，但我能感觉，在正式的项目中一定要考虑内存对齐的原则按顺序定义成员数据类型，稍微有顺序地定义成员数据类型可以提高机器内部的存储效率，积少成多，还是得注意细节问题。</p><ul><li>假如我把B里的<code>double d</code>换成float类型，会发生什么改变呢？再请读者花上一分钟时间自行计算一下此时的B的大小。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">A a;<span class="comment">// [0]...[19]</span></span><br><span class="line">short s;<span class="comment">// [20]...[21]</span></span><br><span class="line"><span class="keyword">char</span> c;<span class="comment">// [22]--&gt;[23]</span></span><br><span class="line"><span class="keyword">int</span> i;<span class="comment">// [24]...[27]</span></span><br><span class="line"><span class="keyword">float</span> d;<span class="comment">// [28]...[31]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很好，如果你计算出来的结果是32说明这一块你应该已经基本掌握了。当我把double–&gt;float，此时B的最大成员大小只有4字节，所以我们只需要遵循4k原则去对齐，从double–&gt;float少了4个字节，但整个B少了8个字节。从这一点我又想到在定义成员变量的数据类型的时候，考虑到实际内存大小，我们不能盲目地想着用long、double这些类型一劳永逸，应该根据实际情况去选择适合实际情况的数据类型，在时间和空间中找到权衡。</p><h3 id="三-pragma-pack"><a href="#三-pragma-pack" class="headerlink" title="三.#pragma pack()"></a>三.#pragma pack()</h3><p>假如我们不希望机器内存对齐，有办法吗？</p><p>当然有。<code>#pragma pack()</code></p><p>该预处理指令用来改变对齐参数。在缺省情况下，C编译器为每一个变量或数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对齐参数：</p><ul><li>使用伪指令#pragma pack (n)，C编译器将按照n字节对齐。</li><li>使用伪指令#pragma pack ()，取消自定义字节对齐方式。</li></ul><p>也可以写成：</p><p><code>#pragma pack(push,n)</code></p><p><code>#pragma pack(pop)</code></p><p><code>#pragma pack (n)</code>表示每个成员的对齐单元<strong>不大于</strong>n（n为2的整数次幂）。这里规定的是上界，只影响对齐单元大于n的成员，对于对齐字节不大于n的成员没有影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">short s;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">A a;</span><br><span class="line">short s;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">float</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">short s;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">C c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(a));<span class="comment">// 16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(b));<span class="comment">// 27</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(c));<span class="comment">// 15</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-参考文章"><a href="#四-参考文章" class="headerlink" title="四.参考文章"></a>四.参考文章</h3><ul><li><a href="https://www.jianshu.com/p/9441a78062f3" target="_blank" rel="noopener">内存对齐三个原则</a></li><li><a href="https://blog.csdn.net/hairetz/article/details/4084088" target="_blank" rel="noopener">５分钟搞定内存字节对齐</a></li><li><a href="https://blog.csdn.net/chy19911123/article/details/48894579" target="_blank" rel="noopener">C/C++ 内存对齐原则及作用</a></li><li><a href="https://blog.csdn.net/lgouc/article/details/8235471" target="_blank" rel="noopener">为什么要内存对齐 Data alignment: Straighten up and fly right</a></li><li><a href="https://blog.csdn.net/lgouc/article/details/8235616" target="_blank" rel="noopener">关于内存对齐</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++程序内存的各种变量存储区域和各个区域详解</title>
      <link href="/2020/07/02/variable-storage-areas-in-cpp/"/>
      <url>/2020/07/02/variable-storage-areas-in-cpp/</url>
      
        <content type="html"><![CDATA[<p>C/C++程序内存中各种变量的存储区域划分是C++面试时常问的一个问题，别的公司我不太清楚，至少某讯是挺爱问的……甚至面试官在面试的时候跟我说，“好的，你能说出这个三个区域就可以了，后面就不做要求了……”。之前看过<a href="https://blog.csdn.net/jirryzhang/article/details/79518408" target="_blank" rel="noopener">一篇博客</a>写的很详细，每次面试前临时背一背，现在不想背了，自己过一遍，画一画图加强理解吧。</p><a id="more"></a><h3 id="一-预备知识—程序的内存分配"><a href="#一-预备知识—程序的内存分配" class="headerlink" title="一.预备知识—程序的内存分配"></a>一.预备知识—程序的内存分配</h3><p>一个由C/C++编译的程序占用的内存分为以下几个部分</p><ol><li><p>栈区（stack）— 程序运行时由编译器自动分配，存放函数的参数值，局部变量的值等。</p><p>其操作方式类似于数据结构中的栈。</p></li><li><p>堆区（heap） — 在内存开辟另一块存储区域。</p><p>一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。</p><p>注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p></li><li><p>全局区（静态区）（static）—编译器编译时即分配内存。   </p><p>全局变量和静态变量的存储是放在一块的，</p><p><strong>初始化</strong>的全局变量和静态变量在一块区域，</p><p><strong>未初始化</strong>的全局变量和未初始化的静态变量在相邻的另一块区域。 </p><p>（在C++中，由于全局变量和静态变量编译器会给这些变量自动初始化赋值，所以没有区分了）</p><p>程序结束后由系统释放。</p></li><li><p>文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放。</p></li><li><p>程序代码区—存放函数体的二进制代码。</p></li></ol><p>注意：静态局部变量和静态全局变量</p><p>属于静态存储方式的量不一定就是静态变量。 </p><p>例如：全局变量虽属于静态存储方式，但不一定是静态变量，</p><p>必须由 static加以定义后才能成为静态外部变量，或称静态全局变量。</p><p>把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。<br>把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</p><h3 id="二-动-amp-静"><a href="#二-动-amp-静" class="headerlink" title="二.动&amp;静"></a>二.动&amp;静</h3><p>一个程序被加载到内存中，这块内存首先就存在两种<strong>属性</strong>：静态分配内存和动态分配内存。<br>静态分配内存：是在程序编译和链接时就确定好的内存。<br>动态分配内存：是在程序加载、调入、执行的时候分配/回收的内存。</p><p><strong>Text &amp; Data &amp; Bss</strong></p><ul><li><p>.text： 也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)。<br>这块内存是共享的,当有多个相同进程(Process)存在时，共用同一个text段。</p></li><li><p>.data： 也有的地方叫GVAR(global value)，用来存放程序中已经初始化的非零全局变量。静态分配。</p><p>​    data又可分为读写（RW）区域和只读（RO）区域。<br>​    -&gt; RO段保存常量所以也被称为.constdata<br>​    -&gt; RW段则是普通非常全局变量，静态变量就在其中</p></li><li><p>.bss： 存放程序中为初始化的和零值全局变量。静态分配，在程序开始时通常会被清零。</p></li></ul><p>text和data段都在可执行文件中，由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。<br>这三段内存就组成了我们编写的程序的本体，但是一个程序运行起来，还需要更多的数据和数据间的交互，否则这个程序就是死的，无用的。所以我们还需要为更多的数据和数据交互提供一块内存——堆栈。</p><p><strong>堆栈（Heap&amp; Stack）</strong><br>堆和栈都是动态分配内存，两者空间大小都是可变的。</p><ul><li>Stack： 栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。</li></ul><ul><li>Heap： 堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。<br>每个线程都会有自己的栈，但是堆空间是共用的。</li></ul><h3 id="三-代码"><a href="#三-代码" class="headerlink" title="三.代码"></a>三.代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_i = <span class="number">0</span>;<span class="comment">// global_i在全局（初始化）区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* global_p;<span class="comment">// global_p在全局（未初始化）区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;global_i = %p\n"</span>, &amp;global_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;global_p = %p\n"</span>, &amp;global_p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"global_p = %p\n"</span>, global_p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_i = <span class="number">1</span>;<span class="comment">// 全局静态区</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;<span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> const_i = <span class="number">3</span>;<span class="comment">// 栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> p1[] = <span class="string">"HUST"</span>;<span class="comment">// p1在栈，"HUST"在常量区</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p2 = <span class="string">"Computer Science"</span>;<span class="comment">// p2在栈，"Computer Science"在常量区</span></span><br><span class="line">global_p = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 指针变量global_p依然在全局区，但在堆上开辟了10个char长度的空间，global_p的值是堆上开辟空间的首地址</span></span><br><span class="line"><span class="keyword">char</span>* p3 = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 这行代码在Heap中开辟了20个char长度的空间，同时在Stack上压入了p3，</span></span><br><span class="line"><span class="comment">// 指针变量p3存在于栈上，其值为刚刚在堆上开辟的空间的首地址。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;static_i = %p\n"</span>, &amp;static_i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;i = %p\n"</span>, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;const_i = %p\n"</span>, &amp;const_i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;p1 = %p\n"</span>, &amp;p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;p2 = %p\n"</span>, &amp;p2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(p2));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p1 = %p\n"</span>, p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p2 = %p\n"</span>, p2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;global_p = %p\n"</span>, &amp;global_p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"global_p = %p\n"</span>, global_p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;p3 = %p\n"</span>, &amp;p3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p3 = %p\n"</span>, p3);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&amp;global_i = <span class="number">0x10e6a0020</span></span><br><span class="line">&amp;global_p = <span class="number">0x10e6a0028</span></span><br><span class="line">global_p = <span class="number">0x0</span></span><br><span class="line">&amp;static_i = <span class="number">0x10e6a0018</span></span><br><span class="line">&amp;i = <span class="number">0x7ffee15618ac</span></span><br><span class="line">&amp;const_i = <span class="number">0x7ffee15618a8</span></span><br><span class="line">&amp;p1 = <span class="number">0x7ffee15618a3</span></span><br><span class="line">&amp;p2 = <span class="number">0x7ffee1561898</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">p1 = <span class="number">0x7ffee15618a3</span></span><br><span class="line">p2 = <span class="number">0x10e69ef3a</span></span><br><span class="line">&amp;global_p = <span class="number">0x10e6a0028</span></span><br><span class="line">global_p = <span class="number">0x7fc593c05850</span></span><br><span class="line">&amp;p3 = <span class="number">0x7ffee1561890</span></span><br><span class="line">p3 = <span class="number">0x7fc593c05860</span></span><br><span class="line">[Finished in <span class="number">0.9</span>s]</span><br></pre></td></tr></table></figure><p>粗略地画了个草图……</p><img src="/2020/07/02/variable-storage-areas-in-cpp/1.jpg" class="" title="image"><p>在全局静态区的有<code>global_p</code>，<code>global_i</code>，<code>static_i</code>，其中<code>global_i</code>，<code>static_i</code>是int类型，所以1个int数据直接在全局区占4字节存数据，而<code>global_p</code>是char类型的指针，一开始没有初始化，C++默认初始化为零指针，指向<code>0x00</code>，但指针变量<code>global_p</code>是在全局区上，后面new分配了地址，才指向了堆区。</p><p>在栈上的有<code>i</code>，<code>const_i</code>，<code>p1</code>，<code>p2</code>，<code>p3</code>，其中<code>i</code>，<code>const_i</code>都是int，所以int数据之间存在栈上，但他们也有区别，加了const变量说明这块区域是不能“修改”的，你无法再给<code>const_i</code>重新赋值；<code>p1</code>是数组名，将常量区的<code>&quot;HUST\0&quot;</code>五个字符复制拷贝给p1数组，所以你会发现<code>p1</code>和<code>const_i</code>之间刚好有5个字节；<code>p2</code>是const char<em>，是指针，占8个字节，但如果仔细的算一下，你会发现，<code>p2</code>和<code>p1</code>之间有11个字节，好像对不上？其实不光这里对不上，你会发现在全局区里的int只占4个字节，但相邻int之间隔了8个字节，以及后面堆区上的<code>global_p</code>明明只分配10个字节，却和相邻区域隔了整整16个字节，其实这是C++里的*</em>内存对齐**规则，遵循4k/8k原则，这里不多说了。</p><p>堆上的就是<code>global_p</code>和<code>p3</code>分配的空间，注意一下栈和堆的地址高低，等会要讲……</p><p>常量区上的就是<code>p2</code>指向的常量，通过地址可以看得出来，常量区的地址和全局区很近，和堆栈区隔得比较远，那么这些区域在计算机内存中到底是如何分布的呢？</p><h3 id="四-图解"><a href="#四-图解" class="headerlink" title="四.图解"></a>四.图解</h3><p>在 sw-at 的博客上扒了一张图，这张图中所示内存空间，地址由下往上增长，分别标示了 .text、.data、.bss、stack和heap的内存分部情况。<br>我们可以看到：</p><ul><li>text、data(gvar)、bss 在内存中地址较低低的位置（low level address），而堆栈则在相对较搞的位置。</li><li>堆(Heap)往高地址方向生长，栈(Stack)往低地址方向生长。</li></ul><img src="/2020/07/02/variable-storage-areas-in-cpp/2.jpg" class="" title="image"><p>在C\C++中，通常可以把内存理解为4个分区：栈、堆、全局/静态存储区和常量存储区。下面我们分别简单地介绍一下各自的特点。</p><p><strong>1 栈</strong><br>        通常是用于那些在编译期间就能确定存储大小的变量的存储区，用于在函数作用域内创建，在离开作用域后自动销毁的变量的存储区。通常是局部变量，函数参数等的存储区。他的存储空间是连续的，两个紧密挨着定义的局部变量，他们的存储空间也是紧挨着的。栈的大小是有限的，通常Visual C++编译器的默认栈的大小为1MB，所以不要定义int a[1000000]这样的超大数组。</p><p><strong>2 堆</strong><br>        通常是用于那些在编译期间不能确定存储大小的变量的存储区，它的存储空间是不连续的，一般由malloc（或new）函数来分配内存块，并且需要用free（delete）函数释放内存。如果程序员没有释放掉，那么就会出现常说的内存泄漏问题。需要注意的是，两个紧挨着定义的指针变量，所指向的malloc出来的两块内存并不一定的是紧挨着的，所以会产生内存碎片。另外需要注意的一点是，堆的大小几乎不受限制，理论上每个程序最大可达4GB。</p><p><strong>3 全局/静态存储区</strong><br>        和“栈”一样，通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。</p><p><strong>4 常量存储区</strong><br>        和“全局/静态存储区”一样，通常是用于那些在编译期间就能确定存储大小的常量的存储区，并且在程序运行期间，存储区内的常量是全局可见的。这是一块比较特殊的存储去，他们里面存放的是常量，不允许被修改。</p><h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><p> 根据上面的内容，分别将栈和堆、全局/静态存储区和常量存储区进行对比，结果如下。</p><p><strong>表1 栈和堆的对比</strong></p><table><thead><tr><th></th><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>存储内容</td><td>局部变量</td><td>变量</td></tr><tr><td>作用域</td><td>函数作用域、语句块作用域</td><td>函数作用域、语句块作用域</td></tr><tr><td>编译期间大小是否确定</td><td>是</td><td>否</td></tr><tr><td>大小</td><td>1MB</td><td>4GB</td></tr><tr><td>内存分配方式</td><td>地址由高向低减少</td><td>地址由低向高增加</td></tr><tr><td>内容是否可以修改</td><td>是</td><td>是</td></tr></tbody></table><p><strong>表2 全局/静态存储区和常量存储区的对比</strong></p><table><thead><tr><th></th><th>全局/静态存储区</th><th>常量存储区</th></tr></thead><tbody><tr><td>存储内容</td><td>全局变量、静态变量</td><td>常量</td></tr><tr><td>编译期间大小是否确定</td><td>是</td><td>是</td></tr><tr><td>内容是否可以修改</td><td>是</td><td>否</td></tr></tbody></table><p>l          栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。.esp 始终指向栈顶, 栈中的数据越多, esp的值越小。</p><p>l          堆区：用于存放动态分配的对象, 当你使用 malloc和new 等进行分配时,所得到的空间就在堆中。动态分配得到的内存区域附带有分配信息, 所以你能够 free和delete它们。</p><p>l          数据区：全局，静态和常量是分配在数据区中的，数据区包括bss（未初始化数据区）和初始化数据区。</p><p>注意：</p><p>1）     堆向高内存地址生长；</p><p>2）     栈向低内存地址生长；</p><p>3）     堆和栈相向而生，堆和栈之间有个临界点，称为stkbrk。</p><p>全局区可以在编译期间确定大小，那么我们可以应该想到，<strong>static const</strong>关键词不光可以作为类的静态常量属性，还可以作为预编译声明。</p><p>当作为<strong>预编译声明</strong>时，static const 属性必须在声明时即指定值，而且类型仅限基本数据类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a =<span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时相当于C语言中的 <code>#define a 1</code> 宏定义了一个宏变量a，但是C++的这种方式比C的#define的优势在于，<strong>可以对类型进行检查和限制，减少了编译期间因为类型隐式转换而造成的潜在风险</strong>。</p><p>此时的static const常量既不存在于动态区也不存在于静态区（应该是存在于常量区或代码区），而是由编译器在编译期间就直接进行了值替换。也因为这个原因不可以对其进行取地址操作，因为它根本没有地址。</p><p>关于这些区域存取的效率，我们可以分析这样两行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] = <span class="string">"aaaaaaaaaaaaaaa"</span>; </span><br><span class="line"><span class="keyword">char</span> *s2 = <span class="string">"bbbbbbbbbbbbbbbbb"</span>;</span><br></pre></td></tr></table></figure><p>aaaaaaaaaaa是在运行时刻赋值给s1的，存在栈上；<br>而bbbbbbbbbbb是在编译时就确定的，存在常量区； </p><p>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 </p><p>栈是机器系统提供的数据结构，计算机在底层提供支持，分配有专门的堆栈段寄存器，入栈出栈有专门的机器指令，这些都决定了栈的高效率执行。</p><p>堆是由C/C++函数库提供的，机制比较复杂，有不同的分配算法，易产生内存碎片，需要对内存进行各种管理，效率比栈要低很多。</p><p>堆和栈的区别可以用如下的比喻来看出：<br>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p><h3 id="六-参考文章"><a href="#六-参考文章" class="headerlink" title="六.参考文章"></a>六.参考文章</h3><ul><li><a href="https://blog.csdn.net/jirryzhang/article/details/79518408" target="_blank" rel="noopener">C/C++程序内存的各种变量存储区域和各个区域详解</a></li><li><a href="https://www.cnblogs.com/zhoug2020/p/10520341.html" target="_blank" rel="noopener">c/c++内存机制（一）（转）</a></li><li><a href="https://www.cnblogs.com/ComputerG/archive/2012/02/01/2334898.html" target="_blank" rel="noopener">c/c++内存机制（一）（原）</a></li><li><a href="https://blog.csdn.net/qq_33266987/article/details/51965221" target="_blank" rel="noopener">C/C++ 全局变量和局部变量在内存里的区别？堆和栈</a></li><li><a href="https://blog.csdn.net/LYKXHTP/article/details/88877930" target="_blank" rel="noopener">C++ 常量区 静态区 堆区 栈区</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈字节序</title>
      <link href="/2020/06/29/byte-order/"/>
      <url>/2020/06/29/byte-order/</url>
      
        <content type="html"><![CDATA[<p>我记得那场面了3个小时的腾讯面试，面试官出了一道颠倒字节序的题目，当时完全不懂……昨晚看书，看到书上讲到了寻址和字节顺序，方才恍然大悟，发现还是自己书读的不够多。</p><a id="more"></a><h3 id="一-大小端"><a href="#一-大小端" class="headerlink" title="一.大小端"></a>一.大小端</h3><p>计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。</p><p>举例来说，数值<code>0x2211</code>使用两个字节储存：高位字节是<code>0x22</code>，低位字节是<code>0x11</code>。</p><blockquote><ul><li><strong>大端字节序</strong>：高位字节在前，低位字节在后，这是人类读写数值的方法。</li><li><strong>小端字节序</strong>：低位字节在前，高位字节在后，即以<code>0x1122</code>形式储存。</li></ul></blockquote><img src="/2020/06/29/byte-order/1.jpg" class="" title="image"><p>同理，<code>0x1234567</code>的大端字节序和小端字节序的写法如下图。</p><img src="/2020/06/29/byte-order/2.gif" class="" title="image"><p>注意，在字<code>0x1234567</code>中，高位字节的十六进制为<code>0x01</code>，而低位字节值为<code>0x67</code>。</p><h3 id="二-计算机如何处理字节序"><a href="#二-计算机如何处理字节序" class="headerlink" title="二.计算机如何处理字节序"></a>二.计算机如何处理字节序</h3><p>大多数的Intel兼容机都只用小端模式。另一方面，IBM和Oracle（从其2010年收购Sun Microsystems开始）的大多数机器则是按大端模式操作。但注意我们说的只是“大多数”。这些规则并没有严格按照企业界限来划分。比如IBM和Oracle制造的个人计算机使用的是Intel兼容的处理器，因此使用小端法。许多比较新的微处理器是<code>双端法（bi-endian）</code>，也就是说可以把它们配置成作为大段或小端的机器运行。然而实际情况是一旦选择了特定的操作系统，那么字节顺序也就固定下来了。例如，许多移动电话的ARM微处理器，其硬件可以按照小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统——Android和iOS——却只能运行于小端模式。</p><p>显然大端法更符合人类的阅读习惯，那为什么要有小端法呢？</p><p>答案是，计算机电路先处理低位字节，效率比较高，<strong>因为计算都是从低位开始的</strong>。所以，计算机的内部处理都是小端字节序。</p><p>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p><p>计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。</p><p>如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。</p><p>理解这一点，才能理解计算机如何处理字节序。</p><p>字节序的处理，就是一句话：</p><blockquote><p><strong>“只有读取的时候，才必须区分字节序，其他情况都不用考虑。”</strong></p></blockquote><p>处理器读取外部数据的时候，必须知道数据的字节序，将其转成正确的值。然后，就正常使用这个值，完全不用再考虑字节序。</p><p>即使是向外部设备写入数据，也不用考虑字节序，正常写入一个值即可。外部设备会自己处理字节序的问题。</p><p>举例来说，处理器读入一个16位整数。如果是大端字节序，就按下面的方式转成值。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = buf[offset] * <span class="number">256</span> + buf[offset+<span class="number">1</span>];</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>buf</code>是整个数据块在内存中的起始地址，<code>offset</code>是当前正在读取的位置。第一个字节乘以256，再加上第二个字节，就是大端字节序的值，这个式子可以用逻辑运算符改写。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = buf[offset]&lt;&lt;<span class="number">8</span> | buf[offset+<span class="number">1</span>];</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，第一个字节左移8位（即后面添8个<code>0</code>），然后再与第二个字节进行或运算。</p><p>如果是小端字节序，用下面的公式转成值。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = buf[offset+<span class="number">1</span>] * <span class="number">256</span> + buf[offset];</span><br></pre></td></tr></table></figure></blockquote><p>32位整数的求值公式也是一样的。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 大端字节序 */</span></span><br><span class="line">i = (data[<span class="number">3</span>]&lt;&lt;<span class="number">0</span>) | (data[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>) | (data[<span class="number">1</span>]&lt;&lt;<span class="number">16</span>) | (data[<span class="number">0</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 小端字节序 */</span></span><br><span class="line">i = (data[<span class="number">0</span>]&lt;&lt;<span class="number">0</span>) | (data[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>) | (data[<span class="number">2</span>]&lt;&lt;<span class="number">16</span>) | (data[<span class="number">3</span>]&lt;&lt;<span class="number">24</span>);</span><br></pre></td></tr></table></figure></blockquote><h3 id="三-判断自己的电脑的字节序"><a href="#三-判断自己的电脑的字节序" class="headerlink" title="三.判断自己的电脑的字节序"></a>三.判断自己的电脑的字节序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x\n"</span>, n);</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span>*)&amp;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %p\n"</span>, *(p+i), p+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*p==<span class="number">10</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Little-endian in this PC."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Big-endian in this PC."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (*(<span class="keyword">char</span> *) &amp;x ==<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Little endian!\n"</span>);</span><br><span class="line">  <span class="keyword">else</span>    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Big endian!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="number">10</span> <span class="number">0x7ffeef765b6c</span></span><br><span class="line"><span class="number">0</span> <span class="number">0x7ffeef765b6d</span></span><br><span class="line"><span class="number">0</span> <span class="number">0x7ffeef765b6e</span></span><br><span class="line"><span class="number">0</span> <span class="number">0x7ffeef765b6f</span></span><br><span class="line">Little-endian in <span class="keyword">this</span> PC.</span><br><span class="line">Little endian!</span><br></pre></td></tr></table></figure><h3 id="四-大小端的转换"><a href="#四-大小端的转换" class="headerlink" title="四.大小端的转换"></a>四.大小端的转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %.2x"</span>, start[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span> *x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">swapInt32</span><span class="params">(<span class="keyword">int32_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">           ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">           ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) |</span><br><span class="line">           ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data is %d\n"</span>, data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bytes order of data is"</span>);   show_int(data);</span><br><span class="line">    <span class="keyword">char</span>* pa = (<span class="keyword">char</span>*) &amp;data;</span><br><span class="line">    <span class="keyword">int</span> big_data = (pa[<span class="number">3</span>]&lt;&lt;<span class="number">0</span>) | (pa[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>) | (pa[<span class="number">1</span>]&lt;&lt;<span class="number">16</span>) | (pa[<span class="number">0</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">int</span> little_data = (pa[<span class="number">0</span>]&lt;&lt;<span class="number">0</span>) | (pa[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>) | (pa[<span class="number">2</span>]&lt;&lt;<span class="number">16</span>) | (pa[<span class="number">3</span>]&lt;&lt;<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"big_endian order data is %d\n"</span>, big_data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"little_endian order data is %d\n"</span>, little_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12345</span>;</span><br><span class="line">    show_int(<span class="number">12345</span>);</span><br><span class="line">    show_float(<span class="number">12345.6789</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">    show_pointer(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0x01234567</span>;</span><br><span class="line">    read(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--------After swap bytes order--------\n"</span>);</span><br><span class="line">    data = swapInt32(data);</span><br><span class="line">    read(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">39</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"> b7 e6 <span class="number">40</span> <span class="number">46</span></span><br><span class="line"><span class="number">0x7ffee5f20b5c</span></span><br><span class="line"> <span class="number">5</span>c <span class="number">0b</span> f2 e5 fe <span class="number">7f</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">data is <span class="number">19088743</span></span><br><span class="line">bytes order of data is <span class="number">67</span> <span class="number">45</span> <span class="number">23</span> <span class="number">01</span></span><br><span class="line">big_endian order data is <span class="number">1732584193</span></span><br><span class="line">little_endian order data is <span class="number">19088743</span></span><br><span class="line">--------After swap bytes order--------</span><br><span class="line">data is <span class="number">1732584193</span></span><br><span class="line">bytes order of data is <span class="number">01</span> <span class="number">23</span> <span class="number">45</span> <span class="number">67</span></span><br><span class="line">big_endian order data is <span class="number">19088743</span></span><br><span class="line">little_endian order data is <span class="number">1732584193</span></span><br></pre></td></tr></table></figure><h3 id="五-参考文章"><a href="#五-参考文章" class="headerlink" title="五.参考文章"></a>五.参考文章</h3><ul><li><a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">理解字节序</a></li><li>深入理解计算机系统</li><li><a href="https://blog.csdn.net/qq_37941471/article/details/81301536?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节 序</a></li><li><a href="https://blog.csdn.net/bitzhidu/article/details/106332088" target="_blank" rel="noopener">【百度笔试题】简述大小端字节序的概念并写一个小程序检测当前机器的大小端字节序</a></li><li><a href="https://blog.csdn.net/kuai0705/article/details/20841133" target="_blank" rel="noopener">［c/c++ ］字节序与大小端转换</a></li><li><a href="https://blog.csdn.net/sunboyiris/article/details/77574566" target="_blank" rel="noopener">C/C++ 大小端理解及转换</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 字节序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C/C++整型上下限INT_MAX和INT_MIN及其运算</title>
      <link href="/2020/06/28/INT-MAX-INT-MIN/"/>
      <url>/2020/06/28/INT-MAX-INT-MIN/</url>
      
        <content type="html"><![CDATA[<p>今天在刷题的时候，遇到几道关于处理32位有符号整数的题目：<a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7.整数反转</a>和 <a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8.字符串转换整数 (atoi)</a>。题目看起来不算很难，但如果在面试时遇到这样的题目，想想面试官是要考察你什么？考察你用long抖机灵吗？考察你会捕获异常吗？我想应该是要考察你对C/C++中整型的上下限的理解以及这方面的细节处理。</p><a id="more"></a><h3 id="一-整型数据类型和数据大小"><a href="#一-整型数据类型和数据大小" class="headerlink" title="一.整型数据类型和数据大小"></a>一.整型数据类型和数据大小</h3><p>说到整型数据类型，很多人第一反应就是int。</p><p>int占4个字节，1个字节通常是占8位，所以一个int占32位，根据二进制编码规则，int最大是2^32-1(2147483647)，最小是-2^32(-2147483648)。</p><p>除了int还有吗？</p><p>在C当中：</p><table><thead><tr><th>C声明</th><th></th><th>字节数</th><th></th></tr></thead><tbody><tr><td>有符号</td><td>无符号</td><td>32位</td><td>64位</td></tr><tr><td>[signed] char</td><td>unsigned char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>unsigned</td><td>4</td><td>4</td></tr><tr><td>long</td><td>unsigned long</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>8</td><td>8</td></tr><tr><td>char*</td><td></td><td>4</td><td>8</td></tr><tr><td>float</td><td></td><td>4</td><td>4</td></tr><tr><td>double</td><td></td><td>8</td><td>8</td></tr></tbody></table><p>我们只讨论整数类型，整数我们可以分为两种类型，一种是<strong>有符号</strong>的，这种可以表示负数、零和正数；另一种是<strong>无符号</strong>的，这种只能表示非负数。</p><p>在32位程序上，C语言整型数据类型的典型取值范围如下：</p><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>[signed] char</td><td>-128</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32768</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned</td><td>0</td><td>4294967295</td></tr><tr><td>long</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned long</td><td>0</td><td>4294967295</td></tr><tr><td>int32_t</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>uint32_t</td><td>0</td><td>4294967295</td></tr><tr><td>int64_t</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>uint64_t</td><td>0</td><td>18446744073709551615</td></tr></tbody></table><p>在64位程序上，C语言整型数据类型的典型取值范围如下：</p><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>[signed] char</td><td>-128</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32768</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned</td><td>0</td><td>4294967295</td></tr><tr><td>long</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>unsigned long</td><td>0</td><td>18446744073709551615</td></tr><tr><td>int32_t</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>uint32_t</td><td>0</td><td>4294967295</td></tr><tr><td>int64_t</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>uint64_t</td><td>0</td><td>18446744073709551615</td></tr></tbody></table><p>通过上面两张表我们可以注意到，有符号的整型的取值范围是不对称的——负数的范围比整数的范围大1。这个原因是计算机在用二进制表示负数的时候用到了<strong>补码编码</strong>，最前面一位是符号位，就不在这里啰嗦了……</p><p>C语言标准定义了每种数据类型必须能够表示的最小取值范围：</p><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>[signed] char</td><td>-127</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32767</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-32767</td><td>32767</td></tr><tr><td>unsigned</td><td>0</td><td>65535</td></tr><tr><td>long</td><td>-2147483647</td><td>2147483647</td></tr><tr><td>unsigned long</td><td>0</td><td>4294967295</td></tr><tr><td>int32_t</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>uint32_t</td><td>0</td><td>4294967295</td></tr><tr><td>int64_t</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>uint64_t</td><td>0</td><td>18446744073709551615</td></tr></tbody></table><p>C++中的整型类型和范围如下：</p><table><thead><tr><th>类型</th><th>位</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1 个字节</td><td>-128 到 127 或者 0 到 255</td></tr><tr><td>unsigned char</td><td>1 个字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 个字节</td><td>-128 到 127</td></tr><tr><td>int</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>unsigned int</td><td>4 个字节</td><td>0 到 4294967295</td></tr><tr><td>signed int</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>short int</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>unsigned short int</td><td>2 个字节</td><td>0 到 65,535</td></tr><tr><td>signed short int</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>long int</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>signed long int</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>unsigned long int</td><td>8 个字节</td><td>0 到 18,446,744,073,709,551,615</td></tr><tr><td>float</td><td>4 个字节</td><td>精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr><tr><td>double</td><td>8 个字节</td><td>双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td></tr><tr><td>long double</td><td>16 个字节</td><td>长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr><tr><td>wchar_t</td><td>2 或 4 个字节</td><td>1 个宽字符</td></tr></tbody></table><p>其实 wchar_t 是这样来的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> short <span class="keyword">int</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>所以 wchar_t 实际上的空间是和 short int 一样。</p><p><strong>注意：</strong>不同系统会有所差异，一字节为 8 位。</p><p><strong>注意：</strong>long int 与 int 都是 4 个字节，因为早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的C/C++ 标准兼容了早期的这一设定。</p><blockquote><p>C和C++都支持有符号（默认）和无符号数，Java只支持有符号数</p></blockquote><h3 id="二-INT-MAX和INT-MIN"><a href="#二-INT-MAX和INT-MIN" class="headerlink" title="二.INT_MAX和INT_MIN"></a>二.INT_MAX和INT_MIN</h3><p>我们已经知道了C/C++中一个int占32位，于是为了方便表示int类型的范围，于是在头文件limits.h中，用常量INT_MAX和INT_MIN分别表示最大、最小整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br><span class="line"><span class="comment">//這裏沒有簡單地將INT_MIN賦值成-2147483647，是因為-2147483648對於編譯器而言是個表達式，</span></span><br><span class="line"><span class="comment">//而2147483648對於32-bit整數是無法表示的，所以經過這個表達式的結果是未定義的。</span></span><br><span class="line"><span class="comment">//在GCC上直接寫-2147483648後，編譯器給出了警告，說結果是unsigned。</span></span><br></pre></td></tr></table></figure><p>在C/C++語言中，不能夠直接使用-2147483648來代替最小負數，因為這不是一個數字，而是一個表達式。表達式的意思是對整數21473648取負，但是2147483648已經溢出了int的上限，所以定義為（-INT_MAX -1）。</p><p>记住INT_MAX和INT_MIN的定义，在后面的运算中很重要。</p><p>我们用二进制来表示INT_MAX和INT_MIN：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX == <span class="number">0b01111111111111111111111111111111</span>;<span class="comment">// 31个1</span></span><br><span class="line">INT_MIN == <span class="number">0b10000000000000000000000000000000</span>;<span class="comment">// 31个0</span></span><br></pre></td></tr></table></figure><h3 id="三-运算"><a href="#三-运算" class="headerlink" title="三.运算"></a>三.运算</h3><p>当我们弄清楚了INT_MAX和INT_MIN的本质之后再来谈谈他们的运算。</p><p>整数的运算离不开二进制编码的原码、补码和反码这些规则，所以当在刷算法题涉及到INT_MAX和INT_MIN时我们应该对边界情况考虑周到，考虑溢出的情况，当发生溢出的时候，就不会遵循数学规则了。</p><p><strong>INT_MAX + 1 = INT_MIN</strong></p><p><strong>INT_MIN - 1 = INT_MAX</strong></p><p><strong>abs(INT_MIN) = INT_MIN</strong></p><p>前两条对比二进制做加减法就能一目了然，那么第三条abs()这个怎么解释呢？别忘了<code>#define INT_MIN (-INT_MAX - 1)</code> 所以<code>abs(INT_MIN)</code>也就是<code>abs(-INT_MAX - 1)</code>，结果就是<code>INT_MAX+1</code>，还是<code>INT_MIN</code>。</p><p>同理，<code>-INT_MIN == INT_MIN</code>。</p><p>那么我们可以达到另外一种下溢：</p><p><strong>INT_MIN + INT_MIN = 0</strong></p><p>将上式中的<code>INT_MIN</code>用<code>INT_MAX+1</code>进行替换，我们就得到了另一种上溢：</p><p><strong>INT_MAX + INT_MAX = -2</strong></p><p>总结一下：</p><ol><li>最轻微的上溢是INT_MAX + 1 :结果是 INT_MIN; </li><li>最严重的上溢是INT_MAX + INT_MAX :结果是-2; </li><li>最轻微的下溢是INT_MIN - 1:结果是是INT_MAX; </li><li>最严重的下溢是INT_MIN + INT_MIN:结果是0 。</li></ol><h3 id="四-代码"><a href="#四-代码" class="headerlink" title="四.代码"></a>四.代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0b10000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0b01111111111111111111111111111111</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (i == INT_MIN) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (j == INT_MAX) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-INT_MIN = "</span> &lt;&lt; -INT_MIN &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN = "</span> &lt;&lt; INT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN/10 = "</span> &lt;&lt; INT_MIN/<span class="number">10</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN%10 = "</span> &lt;&lt; INT_MIN%<span class="number">10</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-INT_MIN%10 = "</span> &lt;&lt; -INT_MIN%<span class="number">10</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-(INT_MIN%10) = "</span> &lt;&lt; -(INT_MIN%<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MAX + INT_MAX = "</span> &lt;&lt; INT_MAX + INT_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN + INT_MIN = "</span> &lt;&lt; INT_MIN + INT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/Users/saladdays/Projects/Learn_CPP/INT/int.cpp:16:44: warning: overflow in expression; result is -2 with type 'int' [-Winteger-overflow]</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MAX + INT_MAX = "</span> &lt;&lt; INT_MAX + INT_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                                                  ^</span><br><span class="line">/Users/saladdays/Projects/Learn_CPP/INT/int.cpp:17:44: warning: overflow in expression; result is 0 with type 'int' [-Winteger-overflow]</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INT_MIN + INT_MIN = "</span> &lt;&lt; INT_MIN + INT_MIN &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                                                  ^</span><br><span class="line"><span class="number">2</span> warnings generated.</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">-INT_MIN = <span class="number">-2147483648</span></span><br><span class="line">INT_MIN = <span class="number">-2147483648</span></span><br><span class="line">INT_MIN/<span class="number">10</span> = <span class="number">-214748364</span></span><br><span class="line">INT_MIN%<span class="number">10</span> = <span class="number">-8</span></span><br><span class="line">-INT_MIN%<span class="number">10</span> = <span class="number">-8</span></span><br><span class="line">-(INT_MIN%<span class="number">10</span>) = <span class="number">8</span></span><br><span class="line">INT_MAX + INT_MAX = <span class="number">-2</span></span><br><span class="line">INT_MIN + INT_MIN = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="五-参考文章"><a href="#五-参考文章" class="headerlink" title="五.参考文章"></a>五.参考文章</h3><ul><li>深入理解计算机系统</li><li><a href="https://www.runoob.com/cplusplus/cpp-data-types.html" target="_blank" rel="noopener">C++数据类型</a></li><li><a href="https://www.itread01.com/content/1534661783.html" target="_blank" rel="noopener">INT_MIN和INT_MAX註意事項 //C++</a></li><li><a href="https://stackoverflow.com/questions/54292185/why-int-min-is-not-2147483648-for-uint64-t-type" target="_blank" rel="noopener">Why -INT_MIN is NOT 2147483648 for uint64_t type</a></li><li><a href="https://blog.csdn.net/weixin_42372777/article/details/83092086" target="_blank" rel="noopener">C/C++中int型上下限INT_MAX INT_MIN以及溢出</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>initializer_list</title>
      <link href="/2020/06/23/initializer-list/"/>
      <url>/2020/06/23/initializer-list/</url>
      
        <content type="html"><![CDATA[<p>我记得有次面试的时候面试官提过一句initializer_list，当时只是知道这个东西是C++11中的新类型，但并没有去深入了解它，今天突然想到了就看了一些文章，随便记录一下。</p><p>C++11提供的新类型，定义在<initializer_list>头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">initializer_list</span>;</span></span><br></pre></td></tr></table></figure><p>回忆一下我们初始化一个vector有哪些方法？</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: s) </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">4</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(a, a+<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v5</span><span class="params">(v4.begin(), v4.end())</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v6 = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v7&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">show(v1);</span><br><span class="line">show(v2);</span><br><span class="line">show(v3);</span><br><span class="line">show(v4);</span><br><span class="line">show(v5);</span><br><span class="line">show(v6);</span><br><span class="line">show(v7);</span><br><span class="line"><span class="comment">//show(&#123;1,0,3,7&#125;);// invalid: note: candidate template ignored: couldn't infer template argument 'T'</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面罗列了6种初始化vector的方法，但我在电脑上执行的时候，v6报错了：</p><img src="/2020/06/23/initializer-list/1.png" class="" title="image"><p>我们忽略auto语法的warning，专注一下最后一个error：<strong>error:</strong> <strong>non-aggregate type ‘vector&lt; int &gt;’ cannot be initialized with an initializer list</strong>。大概意思就是我们不能用一个initializer list去初始化一个vector&lt; int &gt;，为啥不行呢？</p><p>我们从C++官网可以找到答案：</p><blockquote><p> A <code>std::initializer_list</code> object is automatically constructed when:</p><ul><li>a <em>braced-init-list</em> is used to <a href="https://en.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="noopener">list-initialize</a> an object, where the corresponding constructor accepts an <code>std::initializer_list</code> parameter</li><li>a <em>braced-init-list</em> is used as the right operand of <a href="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_direct_assignment" target="_blank" rel="noopener">assignment</a> or as a <a href="https://en.cppreference.com/w/cpp/language/overload_resolution#Implicit_conversion_sequence_in_list-initialization" target="_blank" rel="noopener">function call argument</a>, and the corresponding assignment operator/function accepts an <code>std::initializer_list</code> parameter</li><li>a <em>braced-init-list</em> is bound to <a href="https://en.cppreference.com/w/cpp/language/auto" target="_blank" rel="noopener"><code>auto</code></a>, including in a <a href="https://en.cppreference.com/w/cpp/language/range-for" target="_blank" rel="noopener">ranged for loop</a></li></ul></blockquote><p>上面这段话的意思大概就是，在这些情况下会自动构造一个<code>std::initializer_list</code>对象：</p><ul><li>对一个对象初始化是使用大括号<code>std::initializer_list</code>初始化的时候，<code>std::initializer_list</code>对象会被自动构造，同时也适用于赋值和函数调用的参数。</li><li>上面的前提是你要初始化的对象、对应的赋值运算符和函数<strong>必须可以接受(accepts)一个<code>std::initializer_list</code>参数</strong>。</li><li>涉及到for循环的时候，或者auto的时候，使用大括号也会也会被自动构造成一个<code>std::initializer_list</code>。</li></ul><p>也就是说initializer_list对象只能用大括号{}初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">10</span>,<span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// the type of il is an initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>在C++11之前的vector这些STL并没有参数为<code>std::initializer_list</code>的构造函数，所以当我们将一个<code>std::initializer_list</code>赋值拷贝或者拷贝构造给一个对象的前提是，这个对象有提供参数为<code>std::initializer_list</code>的赋值拷贝运算符或拷贝构造函数。上面的程序在C++11的环境下执行就没有问题了。</p><p>另外，拷贝一个initializer_list对象并不会拷贝里面的元素。其实只是引用而已。而且里面的元素全部都是const的，所以我们不能去修改一个<code>std::initializer_list</code>里的数值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=il;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; ill=il;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;v);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, il.begin());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, ill.begin());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;il);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;ill);</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x7ffee328a828</span></span><br><span class="line"><span class="comment">//0x10c978e30</span></span><br><span class="line"><span class="comment">//0x10c978e30</span></span><br><span class="line"><span class="comment">//0x7ffee328a840</span></span><br><span class="line"><span class="comment">//0x7ffee328a808</span></span><br></pre></td></tr></table></figure><p>通过查看对象和对象里元素的地址，我们可以证实了，<code>std::initializer_list</code>里的元素作为const是存在常量区里，随着整个程序的结束才被系统释放，而我们定义出来的<code>std::initializer_list ill</code> 和<code>std::vector v</code>是作为局部变量存在栈区的，函数生命周期结束局部变量也就随之释放了内存。</p><p>还有一点关于对<code>std::initializer_list</code>里的元素访问，我们并不能像访问数组那样用数字下标去访问，因为<code>std::initializer_list</code>并没有提供这样的操作符，我们只能像使用vector一样使用迭代器去访问<code>std::initializer_list</code>里的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> beg=il.begin();beg!=il.end();++beg)</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;*beg&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后让我们再品味一下官方提供的代码吧，你细品你细品~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; v;</span><br><span class="line">    S(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l) : v(l) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructed with a "</span> &lt;&lt; l.size() &lt;&lt; <span class="string">"-element list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.insert(v.end(), l.begin(), l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.size()&#125;;  <span class="comment">// copy list-initialization in return statement</span></span><br><span class="line">                                   <span class="comment">// this is NOT a use of std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">templated_fn</span><span class="params">(T s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: s)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="keyword">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// copy list-initialization</span></span><br><span class="line">    s.append(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// list-initialization in function call</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The vector size is now "</span> &lt;&lt; s.c_arr().second &lt;&lt; <span class="string">" ints:\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Range-for over brace-init-list: \n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// the rule for auto makes this ranged-for work</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// special rule for auto</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The list bound to auto has size() = "</span> &lt;&lt; al.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // compiler error! "&#123;1, 2, 3&#125;" is not an expression,</span></span><br><span class="line">                             <span class="comment">// it has no type, and so T cannot be deduced</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// also OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">constructed with a <span class="number">5</span>-element <span class="built_in">list</span></span><br><span class="line">The <span class="built_in">vector</span> size is now <span class="number">8</span> ints:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> </span><br><span class="line">Range-<span class="keyword">for</span> over brace-init-<span class="built_in">list</span>: </span><br><span class="line"><span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span> </span><br><span class="line"><span class="function">The <span class="built_in">list</span> bound to <span class="keyword">auto</span> has <span class="title">size</span><span class="params">()</span> </span>= <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://en.cppreference.com/w/cpp/utility/initializer_list" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/initializer_list</a></li><li><a href="https://www.cnblogs.com/lysuns/p/4278589.html" target="_blank" rel="noopener">C++11中新特性之：initializer_list详解</a></li><li><a href="https://blog.csdn.net/wangkai_123456/article/details/76252073" target="_blank" rel="noopener">C++ 11 initializer_list关键字</a></li><li><a href="https://blog.csdn.net/fengbingchun/article/details/77938005" target="_blank" rel="noopener">C++11中std::initializer_list的使用</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网面试题目梳理</title>
      <link href="/2020/06/23/computer-networking/"/>
      <url>/2020/06/23/computer-networking/</url>
      
        <content type="html"><![CDATA[<p>计算机网络。</p><p>重要性不言而喻。</p><p>考研的那几本书都快翻烂了，书上的东西虽不敢说理解了100%，理解了个60%还是有的。</p><p>背是不可能背下来的，这辈子都不可能死记硬背的，最多面试前突击记一下……那就来看看哪些需要记忆的吧~</p><a id="more"></a><h3 id="一-计算机网络体系结构"><a href="#一-计算机网络体系结构" class="headerlink" title="一.计算机网络体系结构"></a>一.计算机网络体系结构</h3><img src="/2020/06/23/computer-networking/1.png" class="" title="image"><p>我们主要讨论的还是OSI七层模型：</p><img src="/2020/06/23/computer-networking/2.png" class="" title="image"><h5 id="Q1-OSI七层模型的作用"><a href="#Q1-OSI七层模型的作用" class="headerlink" title="Q1.OSI七层模型的作用"></a>Q1.OSI七层模型的作用</h5><ol><li>应用层(数据):确定进程之间通信的性质以满足用户需要以及提供网络与用户应用；</li><li>表示层(数据):主要解决拥护信息的语法表示问题，如加密解密；</li><li>会话层(数据):提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的；</li><li>传输层(段):实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等；</li><li>网络层(包):提供逻辑地址(IP)、选路，数据从源端到目的端的传输；</li><li>数据链路层(帧):将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正；</li><li>物理层(比特流):设备之间比特流的传输，物理接口，电气特性等。</li></ol><h5 id="Q2-各层使用的是哪个数据交换设备-交换机、路由器、网关"><a href="#Q2-各层使用的是哪个数据交换设备-交换机、路由器、网关" class="headerlink" title="Q2.各层使用的是哪个数据交换设备(交换机、路由器、网关)"></a>Q2.各层使用的是哪个数据交换设备(交换机、路由器、网关)</h5><ol><li>网关:应用层、传输层(网关在传输层上以实现网络互连，是最复杂的网络互连设 备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是 互连层。网关既可以用于广域网互连，也可以用于局域网互连)；</li><li>路由器:网络层(路由选择、存储转发)；</li><li>交换机:数据链路层、网络层(识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中)；</li><li>网桥:数据链路层(将两个 LAN 连起来，根据 MAC 地址来转发帧)；</li><li>集线器(Hub):物理层(纯硬件设备，主要用来连接计算机等网络终端)；</li><li>中继器:物理层(在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离)。</li></ol><p>面试最喜欢问的主要就四个相关协议，TCP、UDP、IP、HTTP，简单记录一些相关问题吧。</p><h3 id="二-IP"><a href="#二-IP" class="headerlink" title="二.IP"></a>二.IP</h3><p>IP协议在网络层，同在网络层的还有DNS、ARP、ICMP等IP相关协议。</p><h5 id="Q3-什么是IP协议"><a href="#Q3-什么是IP协议" class="headerlink" title="Q3.什么是IP协议"></a>Q3.什么是IP协议</h5><p><strong>IP即网际协议，处在OSI七层模型中的网络层，网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点(end-to-end) 通信”。</strong>网络层的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进 行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同 的数据链路上也能实现两端节点之间的数据包传输。</p><p>IP大致分为三大作用模块，它们是<strong>IP寻址</strong>、<strong>路由</strong>(最终节点为止的转发)以及<strong>IP分包与组包</strong>。</p><p>IP数据报的格式：</p><img src="/2020/06/23/computer-networking/3.png" class="" title="image"><ul><li><p>版本 : 有 4(IPv4)和 6(IPv6)两个值;</p></li><li><p>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长 度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。</p></li><li><p>总长度 : 包括首部长度和数据部分长度。</p></li><li><p>生存时间 :TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li><li><p>协议 :指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p></li><li><p>首部检验和 :因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算 的工作量。</p></li><li><p>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ul><p>数据报分片的举例</p><img src="/2020/06/23/computer-networking/4.png" class="" title="image"><h5 id="Q4-IPv4和IPv6的区别"><a href="#Q4-IPv4和IPv6的区别" class="headerlink" title="Q4.IPv4和IPv6的区别"></a>Q4.IPv4和IPv6的区别</h5><ul><li><p>地址空间不同，IPv4中规定IP地址长度为32，而IPv6中IP地址的长度为128。</p></li><li><p>路由表大小不同，IPv6的路由表相比IPv4的更小。</p></li><li><p>IPv6的组播支持以及对流的支持要强于IPv4。</p></li><li><p>安全性不同，IPv6的安全性更高，在使用IPv6的网络时，用户可对网络层的数据进行加密。</p></li><li><p>协议扩充不同，IPv6允许协议进行扩充而IPv4不允许。</p></li></ul><h3 id="三-TCP-UDP"><a href="#三-TCP-UDP" class="headerlink" title="三.TCP/UDP"></a>三.TCP/UDP</h3><p>TCP/IP中有两个具有代表性的传输层协议，它们分别是TCP和UDP。TCP提供可靠的通信传输，而UDP 则常被用于让广播和细节控制交给应用的通信传输。总之，根据通信的具体特征，选择合适的传输层协议是非常重要的。</p><h5 id="Q5-TCP和UDP的特点和区别"><a href="#Q5-TCP和UDP的特点和区别" class="headerlink" title="Q5.TCP和UDP的特点和区别"></a>Q5.TCP和UDP的特点和区别</h5><p><strong>用户数据报协议 UDP（User Datagram Protocol）</strong></p><p>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p><p><strong>传输控制协议 TCP（Transmission Control Protocol）</strong></p><p>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p><ol><li>TCP 面向连接，UDP 面向无连接(无需建立连接)</li><li>TCP 面向字节流，UDP 面向报文</li><li>TCP 提供可靠传输服务(数据顺序、正确性)，UDP 传输不可靠</li><li>TCP 协议传输速度慢，UDP 协议传输速度快</li><li>TCP 协议对系统资源要求多(头部开销大)，UDP 协议要求少</li></ol><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="Q6-UDP校验和怎么计算"><a href="#Q6-UDP校验和怎么计算" class="headerlink" title="Q6.UDP校验和怎么计算"></a>Q6.UDP校验和怎么计算</h5><p>UDP 的校验和要计算首部和数据部分。首部还包括伪首部。</p><img src="/2020/06/23/computer-networking/5.png" class="" title="image"><p>多了 12 个字节的伪首部。<br> 注意点:UDP 长度计算两次。<br> 如果检验和有错，则 UDP 数据报被悄悄丢弃，不产生任何差错报文。</p><h5 id="Q7-UDP为什么要加伪首部"><a href="#Q7-UDP为什么要加伪首部" class="headerlink" title="Q7.UDP为什么要加伪首部"></a>Q7.UDP为什么要加伪首部</h5><p>目的是让 UDP 两次检查数据是否已经正确到达目的地。<br> IP 接受正确的目的地址，传送到正确的上层程序。 所有伪首部包括:源 IP 地址，目的 IP 地址，0，协议号，UDP 长度。</p><p>还有一个原因：<strong>TCP/IP或UDP/IP通信中通常采用5个信息来识别(这个信息可以在Unix或Windows系统中通过 netstat -n 命令显示。)一个通信。它们是“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端 口号”。只要其中某一项不同，则被认为是其他通信。</strong></p><p>TCP/IP中识别一个进行通信的应用需要5大要素，它们分别为“源IP地址”、“目标IP地址”、“源端 口”、“目标端口”、“协议号”。然而，在UDP的首部中只包含它们当中的两项(源端口和目标端口)，余下的3项都包含在IP首部里。</p><p>假定其他3项的信息被破坏会产生什么样的后果呢?很显然，这极有可能会导致应该收包的应用收不到包，不该收到包的应用却收到了包。</p><p>为了避免这类问题，有必要验证一个通信中必要的5项识别码是否正确。为此，在校验和的计算中就引入了伪首部的概念。</p><p>此外，IPv6中的IP首部没有校验和字段。TCP或UDP通过伪首部，得以对5项数字进行校验，从而实 现即使在IP首部并不可靠的情况下仍然能够提供可靠的通信传输。</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="Q8-TCP通过哪些方式来保证传输的可靠性"><a href="#Q8-TCP通过哪些方式来保证传输的可靠性" class="headerlink" title="Q8.TCP通过哪些方式来保证传输的可靠性"></a>Q8.TCP通过哪些方式来保证传输的可靠性</h5><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>确认机制，发送报文后，等待确认。</li><li>重发机制，没有收到确认，将重发数据段。</li><li>保持它首部和数据的校验和。确认数据的准确性。</li><li>排序，丢弃重复的，流量控制。</li></ol><h5 id="Q9-TCP的流量控制机制"><a href="#Q9-TCP的流量控制机制" class="headerlink" title="Q9.TCP的流量控制机制"></a>Q9.TCP的流量控制机制</h5><p>主要是下面的四种机制:</p><p><strong>慢启动(慢开始)</strong>:</p><ol><li><p>慢开始不是指 cwnd 的增长速度慢(指数增长)，而是指 TCP 开始发送设置 cwnd=1。 </p></li><li><p>思路:不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。</p></li><li><p>为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量) 当 cnwd&lt;ssthresh，使用慢开始算法<br> 当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法<br> 当 cnwd&gt;ssthresh，使用拥塞避免算法</p></li></ol><p><strong>拥塞避免</strong>:</p><ol><li><p>拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p></li><li><p>思路:让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控制窗口加一。</p></li></ol><p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理)，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口 设置为 1，执行慢开始算法。 如图所示:</p><img src="/2020/06/23/computer-networking/6.png" class="" title="image"><p><strong>快速重传</strong>:</p><ol><li><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p></li><li><p>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。</p></li></ol><p><strong>快速恢复</strong>:</p><ol><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。 但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小， 然后执行拥塞避免算法。</li></ol><h5 id="Q10-TCP的三次握手和四次挥手"><a href="#Q10-TCP的三次握手和四次挥手" class="headerlink" title="Q10.TCP的三次握手和四次挥手"></a>Q10.TCP的三次握手和四次挥手</h5><p><strong>TCP三次握手</strong></p><img src="/2020/06/23/computer-networking/7.png" class="" title="image"><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN(监听)状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时 也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong> </p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待 一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握 手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确 认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>TCP四次挥手</strong></p><img src="/2020/06/23/computer-networking/8.png" class="" title="image"><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都 为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL(最大报文存活时间)后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong><br>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 </p><p>TIME_WAIT</p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由:</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文， A 等待一段时间就是为了处理这种情况的发生。 </li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h5 id="Q11-服务器端突然出现大量的CLOSE-WAIT状态是什么原因"><a href="#Q11-服务器端突然出现大量的CLOSE-WAIT状态是什么原因" class="headerlink" title="Q11.服务器端突然出现大量的CLOSE_WAIT状态是什么原因"></a>Q11.服务器端突然出现大量的CLOSE_WAIT状态是什么原因</h5><p>（这个题是我在面试百度时被问过，当时直接懵逼……太菜了  : ( </p><p>服务器端出现大量的CLOSE_WAIT状态，说明服务器端没有发送FIN报文，也就是说服务器端的某些进程并没有结束导致服务器端没能向客户端发送FIN报文，通过网上查找资料总结了以下可能的原因：</p><ul><li>服务器端连接了SQL等数据库，执行完之后没有关闭连接；</li><li>服务器端的代码，socket连接，没有写close函数关闭连接，或者出现死循环，服务器端的代码永远执行不到 close。</li><li>客户机响应太慢或者 timeout 设置过小，当服务器端发生阻塞的时候，客户端发出的请求一直在等待，当超时之后就会抛出异常，关闭连接，关闭连接导致客户端发送了FIN报文，但是由于服务器端处理请求的线程还处于阻塞的状态，所以当前的连接状态处于CLOSE_WAIT。</li></ul><h3 id="四-HTTP"><a href="#四-HTTP" class="headerlink" title="四.HTTP"></a>四.HTTP</h3><h5 id="Q12-GET和POST的区别"><a href="#Q12-GET和POST的区别" class="headerlink" title="Q12.GET和POST的区别"></a>Q12.GET和POST的区别</h5><p><strong>作用</strong></p><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><p><strong>参数</strong></p><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在 实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具 (Fiddler)查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code> ，而<code>空格</code>会转换为 <code>%20</code> 。POST 参数支持标准字符集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test&#x2F;demo_form.asp?name1&#x3D;value1&amp;name2&#x3D;value2 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test&#x2F;demo_form.asp HTTP&#x2F;1.1 </span><br><span class="line">Host: w3schools.com </span><br><span class="line">name1&#x3D;value1&amp;name2&#x3D;value2</span><br></pre></td></tr></table></figure><p><strong>安全</strong></p><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数 据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有:HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><table><thead><tr><th>操作方式</th><th>数据位置</th><th>明文密文</th><th>数据安全</th><th>长度限时</th><th>应用场景</th></tr></thead><tbody><tr><td>GET</td><td>HTTP报头</td><td>明文</td><td>不安全</td><td>长度较小</td><td>查询数据</td></tr><tr><td>POST</td><td>HTTP正文</td><td>可明可密</td><td>安全</td><td>支持较大数据传输</td><td>修改数据</td></tr></tbody></table><h5 id="Q13-用浏览器打开一个网页的过程"><a href="#Q13-用浏览器打开一个网页的过程" class="headerlink" title="Q13.用浏览器打开一个网页的过程"></a>Q13.用浏览器打开一个网页的过程</h5><p>(假设主机一开始没有分配IP地址)整个过程可以概括为以下几步：</p><ol><li>DHCP协议自动分配主机IP地址；</li><li>DNS域名解析URL网页的IP地址；</li><li>应用层客户端(浏览器)发送HTTP请求；</li><li>传输层TCP三次握手建立连接，传输报文；</li><li>网络层IP协议把TCP分割好的各种数据包封装到IP包里面传送给接收方，ARP协议将IP地址解析为MAC地址；</li><li>得到下一个(不一定是目的)MAC地址后，数据链路层将IP包封装到数据帧结构中，再通过物理层的比特流送出去（至此客户端发送请求的阶段结束）；</li><li>服务器接收数据，在数据链路层接收到数据报，层层向上直到应用层。这过程中包括在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文；</li><li>服务器响应请求并返回相应文件；</li><li>浏览器开始处理数据信息并渲染页面；</li><li>将渲染好的页面图像显示出来，并开始响应用户的操作。</li></ol><h3 id="五-参考文章"><a href="#五-参考文章" class="headerlink" title="五.参考文章"></a>五.参考文章</h3><ul><li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></li><li>计算机网络·自顶向下方法 第六版</li><li>图解TCP/IP 第五版</li><li><a href="https://www.cnblogs.com/qcrao-2018/p/10182185.html" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗？</a></li><li><a href="https://blog.csdn.net/yu616568/article/details/44677985" target="_blank" rel="noopener">一次服务端大量CLOSE_WAIT问题的解决</a></li><li><a href="https://blog.csdn.net/qq_33528613/article/details/84987469" target="_blank" rel="noopener">出现过多的close_wait可能是什么原因？</a></li><li><a href="https://www.jianshu.com/p/d616d887953a" target="_blank" rel="noopener">浏览器工作原理：从 URL 输入到页面展现到底发生了什么？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C/C++中的char和string</title>
      <link href="/2020/06/19/char-string/"/>
      <url>/2020/06/19/char-string/</url>
      
        <content type="html"><![CDATA[<p>很想写一篇文章来谈一下C/C++中的char和string，顺带也可以说一下python中的string，因为我学习语言的顺序是先学了C再学python然后学C++，一开始对这两个数据类型并没有很敏感，前几天在用C写代码的时候，发现在使用char *和char ch[]的时候有些模糊，而且在给它们初始化或者赋值的时候也会出错。在传统的C里面，我们可以初始化一个定长的char数组，但不能直接给一个定长的char数组赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">20</span>] = <span class="string">"Hello,world!"</span>;<span class="comment">// valid</span></span><br><span class="line"><span class="keyword">char</span> sh[<span class="number">20</span>]；</span><br><span class="line">sh = <span class="string">"Hello,world!"</span>;<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure><p>编译器会提示你：</p><a id="more"></a><p><code>array type &#39;char [20]&#39; is not assignable</code></p><p>这个时候我们需要用到<strong>strcpy()</strong>函数，它存在于string.h头文件当中，使用前你需要include这个头文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sh[<span class="number">20</span>]；</span><br><span class="line">sh = <span class="string">"Hello,world!"</span>;<span class="comment">// invalid</span></span><br><span class="line"><span class="built_in">strcpy</span>(sh, <span class="string">"Hello,world!"</span>);<span class="comment">// valid</span></span><br></pre></td></tr></table></figure><h3 id="一-char类型详解"><a href="#一-char类型详解" class="headerlink" title="一.char类型详解"></a>一.char类型详解</h3><h4 id="1-char与字符的关系"><a href="#1-char与字符的关系" class="headerlink" title="1.char与字符的关系"></a>1.char与字符的关系</h4><p>在C/C++中，char是定义一个字符，存储一个字符，占一个字节(byte)，在内存中占8位(bit)。</p><p>我们需要知道这个知识点，在计算机中，通常8位代表一个字节，即1byte = 8bits。</p><p>所以一个signed char的范围为-128-127，unsigned char的范围为0-255。</p><p>计算机通常用二进制存储信息，所以我们在计算机上看到的汉字、英文等字符是二进制数转换的结果。那么有时候我们在打开一个网页或文件的时候，显示一堆乱码是什么情况呢？这就需要探讨一下不同的字符集。</p><h4 id="2-什么是字符集"><a href="#2-什么是字符集" class="headerlink" title="2.什么是字符集"></a>2.什么是字符集</h4><p><strong>字符集</strong>(charset)是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。常见的字符集比如ASCII码，它是由美国ANSI制定的，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">128</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[%3d -&gt; %c] "</span>, i, i);</span><br><span class="line">  <span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ 32 -&gt;  ] [ 33 -&gt; !] [ 34 -&gt; <span class="string">"] [ 35 -&gt; #] [ 36 -&gt; $] [ 37 -&gt; %] [ 38 -&gt; &amp;] [ 39 -&gt; '] [ 40 -&gt; (] </span></span><br><span class="line"><span class="string">[ 41 -&gt; )] [ 42 -&gt; *] [ 43 -&gt; +] [ 44 -&gt; ,] [ 45 -&gt; -] [ 46 -&gt; .] [ 47 -&gt; /] [ 48 -&gt; 0] [ 49 -&gt; 1] [ 50 -&gt; 2] </span></span><br><span class="line"><span class="string">[ 51 -&gt; 3] [ 52 -&gt; 4] [ 53 -&gt; 5] [ 54 -&gt; 6] [ 55 -&gt; 7] [ 56 -&gt; 8] [ 57 -&gt; 9] [ 58 -&gt; :] [ 59 -&gt; ;] [ 60 -&gt; &lt;] </span></span><br><span class="line"><span class="string">[ 61 -&gt; =] [ 62 -&gt; &gt;] [ 63 -&gt; ?] [ 64 -&gt; @] [ 65 -&gt; A] [ 66 -&gt; B] [ 67 -&gt; C] [ 68 -&gt; D] [ 69 -&gt; E] [ 70 -&gt; F] </span></span><br><span class="line"><span class="string">[ 71 -&gt; G] [ 72 -&gt; H] [ 73 -&gt; I] [ 74 -&gt; J] [ 75 -&gt; K] [ 76 -&gt; L] [ 77 -&gt; M] [ 78 -&gt; N] [ 79 -&gt; O] [ 80 -&gt; P] </span></span><br><span class="line"><span class="string">[ 81 -&gt; Q] [ 82 -&gt; R] [ 83 -&gt; S] [ 84 -&gt; T] [ 85 -&gt; U] [ 86 -&gt; V] [ 87 -&gt; W] [ 88 -&gt; X] [ 89 -&gt; Y] [ 90 -&gt; Z] </span></span><br><span class="line"><span class="string">[ 91 -&gt; [] [ 92 -&gt; \] [ 93 -&gt; ]] [ 94 -&gt; ^] [ 95 -&gt; _] [ 96 -&gt; `] [ 97 -&gt; a] [ 98 -&gt; b] [ 99 -&gt; c] [100 -&gt; d] </span></span><br><span class="line"><span class="string">[101 -&gt; e] [102 -&gt; f] [103 -&gt; g] [104 -&gt; h] [105 -&gt; i] [106 -&gt; j] [107 -&gt; k] [108 -&gt; l] [109 -&gt; m] [110 -&gt; n] </span></span><br><span class="line"><span class="string">[111 -&gt; o] [112 -&gt; p] [113 -&gt; q] [114 -&gt; r] [115 -&gt; s] [116 -&gt; t] [117 -&gt; u] [118 -&gt; v] [119 -&gt; w] [120 -&gt; x] </span></span><br><span class="line"><span class="string">[121 -&gt; y] [122 -&gt; z] [123 -&gt; &#123;] [124 -&gt; |] [125 -&gt; &#125;] [126 -&gt; ~] [127 -&gt; ]</span></span><br></pre></td></tr></table></figure><p>传统的128个ASCII码有33个是控制字符(0-31, 127)，是不可显示的，剩下的都是可显示字符。</p><p>除了ASCII码之外，还有GBxxxx(汉字编码字符集)，Unicode(<strong>统一码</strong>、<strong>万国码</strong>、<strong>单一码</strong>、<strong>标准万国码</strong>)。</p><h4 id="3-如何表示字符"><a href="#3-如何表示字符" class="headerlink" title="3.如何表示字符"></a>3.如何表示字符</h4><p>通俗的说，按照何种规则将字符存储在计算机中，如’a’用什么表示，称为”<strong>编码</strong>“；反之，将存储在计算机中的二进制数解析显示出来，称为”<strong>解码</strong>“，如同密码学中的加密和解密。</p><p>汉字的编码标准，GBK；Unicode的编码标准，UTF。</p><p>在解码过程中，如果使用了错误的解码规则，则导致’a’解析成’b’或者乱码。</p><h4 id="4-C-中的字符类型"><a href="#4-C-中的字符类型" class="headerlink" title="4.C++中的字符类型"></a>4.C++中的字符类型</h4><p>C++提供了几种字符类型，并非只有8bits的char。比如我们熟知的ASCII码，在这种字符集系统上C++的字节确实是8位，然而在国际编程中采用更大的字符集比如Unicode等时，8位组合无法表示所有字符，因此一个字节可能需要16位甚至更多，在这种系统上，C++中的一个字节可能就不是代表8bit了，这是C++对字节的定义，这里我们一定不能搞混淆了。</p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16位</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32位</td></tr></tbody></table><p>其他字符集用于扩展字符集，如wchar_t、char16_t、char32_t。wchar_t类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型char16_t和char32_t则为Unicode字符集服务。</p><h3 id="二-char数组和char指针的区别和联系"><a href="#二-char数组和char指针的区别和联系" class="headerlink" title="二.char数组和char指针的区别和联系"></a>二.char数组和char指针的区别和联系</h3><p>在C语言中，对字符串的操作主要有两种方式，一是字符数组(char[])，二是使用字符指针(char*)。</p><h4 id="1-char数组"><a href="#1-char数组" class="headerlink" title="1.char数组"></a>1.char数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'~'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c[] = <span class="string">"hello~"</span>;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] = <span class="string">"Hello~"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%lu\n"</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(c); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%lu\n"</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(ch); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, ch[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/06/19/char-string/1.png" class="" title="image"><p>这张图可以很明显看出来不同方式声明并初始化char数组的效果是不同的。</p><p>第一种 <code>char a[] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;~&#39;};</code> 声明了一个char数组，不知道分配多大空间，根据右边的字符数组初始化char数组来确定最终的分配空间，给了6个字符，分配了6个sizeof(char)；</p><p>第二种 <code>char c[] = &quot;hello~&quot;;</code> 也是声明了一个不知道分配多少空间的char数组，但使用字符串字面值(string literal)初始化char数组之后，实际分配的空间比我们看到的字符串面值的要多一个&lt;0x00&gt;，也表示为’\0’；</p><p>第三种 <code>char ch[10] = &quot;Hello~&quot;;</code>  声明了长度为10的char数组，<strong>编译器为该数组分配了10个单位的内存</strong>，然后初始化，多余没有用到的内存就用’\0’填充，如果初始化的字符串字面值长度比分配的内存长，则会报错。</p><p>但C语言不允许我们直接声明一个不知道会分配多少内存空间的char数组，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[];<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure><p>char[]经过初始化后就会变成有固定长度的char数组。</p><p>但这个时候我们如果想给char数组重新赋值，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>];</span><br><span class="line">ch = <span class="string">"World!"</span>;<span class="comment">// invalid</span></span><br><span class="line"><span class="comment">// error: array type 'char [6]' is not assignable</span></span><br><span class="line"><span class="built_in">strcpy</span>(ch, <span class="string">"World!"</span>);<span class="comment">// valid</span></span><br></pre></td></tr></table></figure><p>我们要怎么去理解上面这个操作呢？</p><p>我记得我在大一学C语言的时候，老师讲过说，<strong>数组名可以理解为指向这个数组的指针</strong>。那既然是指针为什么不能给这个指针重新赋值呢？</p><p>很简单，数组名是数组名，指针是指针，他们是不能划等号的，老师说的是让你理解成指针，并不是说数组名就是指针！！！</p><p>有个很简单的方法可以证明，你就看<code>sizeof(a)</code>。</p><p>指针是指向一个内存地址的对象，无论是void <em>，char <em>还是int * ，C语言中指向各种数据的指针大小是一致的，在64位的机器上，</em></em>占8个字节**，32位的机器上是4个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] = <span class="string">"hello~"</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* pa = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(p)==%lu\n"</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(ch)==%lu\n"</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(pa)==%lu\n"</span>, <span class="keyword">sizeof</span>(pa));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(a)==%lu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(p)==8</span></span><br><span class="line"><span class="comment">// sizeof(ch)==10</span></span><br><span class="line"><span class="comment">// sizeof(pa)==8</span></span><br><span class="line"><span class="comment">// sizeof(a)==16</span></span><br></pre></td></tr></table></figure><p>通过看sizeof()的大小，我们可以发现数组名并不是指针，那数组名到底是什么呢？它和指针又有什么关系呢？</p><p>那我们不如来看一下他们的“庐山真面目”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p = ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" p ==%p\n"</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ch ==%p\n"</span>, ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;p ==%p\n"</span>, &amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;ch==%p\n"</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" a ==%p\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pa ==%p\n"</span>, pa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;a ==%p\n"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pa==%p\n"</span>, &amp;pa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  p ==0x7ffeec66e8f4</span></span><br><span class="line"><span class="comment">// ch ==0x7ffeec66e8f4</span></span><br><span class="line"><span class="comment">// &amp;p ==0x7ffeec66e8a8</span></span><br><span class="line"><span class="comment">// &amp;ch==0x7ffeec66e8f4</span></span><br><span class="line"><span class="comment">//  a ==0x7ffeec66e8e0</span></span><br><span class="line"><span class="comment">// pa ==0x7ffeec66e8e0</span></span><br><span class="line"><span class="comment">// &amp;a ==0x7ffeec66e8e0</span></span><br><span class="line"><span class="comment">// &amp;pa==0x7ffeec66e8a0</span></span><br></pre></td></tr></table></figure><p>通过上面的打印结果我们可以看到，指针指向的地址和存放这个指针的地址是不一样的，而数组名指向的地址和数组名所在的地址是一样的……听着有点绕，其实已经很清楚了：</p><p>ch数组名代表的就是char数组第一个元素地址的值，但<strong>它不是指针</strong>，只是对应着（而不是指向）一块内存，是个常量(const)，常量是不可以修改的，所以我们是不能给这个常量去赋值。</p><p>简言之，<strong>数组名是一个地址，而非指针，虽然两者数值相同，但是不是同一个东西。</strong></p><p><strong>所以我们要记住，数组名只是代表数组第一个元素的地址的值，比如数组 <code>int a[10]</code>，<code>a</code>实际上就是 <code>&amp;a[0]</code>，它只是一个值，就像 <code>5</code> 这类东西一样，是不能作为左值的，不能给它赋值。</strong></p><p>我想把数组名的真相继续深究下去，就拿<code>char ch[10];</code>来说，ch不是「指向char的指针」类型，ch是「长度为10的char数组」类型；&amp;ch也不是「指向指针的指针」类型，而是「指向长度为10的char数组的指针」类型，虽然ch和&amp;ch的值是一样的，但他们是完全不同的类型，不可混淆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p1 = &amp;ch;<span class="comment">// invalid</span></span><br><span class="line"><span class="comment">// error: cannot initialize a variable of type 'char *' with an rvalue of type 'char (*)[10]'</span></span><br><span class="line"><span class="keyword">char</span>* p1 = &amp;ch[<span class="number">0</span>];<span class="comment">// valid</span></span><br><span class="line"><span class="keyword">char</span> (*p2)[<span class="number">10</span>] = &amp;ch;<span class="comment">// valid:p2是指向长度为10的char数组的指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, p2[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, (*p2)[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>虽然p2看起来像个二维数组，但我们还是要弄清楚他们的本质是不一样的，因为二维数组是数组的数组，而p2是数组的指针。</p><p>以上，除了<strong>sizeof(ch)</strong>和<strong>&amp;ch</strong>以外，其余的情况下，ch可以看成指向首地址的指针，可以看成char* 类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch[<span class="number">1</span>] = <span class="string">'E'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hEllo~</span></span><br></pre></td></tr></table></figure><h4 id="2-char指针"><a href="#2-char指针" class="headerlink" title="2.char指针"></a>2.char指针</h4><p>当我们使用char指针来定义一个字符串的时候，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p0 = <span class="string">"C++!!!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// warning: conversion from string literal to 'char *' is deprecated [-Wc++11-compat-deprecated-writable-strings]</span></span><br></pre></td></tr></table></figure><p>把这个warning转换成中文的意思是：“警告：不建议将字符串文字转换为’char *’[-Wc ++ 11-compat-deprecated-writable-strings]”。</p><p>虽说是个warning，说明执行是没有问题的，但后面提示说这个语法不推荐使用(deprecated)，这是为什么呢？</p><p>在继续讲之前我们需要说一下C/C++的内存分配，内存分配是面试时候面试官问的高频问题。当我们定义一个字符串数组char a[]，这是属于静态分配，建立的静态数组，它是在<strong>栈空间分配内存</strong>；而动态方式使用new或malloc，是在<strong>堆上分配内存</strong>。string literal(字符串字面值)是常量(const)，常量存储在<strong>常量区</strong>，常量的字符串一般存在常量区，程序结束后由系统释放。</p><p>我们再回过头来看上面的定义和初始化语句：<code>char* p0 = &quot;C++!!!&quot;;</code> p0在栈上，而字符串常量”C++!!!\0“在常量区。我们可以这么理解，我们在栈上定义了一个指针p0，这个时候并没有为其分配内存，同时在常量区分配了一块内存放字符串常量”C++!!!\0”，然后让p0指向常量区这块内存的首地址。听起来没有问题，但为什么会有warning？</p><p>主要问题还是在于等号右边的这个string literal，它是个const啊，<a href="https://raoxuntian.github.io/2020/06/03/learnCpp-const/">const是不能修改的</a> (可以回顾一下这篇文章)。我们不能用一个简单的pointer去指向一个const，得用pointer to const，这样指针所指向的对象才是常量，不可变的。</p><p>所以正确的写法应该是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p0 = <span class="string">"C++!!!"</span>;<span class="comment">// valid</span></span><br><span class="line">p0 = <span class="string">"JAVA~"</span>;<span class="comment">// valid: 这里并没有修改*p0的值，而是把p0重新指向了"JAVA~"</span></span><br><span class="line">*p0 = <span class="string">"Python..."</span>;<span class="comment">// invalid: read-only variable is not assignable</span></span><br><span class="line">p0[<span class="number">1</span>] = <span class="string">'a'</span>;<span class="comment">// invalid: read-only variable is not assignable</span></span><br></pre></td></tr></table></figure><p>这种情况下我们并不好去修改p0所指向的字符串的值，这个时候我们可以想起数组……</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[] = <span class="string">"Gooooo"</span>;</span><br><span class="line"><span class="comment">//char* p1 = &amp;ch;// invalid</span></span><br><span class="line"><span class="comment">//char* p1 = ch;// valid: 当数组名作为右值的时候，我们可以简单理解为数组的指针</span></span><br><span class="line"><span class="keyword">char</span>* p1 = &amp;ch[<span class="number">0</span>];<span class="comment">// valid</span></span><br><span class="line">p1[<span class="number">3</span>] = <span class="string">'O'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch);</span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"Golang"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %s\n"</span>, p1, ch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// GooOoo</span></span><br><span class="line"><span class="comment">// Golang Golang</span></span><br></pre></td></tr></table></figure><h3 id="三-string和char的区别"><a href="#三-string和char的区别" class="headerlink" title="三.string和char的区别"></a>三.string和char的区别</h3><p>刚刚我们谈了关于char的很多东西，那么string和char又有什么关系呢？</p><p>在C++ primer一书中有介绍说，char字符属于C++的基本内置类型，包括前面说的wchar_t、char16_t和char32_t，都是primitive type（原始类型）。而在C++里。string是作为标准库类型，成为了一个类(class)，封装在string头文件里，当我们使用string类时，需要先include&lt; string &gt;，string表示的是可变长的字符序列。</p><p>关于string的语法我后面会再写一篇文章来记录，就不在此多说了，发表一下个人看法，有了string类之后，可以弥补之前char指针和char数组在字符串相关操作的不足，然而，熟悉C++语法的人也知道，string类也不只是封装了个char数组这么简单。虽说string中重载了各种操作符，还有各种find函数，给我们带来便利，但我们也不能忽视在复杂环境或多线程下频繁处理string类时的安全性，string不是万能的，不管是在C++还是Python当中，你使用时没有发生错误只是因为你只走到了这一步，并不意味它真的是完美(perfect)的。</p><p>顺带说一笔Python中的string吧，Python中有五个标准的数据类型：</p><ul><li><p>Numbers（数字）</p></li><li><p>String（字符串）</p></li><li><p>List（列表）</p></li><li><p>Tuple（元组）</p></li><li><p>Dictionary（字典）</p></li></ul><p>  没错。Python没有char类型，所以在Python中，<code>str = &quot;Hello~&quot;</code>和<code>str = &#39;Hello~&#39;</code>是没有区别的，str都是字符串，而在C/C++中，字符串或者char数组对应的需要用双引号来表示，而字符对应的需要用单引号来表示，如果你<code>char c = &quot;C&quot;</code>，那这就是错的。</p><h3 id="四-相关文章"><a href="#四-相关文章" class="headerlink" title="四.相关文章"></a>四.相关文章</h3><ul><li><a href="https://blog.csdn.net/Sylvernass/article/details/44604459" target="_blank" rel="noopener">C++中char类型详解</a></li><li><a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html" target="_blank" rel="noopener">字符集和字符编码（Charset &amp; Encoding）</a></li><li><a href="https://segmentfault.com/q/1010000003793687" target="_blank" rel="noopener">C 语言里为什么这样初始化字符串是错误的？</a></li><li><a href="https://blog.csdn.net/self_mind/article/details/49705227" target="_blank" rel="noopener">char数组与char指针的区别与联系</a></li><li><a href="https://www.zhihu.com/question/41805285" target="_blank" rel="noopener">知乎：c中，数组名跟指针有区别吗？</a></li><li><a href="https://blog.csdn.net/wangtie_123/article/details/9629111" target="_blank" rel="noopener">Conversion from string literal to ‘char *’ is deprecated 问题原因</a></li><li><a href="https://blog.csdn.net/u011555996/article/details/79496156" target="_blank" rel="noopener">C++ 数组在内存中的分配</a></li><li><a href="https://blog.csdn.net/yejinxiong001/article/details/78436310" target="_blank" rel="noopener">c/c++中string与char的区别</a></li></ul><h2 id="五-文章中的源码"><a href="#五-文章中的源码" class="headerlink" title="五.文章中的源码"></a>五.文章中的源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">// ASCII码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">128</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%3d -&gt; %c] "</span>, i, i);</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> a[] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'~'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c[] = <span class="string">"hello~"</span>;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] = <span class="string">"Hello~"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%lu\n"</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(c); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%lu\n"</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(ch); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, ch[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">"world"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ch, <span class="string">"world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%s %s\n"</span>, a, ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p %p %p\n"</span>, a, c, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] = <span class="string">"hello~"</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* pa = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(p)==%lu\n"</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(ch)==%lu\n"</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(pa)==%lu\n"</span>, <span class="keyword">sizeof</span>(pa));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(a)==%lu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line">p = ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" p ==%p\n"</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ch ==%p\n"</span>, ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;p ==%p\n"</span>, &amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;ch==%p\n"</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" a ==%p\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pa ==%p\n"</span>, pa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;a ==%p\n"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;pa==%p\n"</span>, &amp;pa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//char* p1 = &amp;ch;</span></span><br><span class="line"><span class="keyword">char</span>* p1 = &amp;ch[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">char</span> (*p2)[<span class="number">10</span>] = &amp;ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, p2[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, (*p2)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">ch[<span class="number">1</span>] = <span class="string">'E'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//char* p0 = "C++!!!";</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p0 = <span class="string">"C++!!!"</span>;</span><br><span class="line">p0 = <span class="string">"JAVA~"</span>;</span><br><span class="line"><span class="comment">//*p0 = "Python...";</span></span><br><span class="line"><span class="comment">//p0[1] = 'a';</span></span><br><span class="line"><span class="keyword">char</span> ch[] = <span class="string">"Gooooo"</span>;</span><br><span class="line"><span class="comment">//char* p1 = &amp;ch[0];</span></span><br><span class="line"><span class="keyword">char</span>* p1 = ch;</span><br><span class="line">p1[<span class="number">3</span>] = <span class="string">'O'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch);</span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"Golang"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %s\n"</span>, p1, ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> char </tag>
            
            <tag> string </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie Tree</title>
      <link href="/2020/06/18/trie-tree/"/>
      <url>/2020/06/18/trie-tree/</url>
      
        <content type="html"><![CDATA[<h3 id="一-什么是Trie树"><a href="#一-什么是Trie树" class="headerlink" title="一.什么是Trie树"></a>一.什么是Trie树</h3><p><strong>Trie树</strong>，又叫<strong>字典树</strong>、<strong>前缀树（Prefix Tree）</strong>、<strong>单词查找树</strong> 或 <strong>键树</strong>，是一种多叉树结构。如下图：</p><img src="/2020/06/18/trie-tree/1.png" class="" title="TrieTree"><a id="more"></a><p>上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质：</p><p>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。<br>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>每个节点的所有子节点包含的字符互不相同。<br>通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。</p><p>可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。</p><h3 id="二-Trie树的优缺点"><a href="#二-Trie树的优缺点" class="headerlink" title="二.Trie树的优缺点"></a>二.Trie树的优缺点</h3><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>插入和查询的效率很高，都为O(m)，其中 m 是待插入/查询的字符串的长度。</p><p>关于查询，会有人说 hash 表时间复杂度是O(1)不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。<br>Trie树中不同的关键字不会产生冲突。</p></li><li><p>Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。</p></li><li><p>Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。</p></li><li><p>Trie树可以对关键字按<strong>字典序</strong>排序。</p></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。</li><li>空间消耗比较大。</li></ol><h3 id="三-Trie树的实现"><a href="#三-Trie树的实现" class="headerlink" title="三.Trie树的实现"></a>三.Trie树的实现</h3><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    Trie *child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        isWord=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; ++i)</span><br><span class="line">            child[i]=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:<span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                t-&gt;child[c-<span class="string">'a'</span>]=<span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;isWord=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:<span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="四-Trie树的应用"><a href="#四-Trie树的应用" class="headerlink" title="四.Trie树的应用"></a>四.Trie树的应用</h3><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p><p>这是一道easy级别的题目，编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p>示例 1:</p><p><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</code><br><code>输出: &quot;fl&quot;</code></p><p>示例 2:</p><p><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</code><br><code>输出: &quot;&quot;</code><br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 a-z 。</p><p>常规方法，也就是暴力法，假设最短字符串长度为m，字符串数组长度为n，那么时间复杂度就是O(m*n)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; ; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> str: strs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;=str.<span class="built_in">size</span>() || str[i]!=strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> str.substr(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们引用Trie树这一数据结构来解决这道题目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    Trie *child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        isWord=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; ++i)</span><br><span class="line">            child[i]=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:<span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                t-&gt;child[c-<span class="string">'a'</span>]=<span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;isWord=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:<span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;child[c-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  判断当前这个节点是否是整个树的前缀，也就是孩子只有一个字母 */</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">isPrefixNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> c=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;child[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                c=(<span class="keyword">char</span>) (<span class="string">'a'</span>+i);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt&gt;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt==<span class="number">1</span>?c:<span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">searchMaxPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        Trie *t=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span> c = t-&gt;isPrefixNode();</span><br><span class="line">        <span class="keyword">while</span> (!t-&gt;isWord &amp;&amp; c!=<span class="string">'\0'</span>) &#123;</span><br><span class="line">            res+=c;</span><br><span class="line">            t=t-&gt;child[c-<span class="string">'a'</span>];</span><br><span class="line">            c=t-&gt;isPrefixNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        Trie *root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str:strs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str==<span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            root-&gt;insert(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;searchMaxPrefix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>算上构建Trie树的时间，可能还不如暴力法快，但在实际情况中，面向更海量的数据，如果将不用vector<string>来存储这些字符串，而是用一棵Trie树来存储这些字符串，那么无论是空间复杂度还是寻找最长前缀的时间复杂度，都将更优。</p><p>Trie树还有的一些应用：</p><h4 id="1、字符串检索"><a href="#1、字符串检索" class="headerlink" title="1、字符串检索"></a>1、字符串检索</h4><p>检索/查询功能是Trie树最原始的功能。思路就是从根节点开始一个一个字符进行比较：</p><ul><li>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</li><li>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isKey;   <span class="comment">// 标记该节点是否代表一个关键字</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、词频统计"><a href="#2、词频统计" class="headerlink" title="2、词频统计"></a>2、词频统计</h4><p>Trie树常被搜索引擎系统用于文本词频统计 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;   <span class="comment">// 记录该节点代表的单词的个数</span></span><br><span class="line">    trie_node *children[<span class="number">26</span>]; <span class="comment">// 各个子节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路：为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。</p><p>注意：第一、第二种应用也都可以用 hash table 来做。</p><h4 id="3、字符串排序"><a href="#3、字符串排序" class="headerlink" title="3、字符串排序"></a>3、字符串排序</h4><p>Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。</p><h4 id="4、前缀匹配"><a href="#4、前缀匹配" class="headerlink" title="4、前缀匹配"></a>4、前缀匹配</h4><p>例如：找出一个字符串集合中所有以ab开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以a-&gt;b-&gt;开头的路径上的关键字即可。</p><p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p><h4 id="5、作为其他数据结构和算法的辅助结构"><a href="#5、作为其他数据结构和算法的辅助结构" class="headerlink" title="5、作为其他数据结构和算法的辅助结构"></a>5、作为其他数据结构和算法的辅助结构</h4><p>如后缀树，AC自动机等。</p><h3 id="五-相关文章"><a href="#五-相关文章" class="headerlink" title="五.相关文章"></a>五.相关文章</h3><ul><li><a href="https://blog.csdn.net/lisonglisonglisong/article/details/45584721" target="_blank" rel="noopener">https://blog.csdn.net/lisonglisonglisong/article/details/45584721</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> data structure </tag>
            
            <tag> trie tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Car Information Management System (车辆信息管理系统) with C</title>
      <link href="/2020/06/17/c-carIMS/"/>
      <url>/2020/06/17/c-carIMS/</url>
      
        <content type="html"><![CDATA[<p>这几天在家接了个私活，帮一个本科生做C语言课设…难度虽然不大，但回想起我大一时C语言的期末考试，又想起前一阵子看到清华贵系大一C语言课设——雷课堂，看着不同学校不同的标准，感慨万千…</p><p>开发环境 Linux + gcc 9.0</p><p>无GUI界面</p><p>数据结构用的是多层次的十字链表，数据存储在文件当中。</p><img src="/2020/06/17/c-carIMS/1.png" class="" title="image"><a id="more"></a><p>主要的操作就是定义结构体，链表的增删查改，文件的读写，模糊查询用到KMP算法。</p><p>C定义结构体可以和C++风格一致，但也有属于C自己风格的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OrderInfo</span>    // 租车订单信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">20</span>];            <span class="comment">// 订单编号</span></span><br><span class="line">    <span class="keyword">char</span> clientName[<span class="number">20</span>];    <span class="comment">// 客户姓名</span></span><br><span class="line">    <span class="keyword">char</span> clientId[<span class="number">20</span>];      <span class="comment">// 客户身份证号码</span></span><br><span class="line">    <span class="keyword">char</span> clientPhone[<span class="number">20</span>];<span class="comment">// 客户电话号码</span></span><br><span class="line">    <span class="keyword">int</span> carNo;          <span class="comment">// 租用的车辆编号</span></span><br><span class="line">    <span class="keyword">char</span> startTime[<span class="number">18</span>];     <span class="comment">// 取车时间</span></span><br><span class="line">    <span class="keyword">float</span> deposit;          <span class="comment">// 押金</span></span><br><span class="line">    <span class="keyword">char</span> planEndTime[<span class="number">18</span>];   <span class="comment">// 预约还车时间</span></span><br><span class="line">    <span class="keyword">char</span> actualEndTime[<span class="number">18</span>]; <span class="comment">// 实际还车时间</span></span><br><span class="line">    <span class="keyword">float</span> planCost;         <span class="comment">// 应缴费用</span></span><br><span class="line">    <span class="keyword">float</span> actualCost;       <span class="comment">// 实缴费用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OrderInfo</span>* <span class="title">next</span>;</span> <span class="comment">// 下一个订单</span></span><br><span class="line">&#125; order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CarInfo</span>  // 车辆基本信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> carNo;          <span class="comment">// 车辆编号</span></span><br><span class="line">    <span class="keyword">char</span> carId[<span class="number">3</span>];         <span class="comment">// 车辆类型编码   '1'-'5'</span></span><br><span class="line">    <span class="keyword">char</span> license[<span class="number">10</span>];   <span class="comment">// 车牌号 </span></span><br><span class="line">    <span class="keyword">char</span> carName[<span class="number">20</span>];   <span class="comment">// 车辆名称</span></span><br><span class="line">    <span class="keyword">char</span> carWay[<span class="number">10</span>];    <span class="comment">// 排档方式</span></span><br><span class="line">    <span class="keyword">float</span> price;        <span class="comment">// 每日租金</span></span><br><span class="line">    <span class="keyword">char</span> status[<span class="number">3</span>];        <span class="comment">// 出租状态 'y' 'n'</span></span><br><span class="line">    order* firstOrder;  <span class="comment">// 此车辆的订单追踪</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CarInfo</span>* <span class="title">next</span>;</span><span class="comment">// 指向同类型的下一个车辆</span></span><br><span class="line">&#125; car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CarType</span>  // 车辆分类信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> carId[<span class="number">3</span>];         <span class="comment">// 车辆类型编码   '1'-'5'</span></span><br><span class="line">    <span class="keyword">char</span> type[<span class="number">20</span>];      <span class="comment">// 车辆类型名称</span></span><br><span class="line">    <span class="keyword">int</span> count;          <span class="comment">// 库存数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CarType</span>* <span class="title">next</span>;</span>      <span class="comment">// 下一个车辆分类信息</span></span><br><span class="line">    car* sub;           <span class="comment">// 此类型车辆的具体车辆信息</span></span><br><span class="line">&#125; cartype;</span><br></pre></td></tr></table></figure><p>链表的增删查改，插入的时候一般有头插法和尾插法，就不赘述了。</p><p>查询的时候我想用hash结构，但发现C里面并没有哈希表，得自己造轮子……</p><p>而且C也没有动态数组……没有容器……都是定义指针、分配地址</p><p>说到分配地址，面试的时候面试官可能就会问new和malloc关键词有什么区别？</p><p>很显然，new是C++的关键词，而malloc是C的关键词。</p><p>new一个对象后一般用delete释放内存，malloc用free释放内存。</p><p>new的时候不需要指定内存块的大小，编译器会帮你计算，而malloc需要输入内存块大小，一般用sizeof(obj)。</p><p>具体的区别如下：</p><blockquote><ol start="0"><li>属性</li></ol><p>new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</p><ol><li>参数</li></ol><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p><ol start="2"><li>返回类型</li></ol><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p><ol start="3"><li>分配失败</li></ol><p>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p><ol start="4"><li><p>自定义类型</p><p> new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。</p><p> malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p></li><li><p>重载</p></li></ol><p>C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</p><ol start="6"><li>内存区域</li></ol><p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p></blockquote><p>关于KMP算法，也是面试时候的一个难点，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP算法的辅助数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">(<span class="keyword">char</span> *T,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模糊查询的核心算法 KMP算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[MAX_LINE_SIZE];</span><br><span class="line">    Next(T,next);<span class="comment">//根据模式串T,初始化next数组</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="comment">//j==0:代表模式串的第一个字符就和当前测试的字符不相等；S[i-1]==T[j-1],如果对应位置字符相等，两种情况下，指向当前测试的两个指针下标i和j都向后移</span></span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span> || S[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];<span class="comment">//如果测试的两个字符不相等，i不动，j变为当前测试字符串的next值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;<span class="built_in">strlen</span>(T)) &#123;<span class="comment">//如果条件为真，说明匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-(<span class="keyword">int</span>)<span class="built_in">strlen</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言文件读取这一块我感觉还是比C++和python麻烦，用fopen选择文件路径和打开的模式(mode)，这里想记录一下，文件读写结构体数据，fwrite()和fread()，如果结构体里有指针，那么这个结构体存入文件再读取的话，指针指向的地址可能已经释放了，成了野指针，所以从文件里读取结构体后需要对指针重新赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取车辆类型信息csv</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_car_type_csv</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cartype* p;</span><br><span class="line">    p = p_type_head = (cartype*) <span class="built_in">malloc</span> (CARTYPESIZE);</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *filePath = <span class="string">"./output/车辆分类信息表_.csv"</span>;</span><br><span class="line">    fp = fopen(filePath, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[打开文件『 %s 』失败...]\n"</span>, filePath);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[正在读取%s...]\n"</span>, filePath);</span><br><span class="line">    <span class="keyword">char</span> buff[MAX_LINE_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *info;</span><br><span class="line">    <span class="keyword">char</span> *tok;</span><br><span class="line">    info = fgets(buff, MAX_LINE_SIZE, fp);   <span class="comment">// 读取csv内容到buff</span></span><br><span class="line">    <span class="comment">//printf("%s\n", buff);</span></span><br><span class="line">    tok = strtok(buff, <span class="string">","</span>);</span><br><span class="line">    tok = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">    tok = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">    <span class="keyword">while</span> ((info = fgets(buff, MAX_LINE_SIZE, fp)) != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("%s\n", buff);</span></span><br><span class="line">        cartype* cur;</span><br><span class="line">        cur = (cartype*) <span class="built_in">malloc</span> (CARTYPESIZE+<span class="number">1</span>);</span><br><span class="line">        tok = strtok(buff, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (tok == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(cur-&gt;carId, tok);</span><br><span class="line">        tok = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (tok == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(cur-&gt;type, tok);</span><br><span class="line">        tok = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span> (tok == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        cur-&gt;count = atoi(tok);</span><br><span class="line">        cur-&gt;sub = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;next = cur;</span><br><span class="line">        p = cur;</span><br><span class="line">        show_car_type(cur);</span><br><span class="line">        <span class="comment">//printf("%s | %s | %d\n", cur-&gt;carId, cur-&gt;type, cur-&gt;count);</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;sub = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s读取成功...]\n"</span>, filePath);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言太久没接触了，这次写代码感觉经常出现内存方面的问题，通过排查发现绝大多数原因还是指针没有分配地址或者指针指向无效的地址这些原因导致的，所以写C的时候，一定要认真细致啊~</p><p>代码: <a href="https://github.com/RaoXuntian/c_carIMS" target="_blank" rel="noopener">https://github.com/RaoXuntian/c_carIMS</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C++关键字之static</title>
      <link href="/2020/06/05/learnCpp-static/"/>
      <url>/2020/06/05/learnCpp-static/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是static"><a href="#1-什么是static" class="headerlink" title="1.什么是static"></a>1.什么是static</h3><p>static 是 C/C++ 中很常用的修饰符，它被用来控制变量的存储方式和可见性。</p><h4 id="1-1-static的引入"><a href="#1-1-static的引入" class="headerlink" title="1.1.static的引入"></a>1.1.static的引入</h4><p>我们知道在函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义为全局的变量，但定义一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数控制）。static 关键字则可以很好的解决这个问题。</p><p>另外，在 C++ 中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。</p><a id="more"></a><h4 id="1-2-静态数据存储"><a href="#1-2-静态数据存储" class="headerlink" title="1.2.静态数据存储"></a>1.2.静态数据存储</h4><p><strong>全局（静态）存储区</strong>：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</p><p>在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。</p><p>这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main() 函数前的全局数据声明和定义处。</p><p>静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的”尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。</p><p>static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p><p><strong>优势：</strong>可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。</p><h3 id="2-static的作用"><a href="#2-static的作用" class="headerlink" title="2.static的作用"></a>2.static的作用</h3><h4 id="2-1-全局静态变量"><a href="#2-1-全局静态变量" class="headerlink" title="2.1.全局静态变量"></a>2.1.全局静态变量</h4><p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。</p><p>内存中的位置：静态存储区，在整个程序运行期间一直存在。</p><p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。</p><p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p><h4 id="2-2-局部静态变量"><a href="#2-2-局部静态变量" class="headerlink" title="2.2.局部静态变量"></a>2.2.局部静态变量</h4><p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p><p>内存中的位置：静态存储区。</p><p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。</p><p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">count_calls</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure><h4 id="2-3-静态函数"><a href="#2-3-静态函数" class="headerlink" title="2.3.静态函数"></a>2.3.静态函数</h4><p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p><p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。</p><p>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰。</p><h4 id="2-4-类的静态成员"><a href="#2-4-类的静态成员" class="headerlink" title="2.4.类的静态成员"></a>2.4.类的静态成员</h4><p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用，而且不需要生成对象就可以访问该成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> y;      <span class="comment">//普通变量成员</span></span><br><span class="line">  <span class="keyword">int</span> &amp;r;     <span class="comment">//引用成员变量</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> d;    <span class="comment">//常量成员变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c;   <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">A():y(<span class="number">1</span>), r(y), d(<span class="number">3</span>)&#123;&#125;;</span><br><span class="line">~A()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::c = <span class="number">1</span>;<span class="comment">// 初始化静态成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">A b;</span><br><span class="line">a.c=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 2</span></span><br><span class="line">b.c=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.c &lt;&lt; <span class="string">" "</span> &lt;&lt; b.c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 3 3</span></span><br><span class="line">A::c=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.c &lt;&lt; <span class="string">" "</span> &lt;&lt; b.c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 4 4</span></span><br><span class="line">A c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c.c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 4</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享。</strong>对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，<strong>静态变量不能使用构造函数初始化</strong>。</p><h4 id="2-5-类的静态函数"><a href="#2-5-类的静态函数" class="headerlink" title="2.5.类的静态函数"></a>2.5.类的静态函数</h4><p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p><p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running ~A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A::f();<span class="comment">// 调用类的静态函数，不需要对象名</span></span><br><span class="line">&#123;</span><br><span class="line">A a;</span><br><span class="line">a.f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"END of main"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">running f()</span><br><span class="line">running A()</span><br><span class="line">running f()</span><br><span class="line">running ~A()</span><br><span class="line">END of main</span><br></pre></td></tr></table></figure><p>在上面的程序中，类A的对象a在括号内是非静态的，所以出了括号之后，a的”生命“也就结束了。如果在括号内将类的对象声明为静态的会怎么样呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running ~A()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"running f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A::f();</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> A a;</span><br><span class="line">a.f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"END of main"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">running f()</span><br><span class="line">running A()</span><br><span class="line">running f()</span><br><span class="line">END of main</span><br><span class="line">running ~A()</span><br></pre></td></tr></table></figure><p>我们可以清晰地看到，a的析构函数是在main函数结束之后才调用的。这是因为，静态对象的范围是贯穿程序的生命周期。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul><li>（1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。</li><li>（2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</li><li>（3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</li><li>（4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。</li><li>（5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）</li></ul><h3 id="4-相关文章"><a href="#4-相关文章" class="headerlink" title="4.相关文章"></a>4.相关文章</h3><ul><li><a href="https://www.runoob.com/w3cnote/cpp-static-usage.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-static-usage.html</a></li><li><a href="https://blog.csdn.net/men_wen/article/details/64443040" target="_blank" rel="noopener">https://blog.csdn.net/men_wen/article/details/64443040</a></li><li><a href="https://light-city.club/sc/basic_content/static/" target="_blank" rel="noopener">https://light-city.club/sc/basic_content/static/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C++的指针与引用</title>
      <link href="/2020/06/04/pointer-and-reference/"/>
      <url>/2020/06/04/pointer-and-reference/</url>
      
        <content type="html"><![CDATA[<h3 id="1-指针与引用"><a href="#1-指针与引用" class="headerlink" title="1.指针与引用"></a>1.指针与引用</h3><h4 id="1-1指针和引用的区别"><a href="#1-1指针和引用的区别" class="headerlink" title="1.1指针和引用的区别"></a>1.1指针和引用的区别</h4><p>1.指针有自己的一块空间，而引用只是一个别名；</p><p>2.使用sizeof看一个指针的大小是4或8，而引用则是被引用对象的大小；</p><p>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</p><p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p><p>5.可以有const指针，但是没有const引用；</p><p>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</p><p>7.指针可以有多级指针（**p），而引用只有一级；</p><p>8.指针和引用使用++运算符的意义不一样；</p><p>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *pt = &amp;i, &amp;ri = i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//pt = 0x7ffee43d269c</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ri &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//ri = 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(pt) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// sizeof(pt) = 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(ri) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// sizeof(ri) = 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptt;<span class="comment">// 合法，但ptt为野指针，需要小心使用</span></span><br><span class="line"><span class="keyword">int</span> *pttt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//int &amp;rii;// 错误：引用必须初始化</span></span><br><span class="line"><span class="comment">//int &amp;riii = 1;// 错误：非const引用不能指向const</span></span><br><span class="line"><span class="comment">//上面语句实际的操作是分两步</span></span><br><span class="line"><span class="comment">//const int tmp = 1;</span></span><br><span class="line"><span class="comment">//int &amp;riii = tmp;// 这一步错误</span></span><br><span class="line"></span><br><span class="line">ri++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// i = 4</span></span><br><span class="line">(*pt)++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// i = 5</span></span><br><span class="line"><span class="comment">//*pt++;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; pt &lt;&lt; endl; // pt = 0x7ffee43d26a0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><h4 id="2-1引用概念"><a href="#2-1引用概念" class="headerlink" title="2.1引用概念"></a>2.1引用概念</h4><p><strong>引用</strong>(<strong>reference</strong>)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;<span class="comment">// refVal指向ival(是ival的另一个名字)</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;<span class="comment">// 报错：引用必须被初始化</span></span><br></pre></td></tr></table></figure><p>一般在初始化话变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序吧引用和它的初始值<strong>绑定</strong>(<strong>bind</strong>)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p><p><strong>引用即别名</strong></p><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p><p>定义一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">refVal = <span class="number">2</span>;<span class="comment">// 把2赋给refVal指向的对象，此处即是赋给了ival</span></span><br><span class="line"><span class="keyword">int</span> ii = refVal;<span class="comment">// 与ii = ival执行结果一样</span></span><br></pre></td></tr></table></figure><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valid:refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal;</span><br><span class="line"><span class="comment">// 利用与refVal绑定的对象的值初始化变量i</span></span><br><span class="line"><span class="keyword">int</span> i = refVal;<span class="comment">//valid:i被初始化为ival的值</span></span><br></pre></td></tr></table></figure><p>因为引用本事不是一个对象，所以不能定义引用的引用。</p><h4 id="2-2引用的定义"><a href="#2-2引用的定义" class="headerlink" title="2.2引用的定义"></a>2.2引用的定义</h4><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, i2 = <span class="number">2048</span>;<span class="comment">// i和i2都是int</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = i, r2 = i2;<span class="comment">// r是一个引用，与i绑定在一起，r2是int</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3;<span class="comment">// i3是int，ri是一个引用，与i3绑定在一起</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = i3, &amp;r4 = i2;<span class="comment">// r3和r4都是引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;refVal4 = <span class="number">10</span>;<span class="comment">// 错误：引用类型初始值必须是一个对象</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal5 = dval;<span class="comment">// 错误：此处引用类型的初始值必须是int型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;refVal4 = <span class="number">10</span>; <span class="comment">// valid</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;refVal5 = dval;<span class="comment">// valid</span></span><br></pre></td></tr></table></figure><h4 id="2-3左值引用"><a href="#2-3左值引用" class="headerlink" title="2.3左值引用"></a>2.3左值引用</h4><p>严格来说，当我们使用术语“引用(reference)”时，指的其实就是“左值引用(lvalue reference)”。</p><p>常规引用，一般表示对象的身份</p><h4 id="2-4右值引用"><a href="#2-4右值引用" class="headerlink" title="2.4右值引用"></a>2.4右值引用</h4><p>敬请期待。。。</p><h3 id="3-指针"><a href="#3-指针" class="headerlink" title="3.指针"></a>3.指针</h3><h4 id="3-1指针概念"><a href="#3-1指针概念" class="headerlink" title="3.1指针概念"></a>3.1指针概念</h4><p><strong>指针</strong>(<strong>pointer</strong>)是“指向(<strong>point to</strong>)”另外一种类型的复合类型。</p><p>与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。</p><ol><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li><li>指针无须在定义时赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li></ol><h4 id="3-2指针值"><a href="#3-2指针值" class="headerlink" title="3.2指针值"></a>3.2指针值</h4><p>指针的值（即地址）应该属于下列4种状态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p>试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法估计，因此程序猿必须清楚任意给定的指针是否有效。</p><p>尽管第2、3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。</p><h4 id="3-3空指针"><a href="#3-3空指针" class="headerlink" title="3.3空指针"></a>3.3空指针</h4><p><strong>空指针</strong>(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;<span class="comment">// 等价于int *p1 = 0;</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;<span class="comment">// 直接将p2初始化为字母常量0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;<span class="comment">// 等价于int *p3 = 0;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0x0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0x0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p3 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0x0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">long</span>)p1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>在效验一个指针是否为一个有效指针时，我们应该倾向于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip)</span><br></pre></td></tr></table></figure><p>为什么有人会用if(ip)这种方式校验一个指针非空，而且在C++中不会出现错误呢？而且现在很多人都会这样写。<br>原因是这样的，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define   NULL   pointer   value   */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>   NULL   </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span>   __cplusplus   </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span>   NULL      0   </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span>   </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span>   NULL      ((void   *)0)   </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//   NULL</span></span></span><br></pre></td></tr></table></figure><p>思考一道腾讯面试题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = (<span class="keyword">long</span>)(((<span class="keyword">int</span> *)<span class="number">0</span>)+<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>a = 8</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> b = (<span class="keyword">long</span>)(((<span class="keyword">int</span> *)<span class="number">8</span>)+<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>b = 24</p><h4 id="3-4野指针"><a href="#3-4野指针" class="headerlink" title="3.4野指针"></a>3.4野指针</h4><p>野指针不是空指针，是一个指向垃圾内存的指针。</p><p><strong>形成原因</strong></p><ol><li><p>指针变量没有初始化。</p><p>任何指针变量被刚创建时不会被自动初始化为<strong>NULL</strong>指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为<strong>NULL</strong>，要么让它指向合法的内存。例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="literal">NULL</span>;  </span><br><span class="line"><span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>指针被free或delete之后，没有设置NULL，让人误以为是合法指针。</p><p><strong>free</strong>和<strong>delete</strong>只是把指针所指向的内存给释放掉，但并没有把指针本身给清理掉。这时候的指针依然指向原来的位置，只不过这个位置的内存数据已经被毁尸灭迹，此时的这个指针指向的内存就是一个垃圾内存。但是此时的指针由于并不是一个<strong>NULL</strong>指针（在没有置为<strong>NULL</strong>的前提下），在做如下指针校验的时候：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>会逃过校验，此时的p不是一个NULL指针，也不指向一个合法的内存块，造成会面程序中指针访问的失败。</p></li><li><p>指针操作超越了变量的作用范围。</p><p>由于C/C++中指针有++操作，因而在执行该操作的时候，稍有不慎，就容易指针访问越界，访问了一个不该访问的内存，结果程序崩溃<br>另一种情况是指针指向一个临时变量的引用，当该变量被释放时，此时的指针就变成了一个野指针，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A *p;<span class="comment">// A为一个自定义对象  </span></span><br><span class="line">&#123;  </span><br><span class="line">    A a;  </span><br><span class="line">    p = &amp;a;<span class="comment">// 注意 a 的生命期 ，只在这个程序块中（花括号里面的两行），而不是整个test函数  </span></span><br><span class="line">&#125;  </span><br><span class="line">p-&gt;Func();<span class="comment">// p是“野指针”</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-相关文章"><a href="#4-相关文章" class="headerlink" title="4.相关文章"></a>4.相关文章</h3><ul><li><a href="https://blog.csdn.net/u014647208/article/details/53383223" target="_blank" rel="noopener">https://blog.csdn.net/u014647208/article/details/53383223</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C++关键字之const</title>
      <link href="/2020/06/03/learnCpp-const/"/>
      <url>/2020/06/03/learnCpp-const/</url>
      
        <content type="html"><![CDATA[<p>C++关键字之const</p><h3 id="1-const含义"><a href="#1-const含义" class="headerlink" title="1.const含义"></a>1.const含义</h3><p>const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。</p><h3 id="2-const作用"><a href="#2-const作用" class="headerlink" title="2.const作用"></a>2.const作用</h3><h4 id="2-1定义const常量"><a href="#2-1定义const常量" class="headerlink" title="2.1定义const常量"></a>2.1定义const常量</h4><p><code>const int* bufSize = 64;</code></p><h4 id="2-2便于进行类型检查"><a href="#2-2便于进行类型检查" class="headerlink" title="2.2便于进行类型检查"></a>2.2便于进行类型检查</h4><p>const*常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误。</p><a id="more"></a><h4 id="2-3可以保护别修饰的东西"><a href="#2-3可以保护别修饰的东西" class="headerlink" title="2.3可以保护别修饰的东西"></a>2.3可以保护别修饰的东西</h4><p>防止修改，起保护作用，增加程序健壮性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">i++; <span class="comment">//error!    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4为函数重载提供一个参考"><a href="#2-4为函数重载提供一个参考" class="headerlink" title="2.4为函数重载提供一个参考"></a>2.4为函数重载提供一个参考</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">           ......</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span>       </span>&#123;......&#125; <span class="comment">//一个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;......&#125; <span class="comment">//上一个函数的重载</span></span><br><span class="line">           ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-5可以节省空间，避免不必要的内存分配"><a href="#2-5可以节省空间，避免不必要的内存分配" class="headerlink" title="2.5可以节省空间，避免不必要的内存分配"></a>2.5可以节省空间，避免不必要的内存分配</h4><p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159         <span class="comment">//常量宏</span></span></span><br><span class="line"><span class="keyword">const</span> doulbe  Pi=<span class="number">3.14159</span>;  <span class="comment">//此时并未将Pi放入ROM中</span></span><br><span class="line">              ......</span><br><span class="line"><span class="keyword">double</span> i=Pi;   <span class="comment">//此时为Pi分配内存，以后不再分配！</span></span><br><span class="line"><span class="keyword">double</span> I=PI;  <span class="comment">//编译期间进行宏替换，分配内存</span></span><br><span class="line"><span class="keyword">double</span> j=Pi;  <span class="comment">//没有内存分配</span></span><br><span class="line"><span class="keyword">double</span> J=PI;  <span class="comment">//再进行宏替换，又一次分配内存！</span></span><br></pre></td></tr></table></figure><h4 id="2-6提高了效率"><a href="#2-6提高了效率" class="headerlink" title="2.6提高了效率"></a>2.6提高了效率</h4><p>可以很方便地进行参数的调整和修改，同宏定义一样，可以做到不变则已，一变都变。</p><p>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</p><h3 id="3-const使用"><a href="#3-const使用" class="headerlink" title="3.const使用"></a>3.const使用</h3><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰函数相关，包括修饰函数参数和函数返回值；</li><li>修饰类成员函数，说明该成员函数内不能修改成员变量。</li></ol><h4 id="3-1修饰变量"><a href="#3-1修饰变量" class="headerlink" title="3.1修饰变量"></a>3.1修饰变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>; </span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> bufSize1 = <span class="number">1024</span>; </span><br><span class="line"><span class="comment">// 以上两种定义形式在本质上是一样的，const修饰的类型为int的变量是不可变的</span></span><br><span class="line">bufSize = <span class="number">1024</span><span class="comment">// 错误：试图向const int对象写值，不能改变bufSize</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = a;<span class="comment">// ci=64</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cis = <span class="keyword">sizeof</span>(a);<span class="comment">// cis=4</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;<span class="comment">// 错误：k是一个未经初始化的变量</span></span><br></pre></td></tr></table></figure><h4 id="3-2修饰指针"><a href="#3-2修饰指针" class="headerlink" title="3.2修饰指针"></a>3.2修饰指针</h4><p>将const用于指针有一些很微妙的地方（指针本身看上去就很微妙），我们将详细探讨一下用两种不同的方式将const关键字用于指针。</p><h5 id="3-2-1-pointer-to-const"><a href="#3-2-1-pointer-to-const" class="headerlink" title="3.2.1 pointer to const"></a>3.2.1 pointer to const</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pt = &amp;age;<span class="comment">// a pointer to const int</span></span><br><span class="line"><span class="comment">// 该声明指出，pt指向一个const int(这里是17)，因此不能用pt来改变这个值。</span></span><br><span class="line"><span class="comment">// 换句话说，*pt的值为const，不能修改。</span></span><br><span class="line"></span><br><span class="line">(*pt)++;<span class="comment">// 错误：指针pt指向的对象是const int</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; *pt<span class="comment">// 错误：同上</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 现在来看一个微妙的问题。</span></span><br><span class="line"><span class="comment">// pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。</span></span><br><span class="line">*pt = <span class="number">23</span>;<span class="comment">// 错误：指针pt指向的对象是const int</span></span><br><span class="line">age = <span class="number">23</span>;<span class="comment">// valid:beacause age is not declared to be const</span></span><br></pre></td></tr></table></figure><h5 id="3-2-2-const-pointer"><a href="#3-2-2-const-pointer" class="headerlink" title="3.2.2 const pointer"></a>3.2.2 const pointer</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sloth = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ps = &amp;sloth;<span class="comment">// a pointer to const int</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> finger = &amp;sloth;<span class="comment">// a const pointer to int</span></span><br><span class="line"><span class="comment">// finger只能指向sloth，但允许使用finger来修改sloth的值。</span></span><br><span class="line"><span class="comment">// ps不能修改sloth的值，但允许ps指向另一个位置。</span></span><br><span class="line">finger = &amp;age;<span class="comment">// invalid</span></span><br><span class="line">*finger = <span class="number">5</span>;<span class="comment">// valid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简言之：finger和*ps都是const，而*finger和ps不是</span></span><br></pre></td></tr></table></figure><h5 id="3-2-3-summary"><a href="#3-2-3-summary" class="headerlink" title="3.2.3 summary"></a>3.2.3 summary</h5><ul><li><p>指针所指向的内容是常量不可变。<br><code>const int *pt;</code></p></li><li><p>指针本身是常量不可变。<br><code>int * const pt;</code></p></li><li><p>两者都不可变。<br><code>const int * const pt;</code></p></li></ul><p><strong>const在*前面，对象是const；</strong><br><strong>const在*后面，指针是const。</strong></p><table><thead><tr><th align="left">Pointers and constants</th><th align="left">int i;</th><th align="left">const int ci = 3;</th></tr></thead><tbody><tr><td align="left">int *ip;//可以通过ip修改</td><td align="left">ip = &i;</td><td align="left">ip = &ci;  // ERROR!</td></tr><tr><td align="left">const int *cip;//不可以通过cip修改</td><td align="left">cip = &i;</td><td align="left">cip = &ci;</td></tr></tbody></table><blockquote><p><strong>尽可能使用const</strong></p><p>将指针参数声明为指向常量数据的指针有两条理由：</p><ul><li>这样可以避免由于无意间修改数据而导致的编程错误。</li><li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。</li></ul><p>如果条件允许，则应该将指针形参声明为指向const的指针。</p></blockquote><h4 id="3-3修饰引用"><a href="#3-3修饰引用" class="headerlink" title="3.3修饰引用"></a>3.3修饰引用</h4><p>可以把引用绑定到const对象上，就像绑定到其它对象上一样，我们称之为对<strong>常量的引用</strong>(<strong>reference to const</strong>)。</p><p>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;<span class="comment">// 正确：引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">// 错误：r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;<span class="comment">// 错误：试图让一个非常量引用(r2)指向一个常量对象(ci)</span></span><br></pre></td></tr></table></figure><p>因为不允许直接为ci赋值，当然也不能通过引用去改变ci。因此，对r2的初始化是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确的。</p><blockquote><p><strong>术语：常量引用是对const的引用</strong></p><hr><p>c++程序猿们经常把词组”对const的引用“简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。</p><p>严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于c++语言并不允许随意改变引用所绑定的对象，所以从这层意思上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。</p></blockquote><ul><li>指向常量的引用(reference to const)</li><li>没有const reference，因为引用本身就是const pointer</li></ul><p><strong>对const的引用可能引用一个并非const的对象</strong></p><p>必须认识到，<strong>常量引用仅对引用可参与的操作做出了限定</strong>，对应引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i; <span class="comment">// 引用r1绑定对象i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;<span class="comment">// r2也绑定对象i，但不允许通过r2修改i的值</span></span><br><span class="line">r1 = <span class="number">0</span>;<span class="comment">// r1并非常量，i的值修改为0</span></span><br><span class="line">r2 = <span class="number">0</span>;<span class="comment">// 错误：r2是一个常量引用</span></span><br></pre></td></tr></table></figure><h4 id="3-4修饰函数相关"><a href="#3-4修饰函数相关" class="headerlink" title="3.4修饰函数相关"></a>3.4修饰函数相关</h4><h5 id="3-4-1修饰函数参数"><a href="#3-4-1修饰函数参数" class="headerlink" title="3.4.1修饰函数参数"></a>3.4.1修饰函数参数</h5><ol><li><p>传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)</p><p><code>void function(const int Var);</code></p></li><li><p>参数指针所指内容为常量不可变</p><p><code>void function(const char* Var);</code></p></li><li><p>参数指针本身为常量不可变(也无意义，因为char* Var也是形参)</p><p><code>void function(char* const Var);</code></p></li><li><p>参数为引用，为了增加效率同时防止修改。修饰引用参数时：</p><p><code>void function(const Class&amp; Var); //引用参数在函数内不可以改变</code></p><p><code>void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变</code></p></li></ol><p>这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的，他禁止对引用的对象的一切修改，唯一不同的是按值传递会先建立一个类对象的副本， 然后传递过去,而它直接传递地址，所以这种传递比按值传递更有效。另外只有引用的const传递可以传递一个临时对象，因为临时对象都是const属性，且是不可见的，他短时间存在一个局部域中，所以不能使用指针，只有引用的const传递能够捕捉到这个家伙。</p><h5 id="3-4-2修饰函数返回值"><a href="#3-4-2修饰函数返回值" class="headerlink" title="3.4.2修饰函数返回值"></a>3.4.2修饰函数返回值</h5><p> const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。</p><ol><li><p><code>const int fun1()</code>    </p><p>   //这个其实无意义，因为参数返回本身就是赋值。</p></li><li><p><code>const int * fun2()</code></p><p>   //调用时 const int *pValue = fun2();<br>   //我们可以把fun2()看作成一个变量，即指针内容不可变。</p></li><li><p><code>int* const fun3()</code></p><p>   //调用时 int * const pValue = fun2();<br>   //我们可以把fun2()看作成一个变量，即指针本身不可变。</p></li></ol><p><strong><em>一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。</em></strong>原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp; test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。</p><h4 id="3-5修饰类成员函数"><a href="#3-5修饰类成员函数" class="headerlink" title="3.5修饰类成员函数"></a>3.5修饰类成员函数</h4><h5 id="3-5-1-const修饰成员变量"><a href="#3-5-1-const修饰成员变量" class="headerlink" title="3.5.1 const修饰成员变量"></a>3.5.1 const修饰成员变量</h5><p>const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        …</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> nValue;         <span class="comment">//成员常量不能被修改</span></span><br><span class="line">        …</span><br><span class="line">        A(<span class="keyword">int</span> x): nValue(x) &#123; &#125; ; <span class="comment">//只能在初始化列表中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-2-const修饰成员函数"><a href="#3-5-2-const修饰成员函数" class="headerlink" title="3.5.2 const修饰成员函数"></a>3.5.2 const修饰成员函数</h5><p>const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。<strong>也就是说，这些函数是”只读”函数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        …</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//常成员函数, 它不改变对象的成员变量.                        </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也不能调用类中任何非const成员函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。</p><p>a. const成员函数不被允许修改它所在对象的任何一个数据成员。</p><p>b. const成员函数能够访问对象的const成员，而其他成员函数不可以。</p><h5 id="3-5-3-const修饰类对象-对象指针-对象引用"><a href="#3-5-3-const修饰类对象-对象指针-对象引用" class="headerlink" title="3.5.3 const修饰类对象/对象指针/对象引用"></a>3.5.3 const修饰类对象/对象指针/对象引用</h5><p>·             const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。</p><p>·             const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。</p><p>·             const对象只能访问const成员函数，而非const对象可以访问任意的成员函数,包括const成员函数。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAA</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> AAA aObj;</span><br><span class="line">aObj.func1();<span class="comment">// invalid</span></span><br><span class="line">aObj.func2();<span class="comment">// valid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AAA* aObj = <span class="keyword">new</span> AAA();</span><br><span class="line">aObj-&gt; func1();<span class="comment">// invalid</span></span><br><span class="line">aObj-&gt; func2();<span class="comment">// valid</span></span><br></pre></td></tr></table></figure><h5 id="3-5-4-const修饰重载运算符"><a href="#3-5-4-const修饰重载运算符" class="headerlink" title="3.5.4 const修饰重载运算符"></a>3.5.4 const修饰重载运算符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> student &amp;a ) <span class="keyword">const</span>&#123;     </span><br><span class="line">        <span class="keyword">if</span>(score!=a.score) <span class="keyword">return</span> score&lt;a.score;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(name.compare(a.name)!=<span class="number">0</span>) <span class="keyword">return</span> name&lt;a.name;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(age!=a.age)<span class="keyword">return</span> age&lt;a.age;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>加const是因为：</strong></p><ol><li><p>我们不希望在这个函数中对用来进行赋值的“原版”做任何修改。<strong>函数加上const后缀的作用是表明函数本身不会修改类成员变量。</strong></p></li><li><p>加上const，对于const的和非const的实参，函数就能接受；如果不加，就只能接受非const的实参。</p></li></ol><p><strong>另外补充，用引用是因为：</strong><br>这样可以避免在函数调用时对实参的一次拷贝，提高了效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 指针变量，指向常对象</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure><h3 id="4-const对象默认为文件局部变量"><a href="#4-const对象默认为文件局部变量" class="headerlink" title="4.const对象默认为文件局部变量"></a>4.const对象默认为文件局部变量</h3><p>注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p><h3 id="5-相关文章"><a href="#5-相关文章" class="headerlink" title="5.相关文章"></a>5.相关文章</h3><ul><li>C++ Primer中文版第5版</li><li>C++ Primer Plus中文版第五版</li><li><a href="https://blog.csdn.net/Eric_Jo/article/details/4138548" target="_blank" rel="noopener">https://blog.csdn.net/Eric_Jo/article/details/4138548</a></li><li><a href="https://interview.huihut.com/#/?id=const" target="_blank" rel="noopener">https://interview.huihut.com/#/?id=const</a></li><li><a href="https://blog.csdn.net/qq_36770641/article/details/89884807" target="_blank" rel="noopener">https://blog.csdn.net/qq_36770641/article/details/89884807</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用指令小结</title>
      <link href="/2020/06/02/git/"/>
      <url>/2020/06/02/git/</url>
      
        <content type="html"><![CDATA[<!--<font face="黑体" size=6>Git常用指令小结</font>--><p>废话不多说，直接总结，方便自己以后查~</p><h2 id="1-获得项目的git仓库"><a href="#1-获得项目的git仓库" class="headerlink" title="1.获得项目的git仓库"></a>1.获得项目的git仓库</h2><h3 id="1-1通过git-init初始化本地的新仓库"><a href="#1-1通过git-init初始化本地的新仓库" class="headerlink" title="1.1通过git init初始化本地的新仓库"></a>1.1通过git init初始化本地的新仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir git</span><br><span class="line"><span class="built_in">cd</span> git</span><br><span class="line">git init <span class="comment"># 初始化git仓库</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-2通过git-clone克隆已有的仓库"><a href="#1-2通过git-clone克隆已有的仓库" class="headerlink" title="1.2通过git clone克隆已有的仓库"></a>1.2通过git clone克隆已有的仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><p>比如克隆一个具体的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RaoXuntian/raoxuntian.github.io.git</span><br></pre></td></tr></table></figure><p>如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RaoXuntian/raoxuntian.github.io.git myBlog</span><br></pre></td></tr></table></figure><p>如果希望克隆时直检出指定的分支，可以指定 <code>-b &lt;分支名&gt;</code> 选项，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo https://github.com/RaoXuntian/raoxuntian.github.io.git myBlog</span><br></pre></td></tr></table></figure><p>通常clone命令会把整个仓库的(包含所有分支的)版本数据给克隆下来，如果只想获取某个分支的版本数据，只需要加上 <code>--single-branch</code>选项，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --single-branch -b hexo https://github.com/RaoXuntian/raoxuntian.github.io.git myBlog</span><br></pre></td></tr></table></figure><p>如果你想在克隆仓库时给仓库设置一些不同于全局的git配置，可以通过 <code>--config</code> 选项，其简写选项是 <code>-c</code>，比如，你想给克隆的仓库设置 用户名 和 邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --config user.name=小饶 -c user.email=raoxuntian@gmail.com https://github.com/RaoXuntian/raoxuntian.github.io.git myBlog</span><br></pre></td></tr></table></figure><h2 id="2-添加跟踪文件、暂存"><a href="#2-添加跟踪文件、暂存" class="headerlink" title="2.添加跟踪文件、暂存"></a>2.添加跟踪文件、暂存</h2><p>用命令git add告诉Git，把文件添加到仓库(实际上就是把文件修改添加到暂存区)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br><span class="line"></span><br><span class="line">git add -A</span><br></pre></td></tr></table></figure><h2 id="3-提交更新"><a href="#3-提交更新" class="headerlink" title="3.提交更新"></a>3.提交更新</h2><p>用命令git commit告诉Git，把文件提交到仓库(实际上就是把暂存区的所有内容提交到当前分支)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"有意义的附加说明"</span></span><br></pre></td></tr></table></figure><h2 id="4-检测当前工作区状态"><a href="#4-检测当前工作区状态" class="headerlink" title="4.检测当前工作区状态"></a>4.检测当前工作区状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">git status -sb</span><br></pre></td></tr></table></figure><h2 id="5-查看修改内容"><a href="#5-查看修改内容" class="headerlink" title="5.查看修改内容"></a>5.查看修改内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><h2 id="6-移除文件"><a href="#6-移除文件" class="headerlink" title="6.移除文件"></a>6.移除文件</h2><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm 文件</span><br></pre></td></tr></table></figure><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆.a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件</span><br></pre></td></tr></table></figure><p>后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm <span class="built_in">log</span>/\*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有log/ 目录下扩展名为 .log 的文件。类似的比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm \*~</span><br></pre></td></tr></table></figure><p>会递归删除当前目录及其子目录中所有 ~ 结尾的文件。</p><h2 id="7-查看历史"><a href="#7-查看历史" class="headerlink" title="7.查看历史"></a>7.查看历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline   <span class="comment">#——要求版本信息只能在一行中显示</span></span><br></pre></td></tr></table></figure><h2 id="8-撤销修改"><a href="#8-撤销修改" class="headerlink" title="8.撤销修改"></a>8.撤销修改</h2><h3 id="8-1修改最后一次提交"><a href="#8-1修改最后一次提交" class="headerlink" title="8.1修改最后一次提交"></a>8.1修改最后一次提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。<br> 如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 <code>--amend</code> 提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'initial commit'</span></span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p><h3 id="8-2取消已经暂存的文件"><a href="#8-2取消已经暂存的文件" class="headerlink" title="8.2取消已经暂存的文件"></a>8.2取消已经暂存的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;…</span><br></pre></td></tr></table></figure><h3 id="8-3取消对文件的修改"><a href="#8-3取消对文件的修改" class="headerlink" title="8.3取消对文件的修改"></a>8.3取消对文件的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;…</span><br></pre></td></tr></table></figure><p>命令git checkout – filename意思就是，把filename文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是filename自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是filename已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，版本回退，不过前提是没有推送到远程库。</p><h2 id="9-移动文件"><a href="#9-移动文件" class="headerlink" title="9.移动文件"></a>9.移动文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv 文件_from  文件_to</span><br></pre></td></tr></table></figure><p>其实，运行 git mv 就相当于运行了下面三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv  文件_from  文件_to </span><br><span class="line">git rm  文件_from </span><br><span class="line">git add  文件_to</span><br></pre></td></tr></table></figure><h2 id="10-远程仓库"><a href="#10-远程仓库" class="headerlink" title="10.远程仓库"></a>10.远程仓库</h2><h3 id="10-1查看当前远程库"><a href="#10-1查看当前远程库" class="headerlink" title="10.1查看当前远程库"></a>10.1查看当前远程库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><p>查看当前配置的远程仓库。它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v ：（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址，提供更多信息；</span><br></pre></td></tr></table></figure><h3 id="10-2添加远程仓库"><a href="#10-2添加远程仓库" class="headerlink" title="10.2添加远程仓库"></a>10.2添加远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [仓库名] [url]</span><br></pre></td></tr></table></figure><p>添加一个新的远程仓库，指定名字为 <code>仓库名</code>，以便将来引用；</p><h3 id="10-3从远程仓库抓取数据"><a href="#10-3从远程仓库抓取数据" class="headerlink" title="10.3从远程仓库抓取数据"></a>10.3从远程仓库抓取数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [远程仓库名]</span><br></pre></td></tr></table></figure><p>此命令会到名为 <code>远程仓库名</code> 的远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。</p><p>如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，<code>git fetch origin</code> 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。<br> 如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用 <code>git pull</code>  命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 <code>git clone</code> 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 <code>git pull</code>，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p><h3 id="10-4推送数据到远程仓库"><a href="#10-4推送数据到远程仓库" class="headerlink" title="10.4推送数据到远程仓库"></a>10.4推送数据到远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库S] [本地分支L]:[远程分支R]</span><br></pre></td></tr></table></figure><p>表示：把 <code>本地分支L</code> 推送到 <code>远程仓库S</code> 的 <code>远程分支R</code> 中，如果 <code>远程仓库S</code> 中不存在 <code>远程分支R</code>，则会在 <code>远程仓库S</code> 中 创建 <code>远程分支R</code> 并把 <code>本地分支L</code> 推送到 <code>远程分支R</code> 中；如果本地分支L和远程分支R名字相同，则可以简写为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库S] [本地分支L]</span><br></pre></td></tr></table></figure><p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那 你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p><h3 id="10-5删除远程分支"><a href="#10-5删除远程分支" class="headerlink" title="10.5删除远程分支"></a>10.5删除远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库S] :[远程分支R]</span><br></pre></td></tr></table></figure><p>这个命令的格式意义比较无理头，为了方便记忆，可以这样理解：它是省略了本地分支名的推送命令 <code>git push [远程仓库S] [本地分支L]:[远程分支R]</code>，省略 <code>本地分支L</code> 表示：在这里提取空白然后把它变成 <code>远程分支R</code>。</p><h3 id="10-6查看远程仓库信息"><a href="#10-6查看远程仓库信息" class="headerlink" title="10.6查看远程仓库信息"></a>10.6查看远程仓库信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [远程仓库名]</span><br></pre></td></tr></table></figure><p>查看名为 <code>远程仓库名</code> 的远程仓库的详细信息</p><h3 id="10-7远程仓库的重命名"><a href="#10-7远程仓库的重命名" class="headerlink" title="10.7远程仓库的重命名"></a>10.7远程仓库的重命名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename  [远程仓库旧名]   [远程仓库新名]</span><br></pre></td></tr></table></figure><p>修改某个远程仓库在本地的名称（新版 Git 中支持）；<br>注意，对远程仓库的重命名，也会使对应的分支名称发生变化;</p><h3 id="10-8远程仓库的删除"><a href="#10-8远程仓库的删除" class="headerlink" title="10.8远程仓库的删除"></a>10.8远程仓库的删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm  [远程仓库名]</span><br></pre></td></tr></table></figure><h3 id="10-9本地仓库同步远程仓库"><a href="#10-9本地仓库同步远程仓库" class="headerlink" title="10.9本地仓库同步远程仓库"></a>10.9本地仓库同步远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/RaoXuntian/raoxuntian.github.io.git<span class="comment"># 本地添加远程仓库</span></span><br><span class="line">git push -u origin master:hexo<span class="comment"># 本地master分支同步到远程的hexo分支</span></span><br></pre></td></tr></table></figure><h2 id="11-分支"><a href="#11-分支" class="headerlink" title="11.分支"></a>11.分支</h2><h3 id="11-1新建分支"><a href="#11-1新建分支" class="headerlink" title="11.1新建分支"></a>11.1新建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch  [分支名]</span><br></pre></td></tr></table></figure><p>注意：此命令仅仅是建立了一个新的分支，但不会自动切换到这个分支中去；</p><h3 id="11-2切换分支"><a href="#11-2切换分支" class="headerlink" title="11.2切换分支"></a>11.2切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [分支名]</span><br></pre></td></tr></table></figure><h3 id="11-3新建并切换分支"><a href="#11-3新建并切换分支" class="headerlink" title="11.3新建并切换分支"></a>11.3新建并切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [分支名]</span><br></pre></td></tr></table></figure><p>相当于以下2条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch [分支名]</span><br><span class="line">git checkout [分支名]</span><br></pre></td></tr></table></figure><h3 id="11-4合并分支"><a href="#11-4合并分支" class="headerlink" title="11.4合并分支"></a>11.4合并分支</h3><p>设当前分支为A</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [分支B]</span><br></pre></td></tr></table></figure><p>此命令表示，把分支B合并到分支A</p><h3 id="11-5删除分支"><a href="#11-5删除分支" class="headerlink" title="11.5删除分支"></a>11.5删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [分支名]</span><br></pre></td></tr></table></figure><h3 id="11-6强制删除分支"><a href="#11-6强制删除分支" class="headerlink" title="11.6强制删除分支"></a>11.6强制删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D [分支名]</span><br></pre></td></tr></table></figure><h3 id="11-7查看当前分支列表"><a href="#11-7查看当前分支列表" class="headerlink" title="11.7查看当前分支列表"></a>11.7查看当前分支列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch -a <span class="comment"># 包括远端的分支</span></span><br></pre></td></tr></table></figure><p>返回结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* master</span><br><span class="line">  remotes&#x2F;origin&#x2F;hexo</span><br></pre></td></tr></table></figure><p>带有 <code>*</code> 的分支表示是当前所在的分支；</p><h3 id="11-8查看各个分支最后一次提交对象的信息"><a href="#11-8查看各个分支最后一次提交对象的信息" class="headerlink" title="11.8查看各个分支最后一次提交对象的信息"></a>11.8查看各个分支最后一次提交对象的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><h3 id="11-9查看已经合并到当前所在分支的分支"><a href="#11-9查看已经合并到当前所在分支的分支" class="headerlink" title="11.9查看已经合并到当前所在分支的分支"></a>11.9查看已经合并到当前所在分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure><h3 id="11-10查看未合并到当前所在分支的分支"><a href="#11-10查看未合并到当前所在分支的分支" class="headerlink" title="11.10查看未合并到当前所在分支的分支"></a>11.10查看未合并到当前所在分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure><h3 id="11-11删除远程分支"><a href="#11-11删除远程分支" class="headerlink" title="11.11删除远程分支"></a>11.11删除远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [远程仓库S] :[远程分支R]</span><br></pre></td></tr></table></figure><p>这个命令的格式意义比较无理头，为了方便记忆，可以这样理解：它是省略了本地分支名的推送命令 <code>git push [远程仓库S] [本地分支L]:[远程分支R]</code>，省略 <code>本地分支L</code> 表示：在这里提取空白然后把它变成 <code>远程分支R</code>。</p><h2 id="12-恢复之前的版本"><a href="#12-恢复之前的版本" class="headerlink" title="12.恢复之前的版本"></a>12.恢复之前的版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看之前版本号</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 版本回退</span></span><br><span class="line">git reset --hard 目标版本号</span><br><span class="line"><span class="comment"># 提交更改</span></span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><h2 id="13-相关文章"><a href="#13-相关文章" class="headerlink" title="13.相关文章"></a>13.相关文章</h2><ul><li><a href="https://github.com/windard/learngit/blob/master/git.txt" target="_blank" rel="noopener">https://github.com/windard/learngit/blob/master/git.txt</a></li><li><a href="https://www.jianshu.com/p/15a4dee9c5df" target="_blank" rel="noopener">https://www.jianshu.com/p/15a4dee9c5df</a></li><li><a href="https://blog.csdn.net/yxlshk/article/details/79944535" target="_blank" rel="noopener">https://blog.csdn.net/yxlshk/article/details/79944535</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/05/29/myFirstBlog/"/>
      <url>/2020/05/29/myFirstBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h2><p>现在是凌晨四点钟，我依旧失眠。</p><p>花了一天半的时间，终于搭建好了第一个个人博客。</p><p>其实本来只想花一天的时间来搭建，但因为一些不能拒绝的琐事而耽误了；</p><p>我虽然不是完美主义者，但也希望这个博客能以最完美的功能和版本online，原本准备在六一正式上线这个博客，但现在必须得提前了，尽管她并不完美……</p><a id="more"></a><h2 id="Welcome-to-my-Salad-Days！"><a href="#Welcome-to-my-Salad-Days！" class="headerlink" title="Welcome to my Salad Days！"></a><em>Welcome to my Salad Days！</em></h2><p><img src="https://tva2.sinaimg.cn/large/005LF7wugy1gf9710jjt1j30j60y3jwp.jpg" alt="image"></p><h2 id="who-am-I"><a href="#who-am-I" class="headerlink" title="who am I ?"></a>who am I ?</h2><p>我是华中科技大学计算机技术专业的硕士研究生，你们可以叫我小饶。</p><p>我曾是一名志愿者，在云南财经大学信息学院青年志愿者协会工作三年。</p><p>我是经常熬夜失眠头秃的孤独患者。</p><p><img src="https://tvax4.sinaimg.cn/large/005LF7wugy1gf97efs2ysj30ib0wlag2.jpg" alt="image"></p><h2 id="what-I-do"><a href="#what-I-do" class="headerlink" title="what I do ?"></a>what I do ?</h2><p>我一开始在实验室研究机器学习和自然语言处理方向的算法，一年的时间也确实自己do了一些算法，但去找实习的时候发现连简历都过不了关，于是现在准备转做工程项目吧，做个低端码农，立志从后端走向全栈。</p><p>我对计算机和编程并没有充满热情，只是比起其他专业，可能这个专业更适合我吧……</p><p>我也不是大佬，我只希望明年毕业的时候能有一份对得起”华科“这个标签的offer。</p><p><img src="https://tvax1.sinaimg.cn/large/005LF7wugy1gf97fj20moj30j60y4qa1.jpg" alt="image"></p><h2 id="what-I-love-？"><a href="#what-I-love-？" class="headerlink" title="what I love ？"></a>what I love ？</h2><p>我喜欢聊天，但我不喜欢闲聊。</p><blockquote><p>我想谈论原子、 死亡、性、外星人、 魔法、智力、生命的意义、遥远的星系，让你想跳舞的音乐、有趣的回忆、你说的谎言、你的缺点、你最喜欢的气味、你的童年、让你彻夜难眠的东西、你的不安全感和恐惧。</p></blockquote><p>我喜欢生活，喜欢记录美好。</p><p>我喜欢五月天。</p><p>我喜欢粤语歌，喜欢张敬轩，喜欢陈奕迅，喜欢杨千嬅。</p><p>我喜欢林夕和黄伟文的词。</p><p><img src="https://tva2.sinaimg.cn/large/005LF7wugy1gf97fw5l15j30j60y3dlv.jpg" alt="image"></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>做这个博客的愿景是希望记录自己成长的点点滴滴，希望自己不是三分钟热度吧.</p><p>六一也快到了，祝我自己六一快乐 :)</p><p><img src="https://tvax1.sinaimg.cn/large/005LF7wugy1gf97g5muo3j30j60y4wjs.jpg" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
